[{"header":" ES5和ES6中对于继承的实现方法","time":" 2016-07-23 23:32:17","tags":" [javascript]","description":" develop cross-platform GUI app with electron","section":"\n在ES5继承的实现非常有趣的，由于没有传统面向对象类的概念，Javascript利用原型链的特性来实现继承，这其中有很多的属性指向和需要注意的地方。\n原型链的特点和实现已经在之前的一篇整理说过了，就是通过将子类构造函数的原型作为父类构造函数的实例，这样就连通了子类-子类原型-父类，原型链的特点就是逐层查找，从子类开始一直往上直到所有对象的原型Object.prototype，找到属性方法之后就会停止查找，所以下层的属性方法会覆盖上层。\n<!--more-->\n一个基本的基于原型链的继承过程大概是这样的：\n```\n//先来个父类，带些属性\nfunction Super(){\n    this.flag = true;\n}\n//为了提高复用性，方法绑定在父类原型属性上\nSuper.prototype.getFlag = function(){\n    return this.flag;\n}\n//来个子类\nfunction Sub(){\n    this.subFlag = false;\n}\n//实现继承\nSub.prototype = new Super;\n//给子类添加子类特有的方法，注意顺序要在继承之后\nSub.prototype.getSubFlag = function(){\n    return this.subFlag;\n}\n//构造实例\nvar es5 = new Sub;\n```\n原型链实现的继承主要有几个问题：\n1、本来我们为了构造函数属性的封装私有性，方法的复用性，提倡将属性声明在构造函数内，而将方法绑定在原型对象上，但是现在子类的原型是父类的一个实例，自然父类的属性就变成子类原型的属性了；\n这就会带来一个问题，我们知道构造函数的原型属性在所有构造的实例中是共享的，所以原型中属性的改变会反应到所有的实例上，这就违背了我们想要属性私有化的初衷；\n2、创建子类的实例时，不能向父类的构造函数传递参数\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n   this.subFlag = false;\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nobj.flag = flase;  //修改之后，由于是原型上的属性，之后创建的所有实例都会受到影响\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //false；\n```\n为了解决以上两个问题，有一个叫借用构造函数的方法\n只需要在子类构造函数内部使用apply或者call来调用父类的函数即可在实现属性继承的同时，又能传递参数，又能让实例不互相影响\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n    Super.call(this)  //如果父类可以需要接收参数，这里也可以直接传递\n}\nvar obj = new Sub();\nobj.flag = flase;\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //依然是true，不会相互影响\n```\n结合借用构造函数和原型链的方法，可以实现比较完美的继承方法，可以称为组合继承：\n```\nfunction Super(){\n    this.flag = true;\n}\nSuper.prototype.getFlag = function(){\n    return this.flag;     //继承方法\n}\nfunction Sub(){\n    this.subFlag = flase\n    Super.call(this)    //继承属性\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nSuper.prototype.getSubFlag = function(){\n    return this.flag;\n}\n```\n这里还有个小问题，Sub.prototype = new Super;  会导致Sub.prototype的constructor指向Super;\n然而constructor的定义是要指向原型属性对应的构造函数的，Sub.prototype是Sub构造函数的原型，所以应该添加一句纠正：\nSub.prototype.constructor = Sub;\n\n看完ES5的实现，再来看看ES6的继承实现方法，其内部其实也是ES5组合继承的方式，通过call借用构造函数，在A类构造函数中调用相关属性，再用原型链的连接实现方法的继承\n```\nclass B extends A {\n  constructor() {\n    return A.call(this);  //继承属性\n  }\n}\nA.prototype = new B;  //继承方法  \n```\nES6封装了class，extends关键字来实现继承，内部的实现原理其实依然是基于上面所讲的原型链，不过进过一层封装后，Javascript的继承得以更加简洁优雅地实现\n```\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 等同于parent.constructor(x, y)\n    this.color = color;\n  }\n  toString() {\n    return this.color + ' ' + super.toString(); // 等同于parent.toString()\n  }\n}\n```\n通过constructor来定义构造函数，用super调用父类的属性方法\n\nES6中Class充当了ES5中，构造函数在继承实现过程中的作用\n同样有原型属性prototype，以及在ES5中用来指向构造函数原型的`__proto__`属性，这个属性在ES6中的指向有一些主动的修改。\n一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法继承。\n```\nclass A extends B {}\nA.__proto__ === B;  //继承属性\nA.prototype.__proto__ === B.prototype;  //继承方法\n```\nES6的子类的`__proto__`是父类，子类的原型的`__proto__`是父类的原型\n第二条继承链理解起来没有什么问题，对应到ES5中的A.prototype = new B;A.prototype作为B构造的实例，指向构造函数B的原型B.prototype，\n但是在ES5中A.`__proto__`是指向Function.prototype的，因为每一个构造函数其实都是Function这个对象构造的，ES6中子类的`__proto__`指向父类可以实现属性的继承，在ES5中在没有用借用继承的时候由于父类属性被子类原型继承，所有的子类实例实际上都是同一个属性引用。\n在ES6中实现了子类继承父类属性，在构造实例的时候会直接拿到子类的属性，不需要查找到原型属性上面去，ES6新的静态方法和静态属性（只能在构造函数上访问）也是通过这样类的直接继承来实现，至于普通复用方法还是放到原型链上，道理和实现和ES5是一样的。\n此外我认为这里修改A.`__proto__`的指向是有意区分ES6中继承和实例化，同时建立子类和父类直接的关系，ES5的子类的构造函数通过子类的原型与父类的构造函数连接，不存在直接的关系；\n可以这么说，在ES5继承和构造实例，ES6构造实例的时候可以理解`__proto__`原型指针是用来指向构造函数的原型的，但是在ES6继承中，`__proto__`指继承自哪个类或原型，在A继承B之后，构造一个实例 var obj = new A; 会发现它所有的属性指向都是和ES5一致的。\n\n\n有个有趣的地方：ES6继承是在父类创建this对象，在子类constructor中来修饰父类的this，ES5是在子类创建this，将父类的属性方法绑定到子类，由于原生的构造函数（Function，Array等）没有this，子类无法通过call/apply(this)获得其内部属性，所以在ES5无法继承，ES6实现后可以为原生构造函数封装一些有趣的接口，比方说阮一峰老师的这个给Array实例封装一个版本记录和回滚的方法：\n```\nclass VersionedArray extends Array {\n  constructor() {\n    super();\n    this.history = [[]];\n  }\n  commit() {\n    this.history.push(this.slice());\n  }\n  revert() {\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  }\n}\n\nvar x = new VersionedArray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\nx.push(3);\nx // [1, 2, 3]\n\nx.revert();\nx // [1, 2]\n```\n最后做一个ES5和ES6的继承小结：\nES5最经典的继承方法是用组合继承的方式，原型链继承方法，借用函数继承属性，ES6也是基于这样的方式，但是封装了更优雅简洁的api，让Javascript越来越强大，修改了一些属性指向，规范了继承的操作，区分开了继承实现和实例构造，此外ES6继承还能实现更多的继承需求和场景。\n\n\n\n\n\n\n"},{"header":" HTTP缓存及众多的web储存概念之小整理","time":" 2016-08-12 01:46:57","tags":" [javascript,html]","description":" this is a article for my way of studying front-end","section":"\n缓存对于一个网站来说非常重要，可以提高网站性能，减少冗余的数据传输，增加服务器负担，web存储则给浏览器提供了更加强大的保存文件的接口。\n有相当一段时间一直混淆了HTTP缓存相关的属性，HTML5离线存储和本地储存的一些关系，最近好好地整理了一下这些Web存储相关的东西\n\n先列出一些相关属性和概念，看看能否理清它们之间的区别和联系？\n<!--more-->\n\n* manifest\n* cache-control\n* expires\n* 304(no modified)\n* ETag\n* If-None-Match\n* Last-Modified\n* If-Modified-Since\n* http-equiv\n* webstorage\n* cookie/session\n\n是不是感觉有点凌乱，那就跟着我整理的笔记走一遍吧：）\n首先说一说HTTP缓存相关的东西:\n　　\n　　\n`Cache-Control`\n每一个用HTTP请求的资源都可以在响应头用Cache-Control来给浏览器定义缓存策略，通过设置一些属性值它可以控制谁可以，在什么条件下可以缓存响应，还有缓存的有效期，这个属性的一些常用值如下\n\n`no-cache：`表示不使用缓存，先和服务器确认要返回的资源是否有修改\n`no-store：`表示禁止浏览器和所有中继缓存响应的资源\n`max-age=100：`表示缓存的有效期，单位是秒，这一段时间内，除非缓存文件发生一些变动，否则会直接使用之前的缓存，注意这段时间内是不会发Etag等方法去验证的资源有没有修改的。缓存的文件发生变动，主要有这些情况：资源名更改，资源地址更改，缓存被删除，网页强制刷新等；资源名更改，给文件名添加版本hash值，比如给image.png修改为image-hash.png，可以保证每次更新文件时用户可以重新发出请求，获取最新的资源。资源路径更改，修改文件的请求路径，比如给image.png添加查询参数修改为image.png?hash，max-age的时间设置根据每个网站的实际情况不同去设置，一种极端的做法是把这个值设置很大，然后通过修改资源名或者给资源请求地址添加查询参数，来告诉浏览器该更新资源了，一般用在很久才更新网站的情况\n`public：`用max-age即是默认public了，不用设置\n`private：`私人缓存，中继缓存不被允许，但是可以在浏览器缓存\n\n`PS：expires：`表示存在的时间，使客户端在这个设置的时间之前不用去请求资源，类似于max-age，但是expires表示的是一个固定时间，而且可能有服务器和客户端时间不一致的问题，主要用于HTTP1.0版本，在HTTP1.1版本完全可以用功能更强的Cache-Control来替代，和max-age同时存在时expiers会被覆盖掉\n`PS：http-equiv：`缓存有两种控制机制，一种是请求头信息控制，另外一种就是利用meta标签；可以在HTML文档中为meta标签设置http-equiv为相应属性名，content为值来设置缓存，例如\n`<meta http-equiv=\"Expires\" content=\"Mon, 20 Jul 2009 23:00:00 GMT\" />`，不过只对改网页的HTML文件有缓存作用，对该页面的其他资源以及其他页面的HTML文件都没有作用\n　　\n　　\n那么max-age（expires）到期之后，在no-cache下的资源会先和服务器确认返回的资源是否有修改，如何实现这一过程？\n`ETag/If-None-Match，Last-Modified/If-Modified-Since`\nETag (Entity Tag)其实就是一个验证令牌，用来标识一个资源，可能是一个hash值，也可能是一个版本号，每当资源有修改的时候ETag的值就会改变\n浏览器第一次请求之后会保存响应头的ETag值，以便下一次发送请求的时候校验Etag是否有更改。\n　　\n　　\n那么下一次浏览器如何告诉服务器本地已经存有Etag和相应的资源了呢？If-None-Match\n通过在请求头添加If-None-Match(如果存在ETag，浏览器会自动添加)，赋值为上一次请求后在本地存储的Etag值，服务器会和服务端最新资源的Etag比对，如果没有更改会直接返回304 no modified给浏览器，浏览器就直接使用本地缓存的文件\n\n`PS：Last-Modified/If-Modified-Since`的作用等同于`ETag/If-None-Match，`不过前者是通过规定一个时间来比对，最小的单位是秒，后者通过一个唯一标识符，所以可以看出来如果原站在一秒内有多次更新，那么前者就不顶用啦。\nETag的验证要优先于Last-Modified，此外ETag也是有缺点的，在分布式的环境中，Etag在不同服务器上的同步问题可能会给服务器带来一些压力。\n　　\n　　\n`HTTP缓存`是和每一个HTTP请求直接相关的，每一个请求资源的响应都有相应的缓存策略，它们往往是相似的，是否可以通过其他的机制，直接告诉浏览器去缓存哪一些文件呢？\n`HTML5离线存储`闪亮出场\n\nH5离线存储：服务器通过一份.manifest文件给浏览器提供一份完备的缓存名单，名单包括需要缓存的文件，不需要缓存的文件的列表之外，还有一些其他的功能，比如给资源设置备选的请求地址，设置404页面等\n\n实现：利用H5的标签新属性manifest，只需要在HTML文件添加`<html manifest=\"test.manifest\">，`服务器则将manifest文件的mime-type设置为text/cache-manifest类型即可，浏览器每次请求会检查`manifest`是否有更新，服务端通过修改manifest文件，即可在浏览器下一次请求资源的时候通知其更新相应的资源。\n作用：通过本地离线存储可以在没有网络的情况下访问网站事先保存的文件资源，在有网络的情况下直接使用本地资源也可以减少请求连接的压力，提高网页的加载速度，注意这里和HTTP缓存的区别，它是直接使用本地资源，请求返回的是200（from cache）,由于有manifest来统一管理，所以不需要发请求查看是否有更新，也没有过期时间。\n　\n`PS：`这里关于manifest文件自身的更新问题，还是要走HTTP缓存，或者直接不缓存这个文件。\n　　\n　　\n前面提到的概念主要都是缓存请求文件这一块的东西，它们的目的都是为了提高网页的性能，可以说是一种优化型的存储，可以给用户带来更流畅的体验\n但是我们印象中还有一种存储，它可以给我们提供更多的可能和效果的实现，是功能型的存储，如H5本地储存`Webstorage，cookie，session`\n　　\n　　\n`cookie，session`\n众所周知，HTTP是无状态的协议，每一次请求都是独立没有联系的，浏览器和服务器都没有办法维持用户的状态，判断用户是不是依然是之前的那个用户。\n很容易可以想到，在同一个用户的每个请求头添加一个唯一标识符，通过判断这个标识符就可以维持用户的一些信息和状态\n会话信息被用来作为标识符解决这个问题，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案（服务端保持状态也需要客户端保持状态，所以一般session都要基础cookie或者sessionstorage）\n\n总的来说：cookie数据放在客户端，session数据放在服务端，cookie可以设置期限，session则是关闭浏览器时销毁（cookie默认也是），cookie不安全，session可能会影响服务器性能\n\n`Cookie：`通常用Javascript封装一个setCookie的函数来创建，有大小限制，可能会导致请求头过于臃肿，浏览器发送请求时，检查本地cookie，如果该cookie声明的范围大于发送请求的url地址时，就会自动在请求上添加cookie字段\n\n`session：`服务器每次会检查浏览器请求头的session标识，如果有则将这个session id在服务器的数据库（散列表）查找，找到后才进行相应权限的操作\n如果没有这个请求标识，则为客户端新建一个，返回给客户端后，客户端可以通过cookie或者sessionstorage来保存这个session id，通过请求头的cookie字段来给服务器提供sessionId，当cookie被禁止时就需要一些其他方法，通常是采用添加到url路径中，添加表单隐藏域等方法\n\ncookie作为HTTP协议规范的一部分，主要还是用来储存用户信息的，用来和服务端交互，大小也有限制，仅仅只是一种会话级别的存储\n　　\n　　\n`localstorage，sessionstorage`\n`webstorage`为了更大的存储文件设计，与Cookie负责记录用户信息相比，webStorage专注于本地存储，通过封装好的setItem，getItem等方法即可使用\nlocalstorage是一种持久化的存储，除非主动删除，否则永远存在，sessionstorage主要用来存储会话（session），关闭浏览器就会销毁，是一种非持久化的存储\n　　\n　　\n除了上面这些的概念之外，还有诸如像IndexDB，FileSystem等存储方法，关于Web存储的知识真的非常多，看上去坑也是不少，还需要实践慢慢来掌握。\n\n\n\n\n\n\n\n\n\n"},{"header":" JavaScript关键概念理解之闭包","time":" 2016-07-10 21:59:48","tags":" [javascript]","description":" none","section":"\nJavaScript作为一种多范式编程语言，和许多函数式编程语言一样拥有闭包的概念。\n闭包是一个老生常谈的问题，前端面试必问，要理解闭包的原理，必须知道什么是词法作用域，理解词法作用域，又需要对Javascript另外两个关键概念的掌握和理解~\n\n<!--more-->\n\n#### 执行环境和作用域链\n执行环境：红宝书将执行环境称为Javascript这么编程语言最为重要的一个概念，一开始我是不服的，屌屌的闭包和原型链呢？后来一番整理，才发现原来闭包和原型链的实现都是依赖于执行环境。\n执行环境定义了变量或者函数有权访问的数据，决定了它们各自的行为，每个执行环境拥有一个变量对象来保存环境中定义的所有变量和函数。\n每个函数都有自己的执行环境，每次执行语句进入函数后，就会将相应函数的执行函数压入环境栈中，执行完函数之后就会弹出，将控制权交给原来的执行环境。\n\n作用域链：作用域链用来保证执行环境中，对所有环境有权访问的变量或者函数的有序访问。每一个执行环境会为自身的变量对象创建一个作用域链，作用域的前端始终是当前执行环境的变量对象，会一直向外延伸到全局作用环境，执行环境查询变量和函数的顺序遵循从局部到全局，一旦找到就会停止查找。\n\n执行环境和作用域是很多概念和一些实现方法的基础，在Javascript里，执行环境决定了访问的权限，作用域链决定了访问的顺序。\n\n#### 闭包和词法作用域\n闭包：闭包就是一个作用域内定义的一个函数，由于Javascript没有块级作用域，局部作用域的形成依赖于函数来实现，所以也可以说闭包是一个函数里定义的一个函数。由于闭包的一个作用就是用来访问其他函数作用域中的变量，所以它又有一种定义：闭包指有权访问另一个函数作用域中变量的一个函数。\n先看一段代码\n```\nname = 'hi';\nfunction close(){\n    name = 'hello';\n    return function sayName(){\n        console.log(name)\n    }\n}\nvar sayName = close();\nsayName();\n```\n词法作用域：在这段代码中console出来的是hello，也就是说sayName执行过程中的name值取得是close函数内部的Name，而不是外部全局环境的name；根据上面对执行环境的理解，当进入sayName这个函数之后，执行环境就由全局进入局部环境，注意到每次定义函数的同时就会生成该函数的执行环境，所以sayName是在哪里声明的，它的外部执行环境就是谁，在这里就是close这个函数的执行环境，再根据上面对作用域链的理解，sayName对于name变量的查询将到此为止，不会到全局去，所以name的值就是hello，而不是hi，简单的说，sayName这个函数所属的作用域是声明它的时候所在的作用域，而不是运行它的时候，高端地说，这就是Javascript的词法作用域。\n\n依照作用域链的原理，本来全局执行环境是没有办法访问到局部执行环境的，但是由于词法作用域的原因，使得sayName这个闭包（全局环境）拥有了访问close内部name变量（局部环境）的能力。\n\n#### 闭包和this关键字\n闭包经常会和this关键字配合使用，每个函数在被调用的时候都会自动获得两个特殊变量，一个是arguments，另一个就是this，所以在一些多层嵌套return的闭包中，无法同过this来正确获得外层的this，因为作用域链在最里层的函数找到this后就停止了，所以一般都需要用一个中间变量来存储或者用bind方法绑定外层的this指向\n```\nvar name = 'hi';\nvar obj = {\n    name:'hello';\n    getName:function(){\n        //var that = this;\n        return function(){\n            return this.name;\n        }\n    }\n}\n```\n关于this的指向问题，只需要认准this当前所在函数的调用方式即可，当函数作为一个对象的方法调用时，this指向为这个对象，当作为一个函数调用时，this在非严格模式下指向全局，严格模式下返回undefined\n\n闭包的作用：\n特权方法：通过上面的闭包的概念理解，已经可以知道闭包的一个作用就是作为一个公有方法用来访问私有变量的，有权访问私有变量和函数的公有方法也叫做特权方法；Javascript中虽然没有传统面向对象中的类，也没有私有成员的概念，不过对于一个函数而言，其函数参数，内部声明的变量或者函数就是私有的。\n```\nfunction Person(){\n    var name = 'daguo';\n    var getAge  = function(){\n        return console.log('22');\n    }\n    this.publicMethod = function(){\n        console.log(name)\n        return getAge()\n    }\n}\n```\n保留变量：通常函数的作用域和其所有变量会在函数执行结束之后就销毁，但是当这个函数返回一个闭包时，只要闭包还存在，那么声明闭包的这个作用域内的变量就不会被销毁，原因就是闭包依然保有对这些变量的引用，使它们不会被JS垃圾回收标记清除。这是一个可以利用的地方，也可能是一个造成内存泄漏的原因。所以不能过多创建闭包\n\n\n\n\n\n\n\n\n\n"},{"header":" chrome扩展程序入门手记","time":" 2016-06-14 23:08:15","tags":" [javascript,chrome]","description":" share my record after learning how to build a plugin for chrome.","section":"chrome是我非常喜欢的浏览器，它除了速度飞快，对前端代码支持友好的优点外，\n还有非常丰富的扩展程序资源，提供了大量方便强大的web页面应用插件\n这两天由于朋友的业务需求，接触了一些chrome扩展程序(即俗称插件)的有关代码\n基于对谷歌开发者文档的学习，随手记录了写chrome插件的基本方法~\n<!--more-->\n每一个基本的Chrome插件,首先都有一个manifest.json\n的配置文件用来存储插件的基本信息 \n\n``\n\"manifest_version\": 2,\n  \"name\": \"Getting started example\",\n  \"description\": \"This extension shows a Google Image search result for the current page\",\n  \"version\": \"1.0\"\n``\n\n包括manifest的版本，扩展插件的名字，描述，版本\n\n弹窗页面的信息browser_action, 在里面配置一个插件弹窗html页面代码，一般名字是popup.html，\n浏览器界面显示的扩展图标位置，以及鼠标hover的title\n\n``\n\"browser_action\": {\n    \"default_icon\": \"images/icon.png\",\n    \"default_popup\": \"popup.html\",\n    \"default_title\": \"Click here!\"\n  }\n``\n\n可选的页面注入代码，一般名字是contentscript.js，\n可选多个文件，匹配页面的matches，只对匹配到的注入代码\n\n``\n\"content_scripts\": [{\n    \"js\": [\"jquery.min.js\", \"contentscript.js\"],\n    \"matches\": [\"http://*/*\",\"https://*/*\"]\n  }]\n``\n\n还有插件要求的权限和要使用该插件的网页的匹配\n\n``\n\"permissions\": [\n    \"tabs\",\n    \"http://*/\"\n  ]\n``\n\n关于manifest的更多字段配置信息，可以查看360翻译谷歌的[开发者文档](http://open.chrome.360.cn/extension_dev/manifest.html)\n\n从上面的配置可以看到，一个简单插件除了有manifest之外\n还有一个browser_action, 即popup.html来渲染点击插件之后的弹窗页面，\n这个页面可以分离出来popup.js popup.css等文件，\n这些文件可以放在同一个根目录下，文件中的引用跟普通项目一致可以取相对路径\n\n\n如果要实现与浏览器打开页面的交互就必须还有一个注入脚本文件，\n一般取名contentscript.js，弹窗页面popup page通过相应api实现和注入脚本的交互\n再由注入脚本实现对web page的交互\n在popup page（popup.js）中的输入代码\n\n```\nchrome.tabs.query({\n      active: true\n    }, function(tab) {\n       var data = '';\n        //要传递给注入脚本文件的信息\n      chrome.tabs.sendMessage(tab[0].id, 'hello, content script, from background page. there are some data:' + data);\n});\n```\n\n第二个参数为发送的信息，在注入脚本中通过request参数拿到\n在contentscript.js中输入以下代码，开启对popup.js的信息发送监听，拿到信息request\n\n```\nchrome.extension.onMessage.addListener(function(request) {\n  //request是popup page传来的信息\n   console.log('get the message from popup.js'+request)\n   //收到popup page的信息后要做的事情\n});\n```\n\n注入脚本contentscript.js和浏览器打开的网页脚本web page运行在不同的环境之下，\n所以他们的变量名和全局对象不会有冲突，\n但是他们共享一个DOM树，也就是可以通过修改注入脚本的DOM结构来改变页面的DOM，\n这也就是注入脚本同web page交互的方式\n\n最后贴一个我练手写的一个[chrome插件](https://github.com/shudery/daguoNote)，\n实现简单的便签功能，界面用amazeUI做的，\n用React渲染，后台处理用Express搭建，数据结果直接保存一份JSON文件来管理\n"},{"header":" javascript的对象构造和原型链继承","time":" 2016-04-14 17:55:58","tags":" [javascript]","description":" javascript的对象构造和原型链继承","section":"这两天仔细地学习了JS的创建对象以及继承的方法，结合红宝石书整理了下笔记。\n（红宝石这里讲了非常多的模式，看第一遍觉得还蛮乱的）\nJavascript作为一种动态的面向对象语言，本身却没有类的概念和方法，\n在创建对象和继承方面有很多有趣的实现和方法\n<!--more-->\n## 1.原始绑定和字面量表示：\n**优点**：简洁方便\n**问题**：使用对象字面量的方法创建的对象，若重复创建会产生大量的重复代码\n```\nvar o = new Object();\no.name = 'shudery';\no.skill = function(){console.log('sayHello')};\n//这是比较老的方法，一般用下面这种简单粗暴的，直接字面量创建\n\nvar obj = {\n    sex = 'man',\n    skill = function(){console.log('tucao')} \n    ...\n}\n```\n## 2.工厂模式：\n抽象创建具体对象的过程\n**具体**：用函数来封装对象，然后调用特定接口创建对象\n**优点和问题**：解决代码重复性的问题，但是没有解决对象识别问题\n```\nfunction createObj(name){\n    var obj= {\n        name : name ,\n        skill : function(){console.log('tucao')}\n    };\n    return obj;\n}\nvar obj_1 = createObj('shudery');\nvar obj_2 = createObj('Lin'); \n//Object类型的对象\n```\n## 3.构造函数模式：\n使用`new`操作符，没有显式创建对象\n**优点**：解决了代码识别问题，可以将它构造的实例标示为特定类型\n**问题**：多次复用的方法需要在每个实例上重新创建一遍，浪费内存\n```\nfunction Myobj(name){\n        this.name = name,\n        this.skill= function(){console.log('tucao')}   \n}\nvar obj_1 =  new Myobj('shudery');\nvar obj_2 =  new Myobj('Lin');\n//对象类型名称为myObj，解决了识别的问题，用下面方法可以验证\nconsole.log(obj_1.constructor === Myobj && obj_2 instanceof Myobj);//true\n```\n这里如果怕遗漏new关键字，可以在`myObj`函数里头显示地返回一个对象，如下：\n```\nfunction Myobj(name){\n        var obj={};\n        obj.name=name,\n        obj.method= function(){\n        console.log('tucao')\n         }\n    return obj;\n}\nvar obj_1 = Myobj('shudery');\nvar obj_2 = new Myobj('shudery');\n```\n如果这么做`obj_1`的`constructor`指向的是`Object`\n这样就和工程模式一样不能识别对象，\n但是功能上两个对象相同，这也被叫寄生构造函数模式，一般不用它\n此外在构造函数模式下如果没有引用this和new，那就是稳妥构造函数模式，\n一般用在安全的环境\n\n## 4.原型模式：\n在构造函数模式下如果直接提取出方法函数到全局环境下，\n在方法变多时容易污染命名空间，\n此外不利于我们自定义的引用类型的封装。\n我们可以用JS的一大特色原型属性来挂载属性方法。\n**优点**：我们可以将复用的方法绑定到每一个构造函数定义的原型属性prototype上来，这样所有的对象实例都可以共享这个挂在这个原型下的属性和方法。\n**问题**：实例失去本身的特点和封装，公用一套属性和方法\n```\nfunction Myobj(){\n       \n}\nMyobj.prototype.name ='shudery';\nMyobj.prototype.age = '22';\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj();\n```\n也可用对象字面量形式，不过要注意顺序，字面量的形式相当于重写整个对象，\n构造函数原型的`constructor`属性（指向对象类型）会被重写为`Object`,\n而不是`Myobj`了\n```\nfunction Myobj(){\n       \n}\nvar obj =  new Myobj();//先实例化\nMyobj.prototype={\n//重写后这个原型和Myobj这个构造函数就没有关系了\n    name: 'shudery',\n    age:'22',\n    method : function(){\n    console.log('tucao')\n    }\n};\nobj.name;//undefined，联系被切断了\n```\n如果在重写之后实例化一个对象，虽然还存在联系，\n但是`obj`实例就不是`Myobj`类型了\n不在乎对象识别问题的话，也可以直接这样重写，仍能调用obj.name等属性和方法\n\n## 5.终极模式：构造函数+原型模式\n 最为常用的创建对象的方式，结合两种模式的优点，\n 实现对象属性的封装和对象方法的复用，\n平衡了对象的独立性和多态复用节省内存的问题。\n```\nfunction Myobj(name,age){\n    this.name =name;\n    this.age = age\n}\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj('shudery',22);\n```\n如此一来对象就拥有自定义的属性和可共享复用的方法啦\n有句话这样说，当我们把程序中变化的部分封装好之后，剩下的就是稳定可复用的了\n这也是很多种设计模式里推崇的，放到创建对象的方法里也是一样的做法。\n\n说完对象的创建，接下来是继承~\nJS是没有类的关键字和概念的，它的继承是基于原型链的，类似上面的原型模式\n我们先简单了解下原型链：\n\n![](https://raw.githubusercontent.com/shudery/public/master/clipboard.png)\n\n每个构造函数都有一个原型对象，构造的实例有一个指向原型对象的指针，\n如果我们把父类的实例赋值给原型对象，那么子类的原型对象就是父类的实例， \n那么这个实例还是有一个指向父类原型的指针，\n这些指针连起了子类和父类的实例（子类构造函数的原型），就是原型链。\n\n对象的方法和属性会循着原型链进行访问，直到查找到相应的属性和方法名，\n或者到达原型链的终点`Object.prototype`,这也就实现了继承\n\n\n\n\n\n\n\n\n\n\n"},{"header":" 搭建属于自己的vpn服务器","time":" 2016-06-10 21:59:48","tags":" [vpn]","description":" how to build vpn or vps by youself","section":"之前实习的时候想着有需要翻墙的时候用着公司的vpn就足够了\n但是随着马上要去工作，还有对一些国外资源的需求（资源你懂的）\n然后也前后被一些网上的vpn服务商坑过（各种掉线，不稳定）\n决定自己租用一台国外的服务器vps\n<!--more-->\n了解一番后知道了国外[搬瓦工](http://bandwagonhost.com/)和[digital ocean](www.digitalocean.com/?refcode=3491087221da)都有不错的口碑，最终选择DO,\n最便宜的512MB内存，20GB固态硬盘，1TB流量，\n\n这个好像只是防止恶意使用的，实际上流量是用不完的，\n在服务器控制版面也没有流量使用情况提示\n首先注册账号，输入邮箱密码，在邮箱收到确认邮件，\n来到Payment Methods \n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_1.png)\n\n这一项我选择的是方便快捷的PayPal，Credit不好设置\n需要预充5刀PayPal，5刀也是最便宜的服务器的月租价格，\n如果没有PayPal的话就先注册一次，比这个Credit方便多了\n注意一些老旧的银联卡号可能提示设置错误，我换了一张卡就好了\n\n然后开始选择服务器，包括价格，地点，系统，\n我选了最便宜已经够用了的5刀/月，ping后较快的美国西部服务器，\n以及比较容易操作的ubuntu系统，然后添加主机的SSH密钥，以后方便，\n\n不过也可以先跳过以后再说，买后会收到邮件，\n得到一个服务器主机Ip，root账户名，以及一个初始密码。\nvps算是有了，接下来我们在这台服务器上搭建vpn\n\n然后不得吐槽的是网页的console控制台实在有点卡卡，\n所以我用简单的putty来建立与vps的链接，也可以使用xshell等工具，\n下载putty后直接输入ip地址，保留默认端口，点击open就进入控制台了\n\n然后输入你的用户名root，然后出现password输入密码，\n这里注意啦~输入密码的时候，光标是不会动的！\n所以，慢慢输入，不要输错了，登录成功后显示一些信息\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_2.png)\n\n第一次登陆要求重置密码，分别填一次旧密码和两次新密码，注意光标还是不会移动！\n然后开始一列Linux操作，作为小白的我们就只管输入代码即可，\n不过我们也是有(yao)追(zhuan)求(bi)的小白，所以也要大概知道这些代码是个什么作用\n\n### 1、安装vpn服务\n首先我们必须在vps服务器上安装一种vpn服务，这里选择点对点隧道协议pptp,输入\n\n```\napt-get install pptpd\n```\n\n### 2、配置文件修改\n用vi编辑器打开配置文件，输入\n\n```\nvi /etc/pptpd.conf\n```\n\n没用过vi的注意啦，要编辑文件必须先输入i，进入INSERT模式，\n将光标移动到最下面更改\n\n```\nlocalip 10.0.0.1\nremoteip 10.0.0.100-200\n```\n\n有两段，localip更改为你vps服务器的ip地址，remoteip是以后分配给\n其他连到你vpn的服务器的ip，可以照着例子分配，写完后保存，\nvi的文件保存方法是先按Esc然后输入冒号:wq即可，w是写入保存，q是退出vi\n\n### 3、添加vpn账号\n用vi打开密钥文件，输入\n\n``` \nvi /etc/ppp/chap-secrets \n```\n\n依次输入 username pptpd password ### \n将username, password更换为你的vpn账号和密码，中间是服务名，\n最后一个是ip通配符，如果要建立多个vpn账号给妹子基友一起用，\n还一行依次输入即可，输完同样保存\n\n### 4、设置公共DNS服务，输入\n\n```\nvi /etc/ppp/pptpd-options\n```\n\n打开服务选项文件设置找到ms-dns并设置为\n`\nms-dns 8.8.8.8\nms-dns 8.8.4.4\n`\n\n### 5、重启pptp服务，\n重启服务，刷新配置，输入\n\n```\nservice pptpd restart\n```\n\n### 6、ip转发配置\n打开转发配置文件，输入\n\n```\nvi /etc/sysctl.conf\n```\n\n发现整个文件都带有注释符#,去掉`# net.ipv4.ip_forward = 1`\n前面的注释符#保存,为了使配置生效还需运行\n\n```\nsysctl -p\n```\n\n### 7、设置iptables\n设置并保存，运行\n\n```\niptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE && iptables-save\n```\n\n至此搭建好属于你自己的vpn，拿着账号在手机和电脑的vpn设置登录即可\n注意如果出现vpn隧道协议构建失败，检查一下网络适配器里vpn的安全属性\n勾选为以下选项\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_3.jpg)\n\n\n\n\n\n\n\n"},{"header":" Javascript开发跨平台桌面app","time":" 2016-06-23 23:32:17","tags":" [javascript,node]","description":" develop cross-platform GUI app with electron","section":"electron原本是atom shell的项目，由于集成node丰富的本地系统级API，\n提供了与操作系统交互的功能，所以归结起来，现在javascrpit的技术栈之所以如此宽广，\n要得益于NodeJS将其中浏览器的环境中分离出来\n\n不过需要特别说明的是，这里生成的桌面应用，\n实际上是Electron生成的一个由Javascrpit控制管理的迷你浏览器Chromeinum，\n它其实是一个Chrome浏览器的试验版本，当然用的也是V8的内核\n<!--more-->\n不管怎么说，这对于喜欢前端，熟悉javascript的同学来说，\n能够用前端和一点后台的知识去接触，尝试各种不同的领域，实在是不要太爽\n\nElectron的入门也符合前端知识领域的特点，几乎没有门槛，\n只要你有一点JS和Node的基础就行了，开发目录的文件层次结构也很简单，\n后面会有打包工具帮助我们一键打包生成层次比较复杂的项目文件，\n作为桌面GUI应用，当然也包括.exe的启动文件，\n\n让我们看看如何开发一个桌面应用，或者说一个能和操作本地系统的web页面的基本方法~\n你可以跟着步骤完成一些基本的文件，也可以直接下载[快速开始的demo](https://github.com/shudery/electron/archive/master.zip)\n基本的文件层次很简单，用app存放一个具体的桌面应用，具体结构是这样的\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_1.png)\n\nOutApp用来存放打包输出的exe文件\n至于为什么有两个``package.json``文件，后面打包操作时你就知道了\n\n### 1、首先安装electron\n命令行进入根目录，先用npm安装electron，如果还没有就先[安装node](https://nodejs.org/en/)\n```\nnpm install -g electron-prebuilt\n```\n### 2、生成``package.json``配置文件\n运行``npm init`` 生成一个``package.json``文件来存放应用的相关配置，这个是第一个``package.json``文件，位于外层根目录下的，运行 \n```\nnpm install --save-dev electron-prebuilt  \n```\n会在devDependencies中生成依赖信息，方便后面打包\n```\n{\n  \"name\": \"firstGUI\",\n  \"version\": \"1.0.0\",\n  \"main\": \"app/main.js\",//js入口文件\n  \"scripts\": {\n    \"build\": \"electron-packager ./app firstApp --platform=win32 --arch=x64 --out ./OutApp --version 0.37.3 --overwrite --icon=./app/img/daguo. jpg\",\n    //打包命令，后面打包可以简化代码\n  },\n  \"devDependencies\": {\n    \"electron-prebuilt\": \"^1.2.0\"\n  }\n}\n```\n### 3、新建main.js\n生成一个入口的js文件来作为控制GUI窗口的主进程程序\n```\nconst electron = require('electron');\n// 控制应用生命周期的模块\nconst {app} = electron;\n// 创建本地浏览器窗口的模块\nconst {BrowserWindow} = electron;\n// 指向窗口对象的一个全局引用\nlet win;\n\nfunction createWindow() {\n\n // 创建一个新的浏览器窗口\n  win = new BrowserWindow({ width: 360, height: 572 });\n // 并且装载应用的index.html页面,注意路径\n  win.loadURL('file://'+__dirname+'/html/index.html');\n // 当窗口关闭时调用的方法\n\n  win.on('closed', () => {\n  // 解除窗口对象的引用，通常而言如果应用支持多个窗口的话，你会在一个数组里\n  // 存放窗口对象，在窗口关闭的时候应当删除相应的元素。\n  win = null;\n  });\n}\n\n// 当Electron完成初始化并且已经创建了浏览器窗口，则该方法将会被调用。\n// 有些API只能在该事件发生后才能被使用。\napp.on('ready', createWindow);\n\n// 当所有的窗口被关闭后退出应用\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\napp.on('activate', () => {\n  if (win === null) {\n    createWindow();\n  }\n});\n// 在这个文件后面你可以直接包含你应用特定的由主进程运行的代码。\n// 也可以把这些代码放在另一个文件中然后在这里导入。\n```\n### 4、index.html\nGUI窗口（web页面）渲染的Html文件\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>firstGUI</title>\n  </head>\n  <body>\n    <h1 style=>Hello World!</h1>\n  </body>\n</html>\n```\n\n### 5、运行桌面app\n大公告成，没错就是如此之快，运行``electron .``（跟一个空格和小点），或者``electron app/main``\n打开制作好的GUI界面，so cool~\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_2.png)\n\n### 6、进行打包\n既然是桌面应用，那肯定是要一键运行的，不需要安装什么依赖模块，\n也不需要运行命令行程序的，所以为了提升逼格，让更多的人可以方便实用你的桌面app，\n需要对app文件夹进行打包，安装打包程序 ``electron-packager``\n```\nnpm install --save-dev electron-packager\n```\n打包的基本命令是 \n```\nelectron-packager <location of project> <name of project> <platform> <architecture> <electron version><optional options>\n```\n上面已经在``package.json``的script里配置了简化的命令，可以根据自身情况对名称，操作系统，应用图标进行修改，\n注意啦开始打包前，一定要复制一份``package.json``到app文件，\n前面说了桌面应用不用下载依赖，其实是因为打包的时候就将依赖一同打包到文件包里了，\n所以我们要打包app文件夹下的文件，需要一个``package.json``  来说明依赖项，注意修改里面的路径，要往下一级，然后运行``npm packager``\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_3.png)\n\n完成打包后可以看到OutApp里头已经有了相应的文件，\n运行里面的exe文件会生成和本地测试时一样的GUI窗口~\n\n\n一个简单的基于前端技术栈的桌面app算是完成了，后续的asar文件加密，\n用nsis制作一个安装引导等等~有兴趣的可以继续完善~\n\n一个桌面级app当然不是用来显示``hello world``的，那样和web页面有什么区别，\n这里只是我入门的一个学习记录，一个基于electron的桌面应用\n还有着非常丰富的与系统交互功能可以设计和开发~\n更加详细的用法和配置有兴趣的同学不妨看看官方的[api演示文档](http://electron.atom.io/)，\n它也是一个基于electron做的桌面app\n\n"},{"header":" 最近的npm模块风波","time":" 2016-04-04 17:53:38","tags":" [npm,modules]","description":" npm导致我们不会写代码了？","section":"最近，前端圈子有件事闹得沸沸扬扬，有一个叫做`leftpad`的npm模块被作者撤下，\n导致一系列引用该模板的项目出现问题。\n\n其实本来大家对这件事的重点应该是关于NPM管理者对于模块作者著作权的保护不周上的，\n但是可能由于这个模块的特殊性和他造成的影响之间的对比太强烈，\n让大家都把注意力放到了这个模块本身和引用这个模块的做法上来了。\n<!--more-->\n**这个模块只有短短十一行，仅仅实现一个简单的字符串左侧填充的功能！**\n\n如此简单的模块为什么那么多项目都要引用他呢？\n其实如果不出现作者`unpublish`的问题，大家不会对这样的做法有太多的疑问，\n因为NodeJS的特色就是如此嘛，而且npm的引用和配置下载也非常方便， \n即使是再简单的模块，我若引用也就是`require`一下，然后将依赖写到json里，\n还是比自己写实现函数要方便一些，虽然方便得不多。\n总之就是不出事还好，一出事，那不好意思就得有人负责，\n这件事没有主要负责人，那么就得有问题被抛出。\n\n所以最近这几天抛出的最多的一个问题就是，**对于简单的代码我们仍要引用模块吗？**\n\n\n首先我觉得像这次又模块被作者下架，这毕竟是少数事件，\n我们不应该讨论对于npm的信任问题，这样会使我们在引用模块时畏手畏脚，\n有人说你简单的函数方法自己写嘛，复杂的再引用别人的，\n就是减少引用，就减少了出了事摊上你的概率，\n我只想说在小概率事件中减小该事件的概率--无关痛痒。\n\n\n总之我对npm模块的引用还是持比较乐观的态度，\nnpm的社区非常繁荣，拥有大批的贡献者，我觉得就是即使是再小的一个模块，\n你写出来了就可以`publish`上去，就可以给别人引用，每个人都有发光发热的机会，\n这给作者多大的鼓励和成就感啊，别人用后也会给你反馈，你再去不断改善，\n大家也可以在`review`其他模块代码中得到非常多的编程技术和思想。\n\n\n与对引用小模块的质疑相反，我觉得引用大模块的问题似乎更多，\n一个项目中引用的大模块往往并不需要里面的很多功能，\n所以NodeJS才在新版中将核心模块分割成多份，大家需要用啥再引用那个模块，\n这样就避免了项目庞大引起的各模块之间可能出现的兼容问题，\n也不至于使得代码太臃肿，至于对小模块引用可能导致require和模块依赖过大，\n但是代码依然比较精简，代码的冗余也比较少。\n\n\n最后，关于npm模块的引用，小模块如果有用过或已经知道的精巧模块，\n不仿大胆引用，若是不清楚也不必特意查询，简单的功能自己想方法实现即可，\n大模块如果与项目的配合不好，该分解的最好分解，结合项目和自身的编程习惯，\n高效的完成项目。\n以上仅仅是个人愚昧的一些看法。\n\n"},{"header":" 用hexo搭建一个博客","time":" 2016-05-05 12:00:33","tags":" [hexo,node,git]","description":" 如何用hexo来搭建一个博客","section":"hexo出自一位台湾大学生之手，是如今搭建，管理博客，发布文章的非常好用的工具，\n之前一直想搭建一个不依赖后台，便于管理和发布的博客，在朋友推荐下用了hexo\n确实是简单粗暴好用~\n基于hexo的博客搭建，对于已经配备了Node环境和git的前端开发人士，\n搭建出一个博客那就是分分钟的事情，即使还没有弄好这些也不难搭建，\n下面就从头大致说一说搭建的流程。\n<!--more-->\n### 创建一个github账号和博客\nhexo搭建的博客是一个静态页面，可以直接托放到github上面的服务器上，\n不需要拥有自己的服务器，所以我们要先有一个github账号，\n然后需要生成一个github的博客，之后我们用自己定制的hexo博客来替换它，\n如何搭建github技术博客可以看看这篇:[创建GitHub技术博客全攻略](http://blog.csdn.net/renfufei/article/details/37725057/)\n### 搭建Node环境\n我们还需要一个运行hexo和调试的环境，就是用Nodejs，\n在[官网地址](https://nodejs.org/en/)选一个稳定版或者开发版一键安装好环境。\n### 安装Hexo，生成文章\n准备好nodejs之后打开命令行使用Node的包管理工具npm,直接在命令行运行\n``\nnpm install -g hexo\n``\n\n下载hexo，然后再在相应的目录运行\n``\nhexo init\n``\n\n即可一键生成文件结构，你可以看到在source/_posts里面有一篇默认的helloworld.md文章，\n在themes里面有一个默认的主题landscape，再继续运行\n``\nhexo generate\n``\n\n### 调试，部署到git\n上面过程之后即可生成一个Public文件，里面会有你的文章内容，然后就可以运行\n``\nhexo server\n``\n\n启动localhost:4000，在浏览器输入地址就可以看到你的博客效果了，\n如果你对默认的配置都满意的话下一步就是运行\n``\nhexo deploy\n``\n\n将内容部署到github上面去了，但是我们好像还没有建立hexo和我们账号github仓库的链接，\n所以要在_config.yml最下面进行一些配置\n```\ndeploy:\n  type: git\n  repo: git@github.com:shudery/shudery.github.io.git # 换成你的博客仓库地址\n  branch: master\n```\n然后再hexo deploy即可完成部署，注意用ssh地址可以免去输入密码的繁琐，\n当然前提是要先生成ssh密钥，并且在你的github上面添加这个ssh密钥~\nhexo博客就已经搭建完成，可以在shudery.github.io上面看到博客页面和文章效果\n### 添加文章，更换主题，修改配置\n基本的东西就是这样，接下来我们可以在_posts里面以markdown的写作形式写文章，\n然后通过同样的方式生成，部署，可以直接在_posts里新建md文件，\n也可以用运行\n``\nhexo new [fileStyle] [fileName]\n``\n\n的方式来生成文件，后者会以scaffolds中对应的fileStyle的形式，\n给你生成一个fileName的md文件，里面会包括一些开头的默认字段，\n会方便记录一些文章的信息，我们还可以在[官网主题](https://hexo.io/themes/)里找一个更加符合心意的主题，\n然后直接git clone/ctrl+c 到我们hexo/themes下面，\n然后在hexo/_config.yml中的 theme:landscape 改为你下载好的主题名，\n然后你会发现主题文件夹里还有一个_config.yml 用来修改主题的一些相关配置，\n你可以参考你下载主题的github,或者官网的介绍来设置这些配置~\n### 完善博客\n最后你可以根据自己的喜好和需求为博客添加一些你喜欢的挂件和工具，\n我自己加了多说评论，百度统计，还有就是换了一个逼格高一点的域名，\n通过添加CNAME域名解析，重定向到github.io的博客地址上面。\n\n搭建过程中一些tips~\n\n* hexo clean会清理缓存和Public文件夹一般是在hexo generate之前使用，但是不用没啥问题\n* hexo/_config.yml对于hexo非常重要，但是如果去掉_config.yml你会发现还是依然能运行各种命令\n* 然而一般运行时报错都是config配置有问题，而且很不好定位，\n  所以可以注释掉config.yml里面你觉得应该不会导致报错的配置，然后再运行看结果，\n  重复几次就可以定位到问题了，这对一开始没有什么经验的人来说是一个可行的debug方法。\n* 在做域名重定向的时候，域名解析的CNAME需要指向github.io，\n  此外还要在hexo/source下面也建立一个CNAME文件指向你的设置了重定向的域名地址才行"},{"header":" ES5和ES6中对于继承的实现方法","time":" 2016-07-23 23:32:17","tags":" [javascript]","description":" develop cross-platform GUI app with electron","section":"\n在ES5继承的实现非常有趣的，由于没有传统面向对象类的概念，Javascript利用原型链的特性来实现继承，这其中有很多的属性指向和需要注意的地方。\n原型链的特点和实现已经在之前的一篇整理说过了，就是通过将子类构造函数的原型作为父类构造函数的实例，这样就连通了子类-子类原型-父类，原型链的特点就是逐层查找，从子类开始一直往上直到所有对象的原型Object.prototype，找到属性方法之后就会停止查找，所以下层的属性方法会覆盖上层。\n<!--more-->\n一个基本的基于原型链的继承过程大概是这样的：\n```\n//先来个父类，带些属性\nfunction Super(){\n    this.flag = true;\n}\n//为了提高复用性，方法绑定在父类原型属性上\nSuper.prototype.getFlag = function(){\n    return this.flag;\n}\n//来个子类\nfunction Sub(){\n    this.subFlag = false;\n}\n//实现继承\nSub.prototype = new Super;\n//给子类添加子类特有的方法，注意顺序要在继承之后\nSub.prototype.getSubFlag = function(){\n    return this.subFlag;\n}\n//构造实例\nvar es5 = new Sub;\n```\n原型链实现的继承主要有几个问题：\n1、本来我们为了构造函数属性的封装私有性，方法的复用性，提倡将属性声明在构造函数内，而将方法绑定在原型对象上，但是现在子类的原型是父类的一个实例，自然父类的属性就变成子类原型的属性了；\n这就会带来一个问题，我们知道构造函数的原型属性在所有构造的实例中是共享的，所以原型中属性的改变会反应到所有的实例上，这就违背了我们想要属性私有化的初衷；\n2、创建子类的实例时，不能向父类的构造函数传递参数\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n   this.subFlag = false;\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nobj.flag = flase;  //修改之后，由于是原型上的属性，之后创建的所有实例都会受到影响\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //false；\n```\n为了解决以上两个问题，有一个叫借用构造函数的方法\n只需要在子类构造函数内部使用apply或者call来调用父类的函数即可在实现属性继承的同时，又能传递参数，又能让实例不互相影响\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n    Super.call(this)  //如果父类可以需要接收参数，这里也可以直接传递\n}\nvar obj = new Sub();\nobj.flag = flase;\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //依然是true，不会相互影响\n```\n结合借用构造函数和原型链的方法，可以实现比较完美的继承方法，可以称为组合继承：\n```\nfunction Super(){\n    this.flag = true;\n}\nSuper.prototype.getFlag = function(){\n    return this.flag;     //继承方法\n}\nfunction Sub(){\n    this.subFlag = flase\n    Super.call(this)    //继承属性\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nSuper.prototype.getSubFlag = function(){\n    return this.flag;\n}\n```\n这里还有个小问题，Sub.prototype = new Super;  会导致Sub.prototype的constructor指向Super;\n然而constructor的定义是要指向原型属性对应的构造函数的，Sub.prototype是Sub构造函数的原型，所以应该添加一句纠正：\nSub.prototype.constructor = Sub;\n\n看完ES5的实现，再来看看ES6的继承实现方法，其内部其实也是ES5组合继承的方式，通过call借用构造函数，在A类构造函数中调用相关属性，再用原型链的连接实现方法的继承\n```\nclass B extends A {\n  constructor() {\n    return A.call(this);  //继承属性\n  }\n}\nA.prototype = new B;  //继承方法  \n```\nES6封装了class，extends关键字来实现继承，内部的实现原理其实依然是基于上面所讲的原型链，不过进过一层封装后，Javascript的继承得以更加简洁优雅地实现\n```\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 等同于parent.constructor(x, y)\n    this.color = color;\n  }\n  toString() {\n    return this.color + ' ' + super.toString(); // 等同于parent.toString()\n  }\n}\n```\n通过constructor来定义构造函数，用super调用父类的属性方法\n\nES6中Class充当了ES5中，构造函数在继承实现过程中的作用\n同样有原型属性prototype，以及在ES5中用来指向构造函数原型的`__proto__`属性，这个属性在ES6中的指向有一些主动的修改。\n一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法继承。\n```\nclass A extends B {}\nA.__proto__ === B;  //继承属性\nA.prototype.__proto__ === B.prototype;  //继承方法\n```\nES6的子类的`__proto__`是父类，子类的原型的`__proto__`是父类的原型\n第二条继承链理解起来没有什么问题，对应到ES5中的A.prototype = new B;A.prototype作为B构造的实例，指向构造函数B的原型B.prototype，\n但是在ES5中A.`__proto__`是指向Function.prototype的，因为每一个构造函数其实都是Function这个对象构造的，ES6中子类的`__proto__`指向父类可以实现属性的继承，在ES5中在没有用借用继承的时候由于父类属性被子类原型继承，所有的子类实例实际上都是同一个属性引用。\n在ES6中实现了子类继承父类属性，在构造实例的时候会直接拿到子类的属性，不需要查找到原型属性上面去，ES6新的静态方法和静态属性（只能在构造函数上访问）也是通过这样类的直接继承来实现，至于普通复用方法还是放到原型链上，道理和实现和ES5是一样的。\n此外我认为这里修改A.`__proto__`的指向是有意区分ES6中继承和实例化，同时建立子类和父类直接的关系，ES5的子类的构造函数通过子类的原型与父类的构造函数连接，不存在直接的关系；\n可以这么说，在ES5继承和构造实例，ES6构造实例的时候可以理解`__proto__`原型指针是用来指向构造函数的原型的，但是在ES6继承中，`__proto__`指继承自哪个类或原型，在A继承B之后，构造一个实例 var obj = new A; 会发现它所有的属性指向都是和ES5一致的。\n\n\n有个有趣的地方：ES6继承是在父类创建this对象，在子类constructor中来修饰父类的this，ES5是在子类创建this，将父类的属性方法绑定到子类，由于原生的构造函数（Function，Array等）没有this，子类无法通过call/apply(this)获得其内部属性，所以在ES5无法继承，ES6实现后可以为原生构造函数封装一些有趣的接口，比方说阮一峰老师的这个给Array实例封装一个版本记录和回滚的方法：\n```\nclass VersionedArray extends Array {\n  constructor() {\n    super();\n    this.history = [[]];\n  }\n  commit() {\n    this.history.push(this.slice());\n  }\n  revert() {\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  }\n}\n\nvar x = new VersionedArray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\nx.push(3);\nx // [1, 2, 3]\n\nx.revert();\nx // [1, 2]\n```\n最后做一个ES5和ES6的继承小结：\nES5最经典的继承方法是用组合继承的方式，原型链继承方法，借用函数继承属性，ES6也是基于这样的方式，但是封装了更优雅简洁的api，让Javascript越来越强大，修改了一些属性指向，规范了继承的操作，区分开了继承实现和实例构造，此外ES6继承还能实现更多的继承需求和场景。\n\n\n\n\n\n\n"},{"header":" HTTP缓存及众多的web储存概念之小整理","time":" 2016-08-12 01:46:57","tags":" [javascript,html]","description":" this is a article for my way of studying front-end","section":"\n缓存对于一个网站来说非常重要，可以提高网站性能，减少冗余的数据传输，增加服务器负担，web存储则给浏览器提供了更加强大的保存文件的接口。\n有相当一段时间一直混淆了HTTP缓存相关的属性，HTML5离线存储和本地储存的一些关系，最近好好地整理了一下这些Web存储相关的东西\n\n先列出一些相关属性和概念，看看能否理清它们之间的区别和联系？\n<!--more-->\n\n* manifest\n* cache-control\n* expires\n* 304(no modified)\n* ETag\n* If-None-Match\n* Last-Modified\n* If-Modified-Since\n* http-equiv\n* webstorage\n* cookie/session\n\n是不是感觉有点凌乱，那就跟着我整理的笔记走一遍吧：）\n首先说一说HTTP缓存相关的东西:\n　　\n　　\n`Cache-Control`\n每一个用HTTP请求的资源都可以在响应头用Cache-Control来给浏览器定义缓存策略，通过设置一些属性值它可以控制谁可以，在什么条件下可以缓存响应，还有缓存的有效期，这个属性的一些常用值如下\n\n`no-cache：`表示不使用缓存，先和服务器确认要返回的资源是否有修改\n`no-store：`表示禁止浏览器和所有中继缓存响应的资源\n`max-age=100：`表示缓存的有效期，单位是秒，这一段时间内，除非缓存文件发生一些变动，否则会直接使用之前的缓存，注意这段时间内是不会发Etag等方法去验证的资源有没有修改的。缓存的文件发生变动，主要有这些情况：资源名更改，资源地址更改，缓存被删除，网页强制刷新等；资源名更改，给文件名添加版本hash值，比如给image.png修改为image-hash.png，可以保证每次更新文件时用户可以重新发出请求，获取最新的资源。资源路径更改，修改文件的请求路径，比如给image.png添加查询参数修改为image.png?hash，max-age的时间设置根据每个网站的实际情况不同去设置，一种极端的做法是把这个值设置很大，然后通过修改资源名或者给资源请求地址添加查询参数，来告诉浏览器该更新资源了，一般用在很久才更新网站的情况\n`public：`用max-age即是默认public了，不用设置\n`private：`私人缓存，中继缓存不被允许，但是可以在浏览器缓存\n\n`PS：expires：`表示存在的时间，使客户端在这个设置的时间之前不用去请求资源，类似于max-age，但是expires表示的是一个固定时间，而且可能有服务器和客户端时间不一致的问题，主要用于HTTP1.0版本，在HTTP1.1版本完全可以用功能更强的Cache-Control来替代，和max-age同时存在时expiers会被覆盖掉\n`PS：http-equiv：`缓存有两种控制机制，一种是请求头信息控制，另外一种就是利用meta标签；可以在HTML文档中为meta标签设置http-equiv为相应属性名，content为值来设置缓存，例如\n`<meta http-equiv=\"Expires\" content=\"Mon, 20 Jul 2009 23:00:00 GMT\" />`，不过只对改网页的HTML文件有缓存作用，对该页面的其他资源以及其他页面的HTML文件都没有作用\n　　\n　　\n那么max-age（expires）到期之后，在no-cache下的资源会先和服务器确认返回的资源是否有修改，如何实现这一过程？\n`ETag/If-None-Match，Last-Modified/If-Modified-Since`\nETag (Entity Tag)其实就是一个验证令牌，用来标识一个资源，可能是一个hash值，也可能是一个版本号，每当资源有修改的时候ETag的值就会改变\n浏览器第一次请求之后会保存响应头的ETag值，以便下一次发送请求的时候校验Etag是否有更改。\n　　\n　　\n那么下一次浏览器如何告诉服务器本地已经存有Etag和相应的资源了呢？If-None-Match\n通过在请求头添加If-None-Match(如果存在ETag，浏览器会自动添加)，赋值为上一次请求后在本地存储的Etag值，服务器会和服务端最新资源的Etag比对，如果没有更改会直接返回304 no modified给浏览器，浏览器就直接使用本地缓存的文件\n\n`PS：Last-Modified/If-Modified-Since`的作用等同于`ETag/If-None-Match，`不过前者是通过规定一个时间来比对，最小的单位是秒，后者通过一个唯一标识符，所以可以看出来如果原站在一秒内有多次更新，那么前者就不顶用啦。\nETag的验证要优先于Last-Modified，此外ETag也是有缺点的，在分布式的环境中，Etag在不同服务器上的同步问题可能会给服务器带来一些压力。\n　　\n　　\n`HTTP缓存`是和每一个HTTP请求直接相关的，每一个请求资源的响应都有相应的缓存策略，它们往往是相似的，是否可以通过其他的机制，直接告诉浏览器去缓存哪一些文件呢？\n`HTML5离线存储`闪亮出场\n\nH5离线存储：服务器通过一份.manifest文件给浏览器提供一份完备的缓存名单，名单包括需要缓存的文件，不需要缓存的文件的列表之外，还有一些其他的功能，比如给资源设置备选的请求地址，设置404页面等\n\n实现：利用H5的标签新属性manifest，只需要在HTML文件添加`<html manifest=\"test.manifest\">，`服务器则将manifest文件的mime-type设置为text/cache-manifest类型即可，浏览器每次请求会检查`manifest`是否有更新，服务端通过修改manifest文件，即可在浏览器下一次请求资源的时候通知其更新相应的资源。\n作用：通过本地离线存储可以在没有网络的情况下访问网站事先保存的文件资源，在有网络的情况下直接使用本地资源也可以减少请求连接的压力，提高网页的加载速度，注意这里和HTTP缓存的区别，它是直接使用本地资源，请求返回的是200（from cache）,由于有manifest来统一管理，所以不需要发请求查看是否有更新，也没有过期时间。\n　\n`PS：`这里关于manifest文件自身的更新问题，还是要走HTTP缓存，或者直接不缓存这个文件。\n　　\n　　\n前面提到的概念主要都是缓存请求文件这一块的东西，它们的目的都是为了提高网页的性能，可以说是一种优化型的存储，可以给用户带来更流畅的体验\n但是我们印象中还有一种存储，它可以给我们提供更多的可能和效果的实现，是功能型的存储，如H5本地储存`Webstorage，cookie，session`\n　　\n　　\n`cookie，session`\n众所周知，HTTP是无状态的协议，每一次请求都是独立没有联系的，浏览器和服务器都没有办法维持用户的状态，判断用户是不是依然是之前的那个用户。\n很容易可以想到，在同一个用户的每个请求头添加一个唯一标识符，通过判断这个标识符就可以维持用户的一些信息和状态\n会话信息被用来作为标识符解决这个问题，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案（服务端保持状态也需要客户端保持状态，所以一般session都要基础cookie或者sessionstorage）\n\n总的来说：cookie数据放在客户端，session数据放在服务端，cookie可以设置期限，session则是关闭浏览器时销毁（cookie默认也是），cookie不安全，session可能会影响服务器性能\n\n`Cookie：`通常用Javascript封装一个setCookie的函数来创建，有大小限制，可能会导致请求头过于臃肿，浏览器发送请求时，检查本地cookie，如果该cookie声明的范围大于发送请求的url地址时，就会自动在请求上添加cookie字段\n\n`session：`服务器每次会检查浏览器请求头的session标识，如果有则将这个session id在服务器的数据库（散列表）查找，找到后才进行相应权限的操作\n如果没有这个请求标识，则为客户端新建一个，返回给客户端后，客户端可以通过cookie或者sessionstorage来保存这个session id，通过请求头的cookie字段来给服务器提供sessionId，当cookie被禁止时就需要一些其他方法，通常是采用添加到url路径中，添加表单隐藏域等方法\n\ncookie作为HTTP协议规范的一部分，主要还是用来储存用户信息的，用来和服务端交互，大小也有限制，仅仅只是一种会话级别的存储\n　　\n　　\n`localstorage，sessionstorage`\n`webstorage`为了更大的存储文件设计，与Cookie负责记录用户信息相比，webStorage专注于本地存储，通过封装好的setItem，getItem等方法即可使用\nlocalstorage是一种持久化的存储，除非主动删除，否则永远存在，sessionstorage主要用来存储会话（session），关闭浏览器就会销毁，是一种非持久化的存储\n　　\n　　\n除了上面这些的概念之外，还有诸如像IndexDB，FileSystem等存储方法，关于Web存储的知识真的非常多，看上去坑也是不少，还需要实践慢慢来掌握。\n\n\n\n\n\n\n\n\n\n"},{"header":" JavaScript关键概念理解之闭包","time":" 2016-07-10 21:59:48","tags":" [javascript]","description":" none","section":"\nJavaScript作为一种多范式编程语言，和许多函数式编程语言一样拥有闭包的概念。\n闭包是一个老生常谈的问题，前端面试必问，要理解闭包的原理，必须知道什么是词法作用域，理解词法作用域，又需要对Javascript另外两个关键概念的掌握和理解~\n\n<!--more-->\n\n#### 执行环境和作用域链\n执行环境：红宝书将执行环境称为Javascript这么编程语言最为重要的一个概念，一开始我是不服的，屌屌的闭包和原型链呢？后来一番整理，才发现原来闭包和原型链的实现都是依赖于执行环境。\n执行环境定义了变量或者函数有权访问的数据，决定了它们各自的行为，每个执行环境拥有一个变量对象来保存环境中定义的所有变量和函数。\n每个函数都有自己的执行环境，每次执行语句进入函数后，就会将相应函数的执行函数压入环境栈中，执行完函数之后就会弹出，将控制权交给原来的执行环境。\n\n作用域链：作用域链用来保证执行环境中，对所有环境有权访问的变量或者函数的有序访问。每一个执行环境会为自身的变量对象创建一个作用域链，作用域的前端始终是当前执行环境的变量对象，会一直向外延伸到全局作用环境，执行环境查询变量和函数的顺序遵循从局部到全局，一旦找到就会停止查找。\n\n执行环境和作用域是很多概念和一些实现方法的基础，在Javascript里，执行环境决定了访问的权限，作用域链决定了访问的顺序。\n\n#### 闭包和词法作用域\n闭包：闭包就是一个作用域内定义的一个函数，由于Javascript没有块级作用域，局部作用域的形成依赖于函数来实现，所以也可以说闭包是一个函数里定义的一个函数。由于闭包的一个作用就是用来访问其他函数作用域中的变量，所以它又有一种定义：闭包指有权访问另一个函数作用域中变量的一个函数。\n先看一段代码\n```\nname = 'hi';\nfunction close(){\n    name = 'hello';\n    return function sayName(){\n        console.log(name)\n    }\n}\nvar sayName = close();\nsayName();\n```\n词法作用域：在这段代码中console出来的是hello，也就是说sayName执行过程中的name值取得是close函数内部的Name，而不是外部全局环境的name；根据上面对执行环境的理解，当进入sayName这个函数之后，执行环境就由全局进入局部环境，注意到每次定义函数的同时就会生成该函数的执行环境，所以sayName是在哪里声明的，它的外部执行环境就是谁，在这里就是close这个函数的执行环境，再根据上面对作用域链的理解，sayName对于name变量的查询将到此为止，不会到全局去，所以name的值就是hello，而不是hi，简单的说，sayName这个函数所属的作用域是声明它的时候所在的作用域，而不是运行它的时候，高端地说，这就是Javascript的词法作用域。\n\n依照作用域链的原理，本来全局执行环境是没有办法访问到局部执行环境的，但是由于词法作用域的原因，使得sayName这个闭包（全局环境）拥有了访问close内部name变量（局部环境）的能力。\n\n#### 闭包和this关键字\n闭包经常会和this关键字配合使用，每个函数在被调用的时候都会自动获得两个特殊变量，一个是arguments，另一个就是this，所以在一些多层嵌套return的闭包中，无法同过this来正确获得外层的this，因为作用域链在最里层的函数找到this后就停止了，所以一般都需要用一个中间变量来存储或者用bind方法绑定外层的this指向\n```\nvar name = 'hi';\nvar obj = {\n    name:'hello';\n    getName:function(){\n        //var that = this;\n        return function(){\n            return this.name;\n        }\n    }\n}\n```\n关于this的指向问题，只需要认准this当前所在函数的调用方式即可，当函数作为一个对象的方法调用时，this指向为这个对象，当作为一个函数调用时，this在非严格模式下指向全局，严格模式下返回undefined\n\n闭包的作用：\n特权方法：通过上面的闭包的概念理解，已经可以知道闭包的一个作用就是作为一个公有方法用来访问私有变量的，有权访问私有变量和函数的公有方法也叫做特权方法；Javascript中虽然没有传统面向对象中的类，也没有私有成员的概念，不过对于一个函数而言，其函数参数，内部声明的变量或者函数就是私有的。\n```\nfunction Person(){\n    var name = 'daguo';\n    var getAge  = function(){\n        return console.log('22');\n    }\n    this.publicMethod = function(){\n        console.log(name)\n        return getAge()\n    }\n}\n```\n保留变量：通常函数的作用域和其所有变量会在函数执行结束之后就销毁，但是当这个函数返回一个闭包时，只要闭包还存在，那么声明闭包的这个作用域内的变量就不会被销毁，原因就是闭包依然保有对这些变量的引用，使它们不会被JS垃圾回收标记清除。这是一个可以利用的地方，也可能是一个造成内存泄漏的原因。所以不能过多创建闭包\n\n\n\n\n\n\n\n\n\n"},{"header":" chrome扩展程序入门手记","time":" 2016-06-14 23:08:15","tags":" [javascript,chrome]","description":" share my record after learning how to build a plugin for chrome.","section":"chrome是我非常喜欢的浏览器，它除了速度飞快，对前端代码支持友好的优点外，\n还有非常丰富的扩展程序资源，提供了大量方便强大的web页面应用插件\n这两天由于朋友的业务需求，接触了一些chrome扩展程序(即俗称插件)的有关代码\n基于对谷歌开发者文档的学习，随手记录了写chrome插件的基本方法~\n<!--more-->\n每一个基本的Chrome插件,首先都有一个manifest.json\n的配置文件用来存储插件的基本信息 \n\n``\n\"manifest_version\": 2,\n  \"name\": \"Getting started example\",\n  \"description\": \"This extension shows a Google Image search result for the current page\",\n  \"version\": \"1.0\"\n``\n\n包括manifest的版本，扩展插件的名字，描述，版本\n\n弹窗页面的信息browser_action, 在里面配置一个插件弹窗html页面代码，一般名字是popup.html，\n浏览器界面显示的扩展图标位置，以及鼠标hover的title\n\n``\n\"browser_action\": {\n    \"default_icon\": \"images/icon.png\",\n    \"default_popup\": \"popup.html\",\n    \"default_title\": \"Click here!\"\n  }\n``\n\n可选的页面注入代码，一般名字是contentscript.js，\n可选多个文件，匹配页面的matches，只对匹配到的注入代码\n\n``\n\"content_scripts\": [{\n    \"js\": [\"jquery.min.js\", \"contentscript.js\"],\n    \"matches\": [\"http://*/*\",\"https://*/*\"]\n  }]\n``\n\n还有插件要求的权限和要使用该插件的网页的匹配\n\n``\n\"permissions\": [\n    \"tabs\",\n    \"http://*/\"\n  ]\n``\n\n关于manifest的更多字段配置信息，可以查看360翻译谷歌的[开发者文档](http://open.chrome.360.cn/extension_dev/manifest.html)\n\n从上面的配置可以看到，一个简单插件除了有manifest之外\n还有一个browser_action, 即popup.html来渲染点击插件之后的弹窗页面，\n这个页面可以分离出来popup.js popup.css等文件，\n这些文件可以放在同一个根目录下，文件中的引用跟普通项目一致可以取相对路径\n\n\n如果要实现与浏览器打开页面的交互就必须还有一个注入脚本文件，\n一般取名contentscript.js，弹窗页面popup page通过相应api实现和注入脚本的交互\n再由注入脚本实现对web page的交互\n在popup page（popup.js）中的输入代码\n\n```\nchrome.tabs.query({\n      active: true\n    }, function(tab) {\n       var data = '';\n        //要传递给注入脚本文件的信息\n      chrome.tabs.sendMessage(tab[0].id, 'hello, content script, from background page. there are some data:' + data);\n});\n```\n\n第二个参数为发送的信息，在注入脚本中通过request参数拿到\n在contentscript.js中输入以下代码，开启对popup.js的信息发送监听，拿到信息request\n\n```\nchrome.extension.onMessage.addListener(function(request) {\n  //request是popup page传来的信息\n   console.log('get the message from popup.js'+request)\n   //收到popup page的信息后要做的事情\n});\n```\n\n注入脚本contentscript.js和浏览器打开的网页脚本web page运行在不同的环境之下，\n所以他们的变量名和全局对象不会有冲突，\n但是他们共享一个DOM树，也就是可以通过修改注入脚本的DOM结构来改变页面的DOM，\n这也就是注入脚本同web page交互的方式\n\n最后贴一个我练手写的一个[chrome插件](https://github.com/shudery/daguoNote)，\n实现简单的便签功能，界面用amazeUI做的，\n用React渲染，后台处理用Express搭建，数据结果直接保存一份JSON文件来管理\n"},{"header":" javascript的对象构造和原型链继承","time":" 2016-04-14 17:55:58","tags":" [javascript]","description":" javascript的对象构造和原型链继承","section":"这两天仔细地学习了JS的创建对象以及继承的方法，结合红宝石书整理了下笔记。\n（红宝石这里讲了非常多的模式，看第一遍觉得还蛮乱的）\nJavascript作为一种动态的面向对象语言，本身却没有类的概念和方法，\n在创建对象和继承方面有很多有趣的实现和方法\n<!--more-->\n## 1.原始绑定和字面量表示：\n**优点**：简洁方便\n**问题**：使用对象字面量的方法创建的对象，若重复创建会产生大量的重复代码\n```\nvar o = new Object();\no.name = 'shudery';\no.skill = function(){console.log('sayHello')};\n//这是比较老的方法，一般用下面这种简单粗暴的，直接字面量创建\n\nvar obj = {\n    sex = 'man',\n    skill = function(){console.log('tucao')} \n    ...\n}\n```\n## 2.工厂模式：\n抽象创建具体对象的过程\n**具体**：用函数来封装对象，然后调用特定接口创建对象\n**优点和问题**：解决代码重复性的问题，但是没有解决对象识别问题\n```\nfunction createObj(name){\n    var obj= {\n        name : name ,\n        skill : function(){console.log('tucao')}\n    };\n    return obj;\n}\nvar obj_1 = createObj('shudery');\nvar obj_2 = createObj('Lin'); \n//Object类型的对象\n```\n## 3.构造函数模式：\n使用`new`操作符，没有显式创建对象\n**优点**：解决了代码识别问题，可以将它构造的实例标示为特定类型\n**问题**：多次复用的方法需要在每个实例上重新创建一遍，浪费内存\n```\nfunction Myobj(name){\n        this.name = name,\n        this.skill= function(){console.log('tucao')}   \n}\nvar obj_1 =  new Myobj('shudery');\nvar obj_2 =  new Myobj('Lin');\n//对象类型名称为myObj，解决了识别的问题，用下面方法可以验证\nconsole.log(obj_1.constructor === Myobj && obj_2 instanceof Myobj);//true\n```\n这里如果怕遗漏new关键字，可以在`myObj`函数里头显示地返回一个对象，如下：\n```\nfunction Myobj(name){\n        var obj={};\n        obj.name=name,\n        obj.method= function(){\n        console.log('tucao')\n         }\n    return obj;\n}\nvar obj_1 = Myobj('shudery');\nvar obj_2 = new Myobj('shudery');\n```\n如果这么做`obj_1`的`constructor`指向的是`Object`\n这样就和工程模式一样不能识别对象，\n但是功能上两个对象相同，这也被叫寄生构造函数模式，一般不用它\n此外在构造函数模式下如果没有引用this和new，那就是稳妥构造函数模式，\n一般用在安全的环境\n\n## 4.原型模式：\n在构造函数模式下如果直接提取出方法函数到全局环境下，\n在方法变多时容易污染命名空间，\n此外不利于我们自定义的引用类型的封装。\n我们可以用JS的一大特色原型属性来挂载属性方法。\n**优点**：我们可以将复用的方法绑定到每一个构造函数定义的原型属性prototype上来，这样所有的对象实例都可以共享这个挂在这个原型下的属性和方法。\n**问题**：实例失去本身的特点和封装，公用一套属性和方法\n```\nfunction Myobj(){\n       \n}\nMyobj.prototype.name ='shudery';\nMyobj.prototype.age = '22';\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj();\n```\n也可用对象字面量形式，不过要注意顺序，字面量的形式相当于重写整个对象，\n构造函数原型的`constructor`属性（指向对象类型）会被重写为`Object`,\n而不是`Myobj`了\n```\nfunction Myobj(){\n       \n}\nvar obj =  new Myobj();//先实例化\nMyobj.prototype={\n//重写后这个原型和Myobj这个构造函数就没有关系了\n    name: 'shudery',\n    age:'22',\n    method : function(){\n    console.log('tucao')\n    }\n};\nobj.name;//undefined，联系被切断了\n```\n如果在重写之后实例化一个对象，虽然还存在联系，\n但是`obj`实例就不是`Myobj`类型了\n不在乎对象识别问题的话，也可以直接这样重写，仍能调用obj.name等属性和方法\n\n## 5.终极模式：构造函数+原型模式\n 最为常用的创建对象的方式，结合两种模式的优点，\n 实现对象属性的封装和对象方法的复用，\n平衡了对象的独立性和多态复用节省内存的问题。\n```\nfunction Myobj(name,age){\n    this.name =name;\n    this.age = age\n}\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj('shudery',22);\n```\n如此一来对象就拥有自定义的属性和可共享复用的方法啦\n有句话这样说，当我们把程序中变化的部分封装好之后，剩下的就是稳定可复用的了\n这也是很多种设计模式里推崇的，放到创建对象的方法里也是一样的做法。\n\n说完对象的创建，接下来是继承~\nJS是没有类的关键字和概念的，它的继承是基于原型链的，类似上面的原型模式\n我们先简单了解下原型链：\n\n![](https://raw.githubusercontent.com/shudery/public/master/clipboard.png)\n\n每个构造函数都有一个原型对象，构造的实例有一个指向原型对象的指针，\n如果我们把父类的实例赋值给原型对象，那么子类的原型对象就是父类的实例， \n那么这个实例还是有一个指向父类原型的指针，\n这些指针连起了子类和父类的实例（子类构造函数的原型），就是原型链。\n\n对象的方法和属性会循着原型链进行访问，直到查找到相应的属性和方法名，\n或者到达原型链的终点`Object.prototype`,这也就实现了继承\n\n\n\n\n\n\n\n\n\n\n"},{"header":" 搭建属于自己的vpn服务器","time":" 2016-06-10 21:59:48","tags":" [vpn]","description":" how to build vpn or vps by youself","section":"之前实习的时候想着有需要翻墙的时候用着公司的vpn就足够了\n但是随着马上要去工作，还有对一些国外资源的需求（资源你懂的）\n然后也前后被一些网上的vpn服务商坑过（各种掉线，不稳定）\n决定自己租用一台国外的服务器vps\n<!--more-->\n了解一番后知道了国外[搬瓦工](http://bandwagonhost.com/)和[digital ocean](www.digitalocean.com/?refcode=3491087221da)都有不错的口碑，最终选择DO,\n最便宜的512MB内存，20GB固态硬盘，1TB流量，\n\n这个好像只是防止恶意使用的，实际上流量是用不完的，\n在服务器控制版面也没有流量使用情况提示\n首先注册账号，输入邮箱密码，在邮箱收到确认邮件，\n来到Payment Methods \n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_1.png)\n\n这一项我选择的是方便快捷的PayPal，Credit不好设置\n需要预充5刀PayPal，5刀也是最便宜的服务器的月租价格，\n如果没有PayPal的话就先注册一次，比这个Credit方便多了\n注意一些老旧的银联卡号可能提示设置错误，我换了一张卡就好了\n\n然后开始选择服务器，包括价格，地点，系统，\n我选了最便宜已经够用了的5刀/月，ping后较快的美国西部服务器，\n以及比较容易操作的ubuntu系统，然后添加主机的SSH密钥，以后方便，\n\n不过也可以先跳过以后再说，买后会收到邮件，\n得到一个服务器主机Ip，root账户名，以及一个初始密码。\nvps算是有了，接下来我们在这台服务器上搭建vpn\n\n然后不得吐槽的是网页的console控制台实在有点卡卡，\n所以我用简单的putty来建立与vps的链接，也可以使用xshell等工具，\n下载putty后直接输入ip地址，保留默认端口，点击open就进入控制台了\n\n然后输入你的用户名root，然后出现password输入密码，\n这里注意啦~输入密码的时候，光标是不会动的！\n所以，慢慢输入，不要输错了，登录成功后显示一些信息\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_2.png)\n\n第一次登陆要求重置密码，分别填一次旧密码和两次新密码，注意光标还是不会移动！\n然后开始一列Linux操作，作为小白的我们就只管输入代码即可，\n不过我们也是有(yao)追(zhuan)求(bi)的小白，所以也要大概知道这些代码是个什么作用\n\n### 1、安装vpn服务\n首先我们必须在vps服务器上安装一种vpn服务，这里选择点对点隧道协议pptp,输入\n\n```\napt-get install pptpd\n```\n\n### 2、配置文件修改\n用vi编辑器打开配置文件，输入\n\n```\nvi /etc/pptpd.conf\n```\n\n没用过vi的注意啦，要编辑文件必须先输入i，进入INSERT模式，\n将光标移动到最下面更改\n\n```\nlocalip 10.0.0.1\nremoteip 10.0.0.100-200\n```\n\n有两段，localip更改为你vps服务器的ip地址，remoteip是以后分配给\n其他连到你vpn的服务器的ip，可以照着例子分配，写完后保存，\nvi的文件保存方法是先按Esc然后输入冒号:wq即可，w是写入保存，q是退出vi\n\n### 3、添加vpn账号\n用vi打开密钥文件，输入\n\n``` \nvi /etc/ppp/chap-secrets \n```\n\n依次输入 username pptpd password ### \n将username, password更换为你的vpn账号和密码，中间是服务名，\n最后一个是ip通配符，如果要建立多个vpn账号给妹子基友一起用，\n还一行依次输入即可，输完同样保存\n\n### 4、设置公共DNS服务，输入\n\n```\nvi /etc/ppp/pptpd-options\n```\n\n打开服务选项文件设置找到ms-dns并设置为\n`\nms-dns 8.8.8.8\nms-dns 8.8.4.4\n`\n\n### 5、重启pptp服务，\n重启服务，刷新配置，输入\n\n```\nservice pptpd restart\n```\n\n### 6、ip转发配置\n打开转发配置文件，输入\n\n```\nvi /etc/sysctl.conf\n```\n\n发现整个文件都带有注释符#,去掉`# net.ipv4.ip_forward = 1`\n前面的注释符#保存,为了使配置生效还需运行\n\n```\nsysctl -p\n```\n\n### 7、设置iptables\n设置并保存，运行\n\n```\niptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE && iptables-save\n```\n\n至此搭建好属于你自己的vpn，拿着账号在手机和电脑的vpn设置登录即可\n注意如果出现vpn隧道协议构建失败，检查一下网络适配器里vpn的安全属性\n勾选为以下选项\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_3.jpg)\n\n\n\n\n\n\n\n"},{"header":" Javascript开发跨平台桌面app","time":" 2016-06-23 23:32:17","tags":" [javascript,node]","description":" develop cross-platform GUI app with electron","section":"electron原本是atom shell的项目，由于集成node丰富的本地系统级API，\n提供了与操作系统交互的功能，所以归结起来，现在javascrpit的技术栈之所以如此宽广，\n要得益于NodeJS将其中浏览器的环境中分离出来\n\n不过需要特别说明的是，这里生成的桌面应用，\n实际上是Electron生成的一个由Javascrpit控制管理的迷你浏览器Chromeinum，\n它其实是一个Chrome浏览器的试验版本，当然用的也是V8的内核\n<!--more-->\n不管怎么说，这对于喜欢前端，熟悉javascript的同学来说，\n能够用前端和一点后台的知识去接触，尝试各种不同的领域，实在是不要太爽\n\nElectron的入门也符合前端知识领域的特点，几乎没有门槛，\n只要你有一点JS和Node的基础就行了，开发目录的文件层次结构也很简单，\n后面会有打包工具帮助我们一键打包生成层次比较复杂的项目文件，\n作为桌面GUI应用，当然也包括.exe的启动文件，\n\n让我们看看如何开发一个桌面应用，或者说一个能和操作本地系统的web页面的基本方法~\n你可以跟着步骤完成一些基本的文件，也可以直接下载[快速开始的demo](https://github.com/shudery/electron/archive/master.zip)\n基本的文件层次很简单，用app存放一个具体的桌面应用，具体结构是这样的\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_1.png)\n\nOutApp用来存放打包输出的exe文件\n至于为什么有两个``package.json``文件，后面打包操作时你就知道了\n\n### 1、首先安装electron\n命令行进入根目录，先用npm安装electron，如果还没有就先[安装node](https://nodejs.org/en/)\n```\nnpm install -g electron-prebuilt\n```\n### 2、生成``package.json``配置文件\n运行``npm init`` 生成一个``package.json``文件来存放应用的相关配置，这个是第一个``package.json``文件，位于外层根目录下的，运行 \n```\nnpm install --save-dev electron-prebuilt  \n```\n会在devDependencies中生成依赖信息，方便后面打包\n```\n{\n  \"name\": \"firstGUI\",\n  \"version\": \"1.0.0\",\n  \"main\": \"app/main.js\",//js入口文件\n  \"scripts\": {\n    \"build\": \"electron-packager ./app firstApp --platform=win32 --arch=x64 --out ./OutApp --version 0.37.3 --overwrite --icon=./app/img/daguo. jpg\",\n    //打包命令，后面打包可以简化代码\n  },\n  \"devDependencies\": {\n    \"electron-prebuilt\": \"^1.2.0\"\n  }\n}\n```\n### 3、新建main.js\n生成一个入口的js文件来作为控制GUI窗口的主进程程序\n```\nconst electron = require('electron');\n// 控制应用生命周期的模块\nconst {app} = electron;\n// 创建本地浏览器窗口的模块\nconst {BrowserWindow} = electron;\n// 指向窗口对象的一个全局引用\nlet win;\n\nfunction createWindow() {\n\n // 创建一个新的浏览器窗口\n  win = new BrowserWindow({ width: 360, height: 572 });\n // 并且装载应用的index.html页面,注意路径\n  win.loadURL('file://'+__dirname+'/html/index.html');\n // 当窗口关闭时调用的方法\n\n  win.on('closed', () => {\n  // 解除窗口对象的引用，通常而言如果应用支持多个窗口的话，你会在一个数组里\n  // 存放窗口对象，在窗口关闭的时候应当删除相应的元素。\n  win = null;\n  });\n}\n\n// 当Electron完成初始化并且已经创建了浏览器窗口，则该方法将会被调用。\n// 有些API只能在该事件发生后才能被使用。\napp.on('ready', createWindow);\n\n// 当所有的窗口被关闭后退出应用\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\napp.on('activate', () => {\n  if (win === null) {\n    createWindow();\n  }\n});\n// 在这个文件后面你可以直接包含你应用特定的由主进程运行的代码。\n// 也可以把这些代码放在另一个文件中然后在这里导入。\n```\n### 4、index.html\nGUI窗口（web页面）渲染的Html文件\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>firstGUI</title>\n  </head>\n  <body>\n    <h1 style=>Hello World!</h1>\n  </body>\n</html>\n```\n\n### 5、运行桌面app\n大公告成，没错就是如此之快，运行``electron .``（跟一个空格和小点），或者``electron app/main``\n打开制作好的GUI界面，so cool~\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_2.png)\n\n### 6、进行打包\n既然是桌面应用，那肯定是要一键运行的，不需要安装什么依赖模块，\n也不需要运行命令行程序的，所以为了提升逼格，让更多的人可以方便实用你的桌面app，\n需要对app文件夹进行打包，安装打包程序 ``electron-packager``\n```\nnpm install --save-dev electron-packager\n```\n打包的基本命令是 \n```\nelectron-packager <location of project> <name of project> <platform> <architecture> <electron version><optional options>\n```\n上面已经在``package.json``的script里配置了简化的命令，可以根据自身情况对名称，操作系统，应用图标进行修改，\n注意啦开始打包前，一定要复制一份``package.json``到app文件，\n前面说了桌面应用不用下载依赖，其实是因为打包的时候就将依赖一同打包到文件包里了，\n所以我们要打包app文件夹下的文件，需要一个``package.json``  来说明依赖项，注意修改里面的路径，要往下一级，然后运行``npm packager``\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_3.png)\n\n完成打包后可以看到OutApp里头已经有了相应的文件，\n运行里面的exe文件会生成和本地测试时一样的GUI窗口~\n\n\n一个简单的基于前端技术栈的桌面app算是完成了，后续的asar文件加密，\n用nsis制作一个安装引导等等~有兴趣的可以继续完善~\n\n一个桌面级app当然不是用来显示``hello world``的，那样和web页面有什么区别，\n这里只是我入门的一个学习记录，一个基于electron的桌面应用\n还有着非常丰富的与系统交互功能可以设计和开发~\n更加详细的用法和配置有兴趣的同学不妨看看官方的[api演示文档](http://electron.atom.io/)，\n它也是一个基于electron做的桌面app\n\n"},{"header":" 最近的npm模块风波","time":" 2016-04-04 17:53:38","tags":" [npm,modules]","description":" npm导致我们不会写代码了？","section":"最近，前端圈子有件事闹得沸沸扬扬，有一个叫做`leftpad`的npm模块被作者撤下，\n导致一系列引用该模板的项目出现问题。\n\n其实本来大家对这件事的重点应该是关于NPM管理者对于模块作者著作权的保护不周上的，\n但是可能由于这个模块的特殊性和他造成的影响之间的对比太强烈，\n让大家都把注意力放到了这个模块本身和引用这个模块的做法上来了。\n<!--more-->\n**这个模块只有短短十一行，仅仅实现一个简单的字符串左侧填充的功能！**\n\n如此简单的模块为什么那么多项目都要引用他呢？\n其实如果不出现作者`unpublish`的问题，大家不会对这样的做法有太多的疑问，\n因为NodeJS的特色就是如此嘛，而且npm的引用和配置下载也非常方便， \n即使是再简单的模块，我若引用也就是`require`一下，然后将依赖写到json里，\n还是比自己写实现函数要方便一些，虽然方便得不多。\n总之就是不出事还好，一出事，那不好意思就得有人负责，\n这件事没有主要负责人，那么就得有问题被抛出。\n\n所以最近这几天抛出的最多的一个问题就是，**对于简单的代码我们仍要引用模块吗？**\n\n\n首先我觉得像这次又模块被作者下架，这毕竟是少数事件，\n我们不应该讨论对于npm的信任问题，这样会使我们在引用模块时畏手畏脚，\n有人说你简单的函数方法自己写嘛，复杂的再引用别人的，\n就是减少引用，就减少了出了事摊上你的概率，\n我只想说在小概率事件中减小该事件的概率--无关痛痒。\n\n\n总之我对npm模块的引用还是持比较乐观的态度，\nnpm的社区非常繁荣，拥有大批的贡献者，我觉得就是即使是再小的一个模块，\n你写出来了就可以`publish`上去，就可以给别人引用，每个人都有发光发热的机会，\n这给作者多大的鼓励和成就感啊，别人用后也会给你反馈，你再去不断改善，\n大家也可以在`review`其他模块代码中得到非常多的编程技术和思想。\n\n\n与对引用小模块的质疑相反，我觉得引用大模块的问题似乎更多，\n一个项目中引用的大模块往往并不需要里面的很多功能，\n所以NodeJS才在新版中将核心模块分割成多份，大家需要用啥再引用那个模块，\n这样就避免了项目庞大引起的各模块之间可能出现的兼容问题，\n也不至于使得代码太臃肿，至于对小模块引用可能导致require和模块依赖过大，\n但是代码依然比较精简，代码的冗余也比较少。\n\n\n最后，关于npm模块的引用，小模块如果有用过或已经知道的精巧模块，\n不仿大胆引用，若是不清楚也不必特意查询，简单的功能自己想方法实现即可，\n大模块如果与项目的配合不好，该分解的最好分解，结合项目和自身的编程习惯，\n高效的完成项目。\n以上仅仅是个人愚昧的一些看法。\n\n"},{"header":" 用hexo搭建一个博客","time":" 2016-05-05 12:00:33","tags":" [hexo,node,git]","description":" 如何用hexo来搭建一个博客","section":"hexo出自一位台湾大学生之手，是如今搭建，管理博客，发布文章的非常好用的工具，\n之前一直想搭建一个不依赖后台，便于管理和发布的博客，在朋友推荐下用了hexo\n确实是简单粗暴好用~\n基于hexo的博客搭建，对于已经配备了Node环境和git的前端开发人士，\n搭建出一个博客那就是分分钟的事情，即使还没有弄好这些也不难搭建，\n下面就从头大致说一说搭建的流程。\n<!--more-->\n### 创建一个github账号和博客\nhexo搭建的博客是一个静态页面，可以直接托放到github上面的服务器上，\n不需要拥有自己的服务器，所以我们要先有一个github账号，\n然后需要生成一个github的博客，之后我们用自己定制的hexo博客来替换它，\n如何搭建github技术博客可以看看这篇:[创建GitHub技术博客全攻略](http://blog.csdn.net/renfufei/article/details/37725057/)\n### 搭建Node环境\n我们还需要一个运行hexo和调试的环境，就是用Nodejs，\n在[官网地址](https://nodejs.org/en/)选一个稳定版或者开发版一键安装好环境。\n### 安装Hexo，生成文章\n准备好nodejs之后打开命令行使用Node的包管理工具npm,直接在命令行运行\n``\nnpm install -g hexo\n``\n\n下载hexo，然后再在相应的目录运行\n``\nhexo init\n``\n\n即可一键生成文件结构，你可以看到在source/_posts里面有一篇默认的helloworld.md文章，\n在themes里面有一个默认的主题landscape，再继续运行\n``\nhexo generate\n``\n\n### 调试，部署到git\n上面过程之后即可生成一个Public文件，里面会有你的文章内容，然后就可以运行\n``\nhexo server\n``\n\n启动localhost:4000，在浏览器输入地址就可以看到你的博客效果了，\n如果你对默认的配置都满意的话下一步就是运行\n``\nhexo deploy\n``\n\n将内容部署到github上面去了，但是我们好像还没有建立hexo和我们账号github仓库的链接，\n所以要在_config.yml最下面进行一些配置\n```\ndeploy:\n  type: git\n  repo: git@github.com:shudery/shudery.github.io.git # 换成你的博客仓库地址\n  branch: master\n```\n然后再hexo deploy即可完成部署，注意用ssh地址可以免去输入密码的繁琐，\n当然前提是要先生成ssh密钥，并且在你的github上面添加这个ssh密钥~\nhexo博客就已经搭建完成，可以在shudery.github.io上面看到博客页面和文章效果\n### 添加文章，更换主题，修改配置\n基本的东西就是这样，接下来我们可以在_posts里面以markdown的写作形式写文章，\n然后通过同样的方式生成，部署，可以直接在_posts里新建md文件，\n也可以用运行\n``\nhexo new [fileStyle] [fileName]\n``\n\n的方式来生成文件，后者会以scaffolds中对应的fileStyle的形式，\n给你生成一个fileName的md文件，里面会包括一些开头的默认字段，\n会方便记录一些文章的信息，我们还可以在[官网主题](https://hexo.io/themes/)里找一个更加符合心意的主题，\n然后直接git clone/ctrl+c 到我们hexo/themes下面，\n然后在hexo/_config.yml中的 theme:landscape 改为你下载好的主题名，\n然后你会发现主题文件夹里还有一个_config.yml 用来修改主题的一些相关配置，\n你可以参考你下载主题的github,或者官网的介绍来设置这些配置~\n### 完善博客\n最后你可以根据自己的喜好和需求为博客添加一些你喜欢的挂件和工具，\n我自己加了多说评论，百度统计，还有就是换了一个逼格高一点的域名，\n通过添加CNAME域名解析，重定向到github.io的博客地址上面。\n\n搭建过程中一些tips~\n\n* hexo clean会清理缓存和Public文件夹一般是在hexo generate之前使用，但是不用没啥问题\n* hexo/_config.yml对于hexo非常重要，但是如果去掉_config.yml你会发现还是依然能运行各种命令\n* 然而一般运行时报错都是config配置有问题，而且很不好定位，\n  所以可以注释掉config.yml里面你觉得应该不会导致报错的配置，然后再运行看结果，\n  重复几次就可以定位到问题了，这对一开始没有什么经验的人来说是一个可行的debug方法。\n* 在做域名重定向的时候，域名解析的CNAME需要指向github.io，\n  此外还要在hexo/source下面也建立一个CNAME文件指向你的设置了重定向的域名地址才行"},{"header":" ES5和ES6中对于继承的实现方法","time":" 2016-07-23 23:32:17","tags":" [javascript]","description":" develop cross-platform GUI app with electron","section":"\n在ES5继承的实现非常有趣的，由于没有传统面向对象类的概念，Javascript利用原型链的特性来实现继承，这其中有很多的属性指向和需要注意的地方。\n原型链的特点和实现已经在之前的一篇整理说过了，就是通过将子类构造函数的原型作为父类构造函数的实例，这样就连通了子类-子类原型-父类，原型链的特点就是逐层查找，从子类开始一直往上直到所有对象的原型Object.prototype，找到属性方法之后就会停止查找，所以下层的属性方法会覆盖上层。\n<!--more-->\n一个基本的基于原型链的继承过程大概是这样的：\n```\n//先来个父类，带些属性\nfunction Super(){\n    this.flag = true;\n}\n//为了提高复用性，方法绑定在父类原型属性上\nSuper.prototype.getFlag = function(){\n    return this.flag;\n}\n//来个子类\nfunction Sub(){\n    this.subFlag = false;\n}\n//实现继承\nSub.prototype = new Super;\n//给子类添加子类特有的方法，注意顺序要在继承之后\nSub.prototype.getSubFlag = function(){\n    return this.subFlag;\n}\n//构造实例\nvar es5 = new Sub;\n```\n原型链实现的继承主要有几个问题：\n1、本来我们为了构造函数属性的封装私有性，方法的复用性，提倡将属性声明在构造函数内，而将方法绑定在原型对象上，但是现在子类的原型是父类的一个实例，自然父类的属性就变成子类原型的属性了；\n这就会带来一个问题，我们知道构造函数的原型属性在所有构造的实例中是共享的，所以原型中属性的改变会反应到所有的实例上，这就违背了我们想要属性私有化的初衷；\n2、创建子类的实例时，不能向父类的构造函数传递参数\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n   this.subFlag = false;\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nobj.flag = flase;  //修改之后，由于是原型上的属性，之后创建的所有实例都会受到影响\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //false；\n```\n为了解决以上两个问题，有一个叫借用构造函数的方法\n只需要在子类构造函数内部使用apply或者call来调用父类的函数即可在实现属性继承的同时，又能传递参数，又能让实例不互相影响\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n    Super.call(this)  //如果父类可以需要接收参数，这里也可以直接传递\n}\nvar obj = new Sub();\nobj.flag = flase;\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //依然是true，不会相互影响\n```\n结合借用构造函数和原型链的方法，可以实现比较完美的继承方法，可以称为组合继承：\n```\nfunction Super(){\n    this.flag = true;\n}\nSuper.prototype.getFlag = function(){\n    return this.flag;     //继承方法\n}\nfunction Sub(){\n    this.subFlag = flase\n    Super.call(this)    //继承属性\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nSuper.prototype.getSubFlag = function(){\n    return this.flag;\n}\n```\n这里还有个小问题，Sub.prototype = new Super;  会导致Sub.prototype的constructor指向Super;\n然而constructor的定义是要指向原型属性对应的构造函数的，Sub.prototype是Sub构造函数的原型，所以应该添加一句纠正：\nSub.prototype.constructor = Sub;\n\n看完ES5的实现，再来看看ES6的继承实现方法，其内部其实也是ES5组合继承的方式，通过call借用构造函数，在A类构造函数中调用相关属性，再用原型链的连接实现方法的继承\n```\nclass B extends A {\n  constructor() {\n    return A.call(this);  //继承属性\n  }\n}\nA.prototype = new B;  //继承方法  \n```\nES6封装了class，extends关键字来实现继承，内部的实现原理其实依然是基于上面所讲的原型链，不过进过一层封装后，Javascript的继承得以更加简洁优雅地实现\n```\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 等同于parent.constructor(x, y)\n    this.color = color;\n  }\n  toString() {\n    return this.color + ' ' + super.toString(); // 等同于parent.toString()\n  }\n}\n```\n通过constructor来定义构造函数，用super调用父类的属性方法\n\nES6中Class充当了ES5中，构造函数在继承实现过程中的作用\n同样有原型属性prototype，以及在ES5中用来指向构造函数原型的`__proto__`属性，这个属性在ES6中的指向有一些主动的修改。\n一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法继承。\n```\nclass A extends B {}\nA.__proto__ === B;  //继承属性\nA.prototype.__proto__ === B.prototype;  //继承方法\n```\nES6的子类的`__proto__`是父类，子类的原型的`__proto__`是父类的原型\n第二条继承链理解起来没有什么问题，对应到ES5中的A.prototype = new B;A.prototype作为B构造的实例，指向构造函数B的原型B.prototype，\n但是在ES5中A.`__proto__`是指向Function.prototype的，因为每一个构造函数其实都是Function这个对象构造的，ES6中子类的`__proto__`指向父类可以实现属性的继承，在ES5中在没有用借用继承的时候由于父类属性被子类原型继承，所有的子类实例实际上都是同一个属性引用。\n在ES6中实现了子类继承父类属性，在构造实例的时候会直接拿到子类的属性，不需要查找到原型属性上面去，ES6新的静态方法和静态属性（只能在构造函数上访问）也是通过这样类的直接继承来实现，至于普通复用方法还是放到原型链上，道理和实现和ES5是一样的。\n此外我认为这里修改A.`__proto__`的指向是有意区分ES6中继承和实例化，同时建立子类和父类直接的关系，ES5的子类的构造函数通过子类的原型与父类的构造函数连接，不存在直接的关系；\n可以这么说，在ES5继承和构造实例，ES6构造实例的时候可以理解`__proto__`原型指针是用来指向构造函数的原型的，但是在ES6继承中，`__proto__`指继承自哪个类或原型，在A继承B之后，构造一个实例 var obj = new A; 会发现它所有的属性指向都是和ES5一致的。\n\n\n有个有趣的地方：ES6继承是在父类创建this对象，在子类constructor中来修饰父类的this，ES5是在子类创建this，将父类的属性方法绑定到子类，由于原生的构造函数（Function，Array等）没有this，子类无法通过call/apply(this)获得其内部属性，所以在ES5无法继承，ES6实现后可以为原生构造函数封装一些有趣的接口，比方说阮一峰老师的这个给Array实例封装一个版本记录和回滚的方法：\n```\nclass VersionedArray extends Array {\n  constructor() {\n    super();\n    this.history = [[]];\n  }\n  commit() {\n    this.history.push(this.slice());\n  }\n  revert() {\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  }\n}\n\nvar x = new VersionedArray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\nx.push(3);\nx // [1, 2, 3]\n\nx.revert();\nx // [1, 2]\n```\n最后做一个ES5和ES6的继承小结：\nES5最经典的继承方法是用组合继承的方式，原型链继承方法，借用函数继承属性，ES6也是基于这样的方式，但是封装了更优雅简洁的api，让Javascript越来越强大，修改了一些属性指向，规范了继承的操作，区分开了继承实现和实例构造，此外ES6继承还能实现更多的继承需求和场景。\n\n\n\n\n\n\n"},{"header":" HTTP缓存及众多的web储存概念之小整理","time":" 2016-08-12 01:46:57","tags":" [javascript,html]","description":" this is a article for my way of studying front-end","section":"\n缓存对于一个网站来说非常重要，可以提高网站性能，减少冗余的数据传输，增加服务器负担，web存储则给浏览器提供了更加强大的保存文件的接口。\n有相当一段时间一直混淆了HTTP缓存相关的属性，HTML5离线存储和本地储存的一些关系，最近好好地整理了一下这些Web存储相关的东西\n\n先列出一些相关属性和概念，看看能否理清它们之间的区别和联系？\n<!--more-->\n\n* manifest\n* cache-control\n* expires\n* 304(no modified)\n* ETag\n* If-None-Match\n* Last-Modified\n* If-Modified-Since\n* http-equiv\n* webstorage\n* cookie/session\n\n是不是感觉有点凌乱，那就跟着我整理的笔记走一遍吧：）\n首先说一说HTTP缓存相关的东西:\n　　\n　　\n`Cache-Control`\n每一个用HTTP请求的资源都可以在响应头用Cache-Control来给浏览器定义缓存策略，通过设置一些属性值它可以控制谁可以，在什么条件下可以缓存响应，还有缓存的有效期，这个属性的一些常用值如下\n\n`no-cache：`表示不使用缓存，先和服务器确认要返回的资源是否有修改\n`no-store：`表示禁止浏览器和所有中继缓存响应的资源\n`max-age=100：`表示缓存的有效期，单位是秒，这一段时间内，除非缓存文件发生一些变动，否则会直接使用之前的缓存，注意这段时间内是不会发Etag等方法去验证的资源有没有修改的。缓存的文件发生变动，主要有这些情况：资源名更改，资源地址更改，缓存被删除，网页强制刷新等；资源名更改，给文件名添加版本hash值，比如给image.png修改为image-hash.png，可以保证每次更新文件时用户可以重新发出请求，获取最新的资源。资源路径更改，修改文件的请求路径，比如给image.png添加查询参数修改为image.png?hash，max-age的时间设置根据每个网站的实际情况不同去设置，一种极端的做法是把这个值设置很大，然后通过修改资源名或者给资源请求地址添加查询参数，来告诉浏览器该更新资源了，一般用在很久才更新网站的情况\n`public：`用max-age即是默认public了，不用设置\n`private：`私人缓存，中继缓存不被允许，但是可以在浏览器缓存\n\n`PS：expires：`表示存在的时间，使客户端在这个设置的时间之前不用去请求资源，类似于max-age，但是expires表示的是一个固定时间，而且可能有服务器和客户端时间不一致的问题，主要用于HTTP1.0版本，在HTTP1.1版本完全可以用功能更强的Cache-Control来替代，和max-age同时存在时expiers会被覆盖掉\n`PS：http-equiv：`缓存有两种控制机制，一种是请求头信息控制，另外一种就是利用meta标签；可以在HTML文档中为meta标签设置http-equiv为相应属性名，content为值来设置缓存，例如\n`<meta http-equiv=\"Expires\" content=\"Mon, 20 Jul 2009 23:00:00 GMT\" />`，不过只对改网页的HTML文件有缓存作用，对该页面的其他资源以及其他页面的HTML文件都没有作用\n　　\n　　\n那么max-age（expires）到期之后，在no-cache下的资源会先和服务器确认返回的资源是否有修改，如何实现这一过程？\n`ETag/If-None-Match，Last-Modified/If-Modified-Since`\nETag (Entity Tag)其实就是一个验证令牌，用来标识一个资源，可能是一个hash值，也可能是一个版本号，每当资源有修改的时候ETag的值就会改变\n浏览器第一次请求之后会保存响应头的ETag值，以便下一次发送请求的时候校验Etag是否有更改。\n　　\n　　\n那么下一次浏览器如何告诉服务器本地已经存有Etag和相应的资源了呢？If-None-Match\n通过在请求头添加If-None-Match(如果存在ETag，浏览器会自动添加)，赋值为上一次请求后在本地存储的Etag值，服务器会和服务端最新资源的Etag比对，如果没有更改会直接返回304 no modified给浏览器，浏览器就直接使用本地缓存的文件\n\n`PS：Last-Modified/If-Modified-Since`的作用等同于`ETag/If-None-Match，`不过前者是通过规定一个时间来比对，最小的单位是秒，后者通过一个唯一标识符，所以可以看出来如果原站在一秒内有多次更新，那么前者就不顶用啦。\nETag的验证要优先于Last-Modified，此外ETag也是有缺点的，在分布式的环境中，Etag在不同服务器上的同步问题可能会给服务器带来一些压力。\n　　\n　　\n`HTTP缓存`是和每一个HTTP请求直接相关的，每一个请求资源的响应都有相应的缓存策略，它们往往是相似的，是否可以通过其他的机制，直接告诉浏览器去缓存哪一些文件呢？\n`HTML5离线存储`闪亮出场\n\nH5离线存储：服务器通过一份.manifest文件给浏览器提供一份完备的缓存名单，名单包括需要缓存的文件，不需要缓存的文件的列表之外，还有一些其他的功能，比如给资源设置备选的请求地址，设置404页面等\n\n实现：利用H5的标签新属性manifest，只需要在HTML文件添加`<html manifest=\"test.manifest\">，`服务器则将manifest文件的mime-type设置为text/cache-manifest类型即可，浏览器每次请求会检查`manifest`是否有更新，服务端通过修改manifest文件，即可在浏览器下一次请求资源的时候通知其更新相应的资源。\n作用：通过本地离线存储可以在没有网络的情况下访问网站事先保存的文件资源，在有网络的情况下直接使用本地资源也可以减少请求连接的压力，提高网页的加载速度，注意这里和HTTP缓存的区别，它是直接使用本地资源，请求返回的是200（from cache）,由于有manifest来统一管理，所以不需要发请求查看是否有更新，也没有过期时间。\n　\n`PS：`这里关于manifest文件自身的更新问题，还是要走HTTP缓存，或者直接不缓存这个文件。\n　　\n　　\n前面提到的概念主要都是缓存请求文件这一块的东西，它们的目的都是为了提高网页的性能，可以说是一种优化型的存储，可以给用户带来更流畅的体验\n但是我们印象中还有一种存储，它可以给我们提供更多的可能和效果的实现，是功能型的存储，如H5本地储存`Webstorage，cookie，session`\n　　\n　　\n`cookie，session`\n众所周知，HTTP是无状态的协议，每一次请求都是独立没有联系的，浏览器和服务器都没有办法维持用户的状态，判断用户是不是依然是之前的那个用户。\n很容易可以想到，在同一个用户的每个请求头添加一个唯一标识符，通过判断这个标识符就可以维持用户的一些信息和状态\n会话信息被用来作为标识符解决这个问题，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案（服务端保持状态也需要客户端保持状态，所以一般session都要基础cookie或者sessionstorage）\n\n总的来说：cookie数据放在客户端，session数据放在服务端，cookie可以设置期限，session则是关闭浏览器时销毁（cookie默认也是），cookie不安全，session可能会影响服务器性能\n\n`Cookie：`通常用Javascript封装一个setCookie的函数来创建，有大小限制，可能会导致请求头过于臃肿，浏览器发送请求时，检查本地cookie，如果该cookie声明的范围大于发送请求的url地址时，就会自动在请求上添加cookie字段\n\n`session：`服务器每次会检查浏览器请求头的session标识，如果有则将这个session id在服务器的数据库（散列表）查找，找到后才进行相应权限的操作\n如果没有这个请求标识，则为客户端新建一个，返回给客户端后，客户端可以通过cookie或者sessionstorage来保存这个session id，通过请求头的cookie字段来给服务器提供sessionId，当cookie被禁止时就需要一些其他方法，通常是采用添加到url路径中，添加表单隐藏域等方法\n\ncookie作为HTTP协议规范的一部分，主要还是用来储存用户信息的，用来和服务端交互，大小也有限制，仅仅只是一种会话级别的存储\n　　\n　　\n`localstorage，sessionstorage`\n`webstorage`为了更大的存储文件设计，与Cookie负责记录用户信息相比，webStorage专注于本地存储，通过封装好的setItem，getItem等方法即可使用\nlocalstorage是一种持久化的存储，除非主动删除，否则永远存在，sessionstorage主要用来存储会话（session），关闭浏览器就会销毁，是一种非持久化的存储\n　　\n　　\n除了上面这些的概念之外，还有诸如像IndexDB，FileSystem等存储方法，关于Web存储的知识真的非常多，看上去坑也是不少，还需要实践慢慢来掌握。\n\n\n\n\n\n\n\n\n\n"},{"header":" JavaScript关键概念理解之闭包","time":" 2016-07-10 21:59:48","tags":" [javascript]","description":" none","section":"\nJavaScript作为一种多范式编程语言，和许多函数式编程语言一样拥有闭包的概念。\n闭包是一个老生常谈的问题，前端面试必问，要理解闭包的原理，必须知道什么是词法作用域，理解词法作用域，又需要对Javascript另外两个关键概念的掌握和理解~\n\n<!--more-->\n\n#### 执行环境和作用域链\n执行环境：红宝书将执行环境称为Javascript这么编程语言最为重要的一个概念，一开始我是不服的，屌屌的闭包和原型链呢？后来一番整理，才发现原来闭包和原型链的实现都是依赖于执行环境。\n执行环境定义了变量或者函数有权访问的数据，决定了它们各自的行为，每个执行环境拥有一个变量对象来保存环境中定义的所有变量和函数。\n每个函数都有自己的执行环境，每次执行语句进入函数后，就会将相应函数的执行函数压入环境栈中，执行完函数之后就会弹出，将控制权交给原来的执行环境。\n\n作用域链：作用域链用来保证执行环境中，对所有环境有权访问的变量或者函数的有序访问。每一个执行环境会为自身的变量对象创建一个作用域链，作用域的前端始终是当前执行环境的变量对象，会一直向外延伸到全局作用环境，执行环境查询变量和函数的顺序遵循从局部到全局，一旦找到就会停止查找。\n\n执行环境和作用域是很多概念和一些实现方法的基础，在Javascript里，执行环境决定了访问的权限，作用域链决定了访问的顺序。\n\n#### 闭包和词法作用域\n闭包：闭包就是一个作用域内定义的一个函数，由于Javascript没有块级作用域，局部作用域的形成依赖于函数来实现，所以也可以说闭包是一个函数里定义的一个函数。由于闭包的一个作用就是用来访问其他函数作用域中的变量，所以它又有一种定义：闭包指有权访问另一个函数作用域中变量的一个函数。\n先看一段代码\n```\nname = 'hi';\nfunction close(){\n    name = 'hello';\n    return function sayName(){\n        console.log(name)\n    }\n}\nvar sayName = close();\nsayName();\n```\n词法作用域：在这段代码中console出来的是hello，也就是说sayName执行过程中的name值取得是close函数内部的Name，而不是外部全局环境的name；根据上面对执行环境的理解，当进入sayName这个函数之后，执行环境就由全局进入局部环境，注意到每次定义函数的同时就会生成该函数的执行环境，所以sayName是在哪里声明的，它的外部执行环境就是谁，在这里就是close这个函数的执行环境，再根据上面对作用域链的理解，sayName对于name变量的查询将到此为止，不会到全局去，所以name的值就是hello，而不是hi，简单的说，sayName这个函数所属的作用域是声明它的时候所在的作用域，而不是运行它的时候，高端地说，这就是Javascript的词法作用域。\n\n依照作用域链的原理，本来全局执行环境是没有办法访问到局部执行环境的，但是由于词法作用域的原因，使得sayName这个闭包（全局环境）拥有了访问close内部name变量（局部环境）的能力。\n\n#### 闭包和this关键字\n闭包经常会和this关键字配合使用，每个函数在被调用的时候都会自动获得两个特殊变量，一个是arguments，另一个就是this，所以在一些多层嵌套return的闭包中，无法同过this来正确获得外层的this，因为作用域链在最里层的函数找到this后就停止了，所以一般都需要用一个中间变量来存储或者用bind方法绑定外层的this指向\n```\nvar name = 'hi';\nvar obj = {\n    name:'hello';\n    getName:function(){\n        //var that = this;\n        return function(){\n            return this.name;\n        }\n    }\n}\n```\n关于this的指向问题，只需要认准this当前所在函数的调用方式即可，当函数作为一个对象的方法调用时，this指向为这个对象，当作为一个函数调用时，this在非严格模式下指向全局，严格模式下返回undefined\n\n闭包的作用：\n特权方法：通过上面的闭包的概念理解，已经可以知道闭包的一个作用就是作为一个公有方法用来访问私有变量的，有权访问私有变量和函数的公有方法也叫做特权方法；Javascript中虽然没有传统面向对象中的类，也没有私有成员的概念，不过对于一个函数而言，其函数参数，内部声明的变量或者函数就是私有的。\n```\nfunction Person(){\n    var name = 'daguo';\n    var getAge  = function(){\n        return console.log('22');\n    }\n    this.publicMethod = function(){\n        console.log(name)\n        return getAge()\n    }\n}\n```\n保留变量：通常函数的作用域和其所有变量会在函数执行结束之后就销毁，但是当这个函数返回一个闭包时，只要闭包还存在，那么声明闭包的这个作用域内的变量就不会被销毁，原因就是闭包依然保有对这些变量的引用，使它们不会被JS垃圾回收标记清除。这是一个可以利用的地方，也可能是一个造成内存泄漏的原因。所以不能过多创建闭包\n\n\n\n\n\n\n\n\n\n"},{"header":" chrome扩展程序入门手记","time":" 2016-06-14 23:08:15","tags":" [javascript,chrome]","description":" share my record after learning how to build a plugin for chrome.","section":"chrome是我非常喜欢的浏览器，它除了速度飞快，对前端代码支持友好的优点外，\n还有非常丰富的扩展程序资源，提供了大量方便强大的web页面应用插件\n这两天由于朋友的业务需求，接触了一些chrome扩展程序(即俗称插件)的有关代码\n基于对谷歌开发者文档的学习，随手记录了写chrome插件的基本方法~\n<!--more-->\n每一个基本的Chrome插件,首先都有一个manifest.json\n的配置文件用来存储插件的基本信息 \n\n``\n\"manifest_version\": 2,\n  \"name\": \"Getting started example\",\n  \"description\": \"This extension shows a Google Image search result for the current page\",\n  \"version\": \"1.0\"\n``\n\n包括manifest的版本，扩展插件的名字，描述，版本\n\n弹窗页面的信息browser_action, 在里面配置一个插件弹窗html页面代码，一般名字是popup.html，\n浏览器界面显示的扩展图标位置，以及鼠标hover的title\n\n``\n\"browser_action\": {\n    \"default_icon\": \"images/icon.png\",\n    \"default_popup\": \"popup.html\",\n    \"default_title\": \"Click here!\"\n  }\n``\n\n可选的页面注入代码，一般名字是contentscript.js，\n可选多个文件，匹配页面的matches，只对匹配到的注入代码\n\n``\n\"content_scripts\": [{\n    \"js\": [\"jquery.min.js\", \"contentscript.js\"],\n    \"matches\": [\"http://*/*\",\"https://*/*\"]\n  }]\n``\n\n还有插件要求的权限和要使用该插件的网页的匹配\n\n``\n\"permissions\": [\n    \"tabs\",\n    \"http://*/\"\n  ]\n``\n\n关于manifest的更多字段配置信息，可以查看360翻译谷歌的[开发者文档](http://open.chrome.360.cn/extension_dev/manifest.html)\n\n从上面的配置可以看到，一个简单插件除了有manifest之外\n还有一个browser_action, 即popup.html来渲染点击插件之后的弹窗页面，\n这个页面可以分离出来popup.js popup.css等文件，\n这些文件可以放在同一个根目录下，文件中的引用跟普通项目一致可以取相对路径\n\n\n如果要实现与浏览器打开页面的交互就必须还有一个注入脚本文件，\n一般取名contentscript.js，弹窗页面popup page通过相应api实现和注入脚本的交互\n再由注入脚本实现对web page的交互\n在popup page（popup.js）中的输入代码\n\n```\nchrome.tabs.query({\n      active: true\n    }, function(tab) {\n       var data = '';\n        //要传递给注入脚本文件的信息\n      chrome.tabs.sendMessage(tab[0].id, 'hello, content script, from background page. there are some data:' + data);\n});\n```\n\n第二个参数为发送的信息，在注入脚本中通过request参数拿到\n在contentscript.js中输入以下代码，开启对popup.js的信息发送监听，拿到信息request\n\n```\nchrome.extension.onMessage.addListener(function(request) {\n  //request是popup page传来的信息\n   console.log('get the message from popup.js'+request)\n   //收到popup page的信息后要做的事情\n});\n```\n\n注入脚本contentscript.js和浏览器打开的网页脚本web page运行在不同的环境之下，\n所以他们的变量名和全局对象不会有冲突，\n但是他们共享一个DOM树，也就是可以通过修改注入脚本的DOM结构来改变页面的DOM，\n这也就是注入脚本同web page交互的方式\n\n最后贴一个我练手写的一个[chrome插件](https://github.com/shudery/daguoNote)，\n实现简单的便签功能，界面用amazeUI做的，\n用React渲染，后台处理用Express搭建，数据结果直接保存一份JSON文件来管理\n"},{"header":" javascript的对象构造和原型链继承","time":" 2016-04-14 17:55:58","tags":" [javascript]","description":" javascript的对象构造和原型链继承","section":"这两天仔细地学习了JS的创建对象以及继承的方法，结合红宝石书整理了下笔记。\n（红宝石这里讲了非常多的模式，看第一遍觉得还蛮乱的）\nJavascript作为一种动态的面向对象语言，本身却没有类的概念和方法，\n在创建对象和继承方面有很多有趣的实现和方法\n<!--more-->\n## 1.原始绑定和字面量表示：\n**优点**：简洁方便\n**问题**：使用对象字面量的方法创建的对象，若重复创建会产生大量的重复代码\n```\nvar o = new Object();\no.name = 'shudery';\no.skill = function(){console.log('sayHello')};\n//这是比较老的方法，一般用下面这种简单粗暴的，直接字面量创建\n\nvar obj = {\n    sex = 'man',\n    skill = function(){console.log('tucao')} \n    ...\n}\n```\n## 2.工厂模式：\n抽象创建具体对象的过程\n**具体**：用函数来封装对象，然后调用特定接口创建对象\n**优点和问题**：解决代码重复性的问题，但是没有解决对象识别问题\n```\nfunction createObj(name){\n    var obj= {\n        name : name ,\n        skill : function(){console.log('tucao')}\n    };\n    return obj;\n}\nvar obj_1 = createObj('shudery');\nvar obj_2 = createObj('Lin'); \n//Object类型的对象\n```\n## 3.构造函数模式：\n使用`new`操作符，没有显式创建对象\n**优点**：解决了代码识别问题，可以将它构造的实例标示为特定类型\n**问题**：多次复用的方法需要在每个实例上重新创建一遍，浪费内存\n```\nfunction Myobj(name){\n        this.name = name,\n        this.skill= function(){console.log('tucao')}   \n}\nvar obj_1 =  new Myobj('shudery');\nvar obj_2 =  new Myobj('Lin');\n//对象类型名称为myObj，解决了识别的问题，用下面方法可以验证\nconsole.log(obj_1.constructor === Myobj && obj_2 instanceof Myobj);//true\n```\n这里如果怕遗漏new关键字，可以在`myObj`函数里头显示地返回一个对象，如下：\n```\nfunction Myobj(name){\n        var obj={};\n        obj.name=name,\n        obj.method= function(){\n        console.log('tucao')\n         }\n    return obj;\n}\nvar obj_1 = Myobj('shudery');\nvar obj_2 = new Myobj('shudery');\n```\n如果这么做`obj_1`的`constructor`指向的是`Object`\n这样就和工程模式一样不能识别对象，\n但是功能上两个对象相同，这也被叫寄生构造函数模式，一般不用它\n此外在构造函数模式下如果没有引用this和new，那就是稳妥构造函数模式，\n一般用在安全的环境\n\n## 4.原型模式：\n在构造函数模式下如果直接提取出方法函数到全局环境下，\n在方法变多时容易污染命名空间，\n此外不利于我们自定义的引用类型的封装。\n我们可以用JS的一大特色原型属性来挂载属性方法。\n**优点**：我们可以将复用的方法绑定到每一个构造函数定义的原型属性prototype上来，这样所有的对象实例都可以共享这个挂在这个原型下的属性和方法。\n**问题**：实例失去本身的特点和封装，公用一套属性和方法\n```\nfunction Myobj(){\n       \n}\nMyobj.prototype.name ='shudery';\nMyobj.prototype.age = '22';\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj();\n```\n也可用对象字面量形式，不过要注意顺序，字面量的形式相当于重写整个对象，\n构造函数原型的`constructor`属性（指向对象类型）会被重写为`Object`,\n而不是`Myobj`了\n```\nfunction Myobj(){\n       \n}\nvar obj =  new Myobj();//先实例化\nMyobj.prototype={\n//重写后这个原型和Myobj这个构造函数就没有关系了\n    name: 'shudery',\n    age:'22',\n    method : function(){\n    console.log('tucao')\n    }\n};\nobj.name;//undefined，联系被切断了\n```\n如果在重写之后实例化一个对象，虽然还存在联系，\n但是`obj`实例就不是`Myobj`类型了\n不在乎对象识别问题的话，也可以直接这样重写，仍能调用obj.name等属性和方法\n\n## 5.终极模式：构造函数+原型模式\n 最为常用的创建对象的方式，结合两种模式的优点，\n 实现对象属性的封装和对象方法的复用，\n平衡了对象的独立性和多态复用节省内存的问题。\n```\nfunction Myobj(name,age){\n    this.name =name;\n    this.age = age\n}\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj('shudery',22);\n```\n如此一来对象就拥有自定义的属性和可共享复用的方法啦\n有句话这样说，当我们把程序中变化的部分封装好之后，剩下的就是稳定可复用的了\n这也是很多种设计模式里推崇的，放到创建对象的方法里也是一样的做法。\n\n说完对象的创建，接下来是继承~\nJS是没有类的关键字和概念的，它的继承是基于原型链的，类似上面的原型模式\n我们先简单了解下原型链：\n\n![](https://raw.githubusercontent.com/shudery/public/master/clipboard.png)\n\n每个构造函数都有一个原型对象，构造的实例有一个指向原型对象的指针，\n如果我们把父类的实例赋值给原型对象，那么子类的原型对象就是父类的实例， \n那么这个实例还是有一个指向父类原型的指针，\n这些指针连起了子类和父类的实例（子类构造函数的原型），就是原型链。\n\n对象的方法和属性会循着原型链进行访问，直到查找到相应的属性和方法名，\n或者到达原型链的终点`Object.prototype`,这也就实现了继承\n\n\n\n\n\n\n\n\n\n\n"},{"header":" 搭建属于自己的vpn服务器","time":" 2016-06-10 21:59:48","tags":" [vpn]","description":" how to build vpn or vps by youself","section":"之前实习的时候想着有需要翻墙的时候用着公司的vpn就足够了\n但是随着马上要去工作，还有对一些国外资源的需求（资源你懂的）\n然后也前后被一些网上的vpn服务商坑过（各种掉线，不稳定）\n决定自己租用一台国外的服务器vps\n<!--more-->\n了解一番后知道了国外[搬瓦工](http://bandwagonhost.com/)和[digital ocean](www.digitalocean.com/?refcode=3491087221da)都有不错的口碑，最终选择DO,\n最便宜的512MB内存，20GB固态硬盘，1TB流量，\n\n这个好像只是防止恶意使用的，实际上流量是用不完的，\n在服务器控制版面也没有流量使用情况提示\n首先注册账号，输入邮箱密码，在邮箱收到确认邮件，\n来到Payment Methods \n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_1.png)\n\n这一项我选择的是方便快捷的PayPal，Credit不好设置\n需要预充5刀PayPal，5刀也是最便宜的服务器的月租价格，\n如果没有PayPal的话就先注册一次，比这个Credit方便多了\n注意一些老旧的银联卡号可能提示设置错误，我换了一张卡就好了\n\n然后开始选择服务器，包括价格，地点，系统，\n我选了最便宜已经够用了的5刀/月，ping后较快的美国西部服务器，\n以及比较容易操作的ubuntu系统，然后添加主机的SSH密钥，以后方便，\n\n不过也可以先跳过以后再说，买后会收到邮件，\n得到一个服务器主机Ip，root账户名，以及一个初始密码。\nvps算是有了，接下来我们在这台服务器上搭建vpn\n\n然后不得吐槽的是网页的console控制台实在有点卡卡，\n所以我用简单的putty来建立与vps的链接，也可以使用xshell等工具，\n下载putty后直接输入ip地址，保留默认端口，点击open就进入控制台了\n\n然后输入你的用户名root，然后出现password输入密码，\n这里注意啦~输入密码的时候，光标是不会动的！\n所以，慢慢输入，不要输错了，登录成功后显示一些信息\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_2.png)\n\n第一次登陆要求重置密码，分别填一次旧密码和两次新密码，注意光标还是不会移动！\n然后开始一列Linux操作，作为小白的我们就只管输入代码即可，\n不过我们也是有(yao)追(zhuan)求(bi)的小白，所以也要大概知道这些代码是个什么作用\n\n### 1、安装vpn服务\n首先我们必须在vps服务器上安装一种vpn服务，这里选择点对点隧道协议pptp,输入\n\n```\napt-get install pptpd\n```\n\n### 2、配置文件修改\n用vi编辑器打开配置文件，输入\n\n```\nvi /etc/pptpd.conf\n```\n\n没用过vi的注意啦，要编辑文件必须先输入i，进入INSERT模式，\n将光标移动到最下面更改\n\n```\nlocalip 10.0.0.1\nremoteip 10.0.0.100-200\n```\n\n有两段，localip更改为你vps服务器的ip地址，remoteip是以后分配给\n其他连到你vpn的服务器的ip，可以照着例子分配，写完后保存，\nvi的文件保存方法是先按Esc然后输入冒号:wq即可，w是写入保存，q是退出vi\n\n### 3、添加vpn账号\n用vi打开密钥文件，输入\n\n``` \nvi /etc/ppp/chap-secrets \n```\n\n依次输入 username pptpd password ### \n将username, password更换为你的vpn账号和密码，中间是服务名，\n最后一个是ip通配符，如果要建立多个vpn账号给妹子基友一起用，\n还一行依次输入即可，输完同样保存\n\n### 4、设置公共DNS服务，输入\n\n```\nvi /etc/ppp/pptpd-options\n```\n\n打开服务选项文件设置找到ms-dns并设置为\n`\nms-dns 8.8.8.8\nms-dns 8.8.4.4\n`\n\n### 5、重启pptp服务，\n重启服务，刷新配置，输入\n\n```\nservice pptpd restart\n```\n\n### 6、ip转发配置\n打开转发配置文件，输入\n\n```\nvi /etc/sysctl.conf\n```\n\n发现整个文件都带有注释符#,去掉`# net.ipv4.ip_forward = 1`\n前面的注释符#保存,为了使配置生效还需运行\n\n```\nsysctl -p\n```\n\n### 7、设置iptables\n设置并保存，运行\n\n```\niptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE && iptables-save\n```\n\n至此搭建好属于你自己的vpn，拿着账号在手机和电脑的vpn设置登录即可\n注意如果出现vpn隧道协议构建失败，检查一下网络适配器里vpn的安全属性\n勾选为以下选项\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_3.jpg)\n\n\n\n\n\n\n\n"},{"header":" Javascript开发跨平台桌面app","time":" 2016-06-23 23:32:17","tags":" [javascript,node]","description":" develop cross-platform GUI app with electron","section":"electron原本是atom shell的项目，由于集成node丰富的本地系统级API，\n提供了与操作系统交互的功能，所以归结起来，现在javascrpit的技术栈之所以如此宽广，\n要得益于NodeJS将其中浏览器的环境中分离出来\n\n不过需要特别说明的是，这里生成的桌面应用，\n实际上是Electron生成的一个由Javascrpit控制管理的迷你浏览器Chromeinum，\n它其实是一个Chrome浏览器的试验版本，当然用的也是V8的内核\n<!--more-->\n不管怎么说，这对于喜欢前端，熟悉javascript的同学来说，\n能够用前端和一点后台的知识去接触，尝试各种不同的领域，实在是不要太爽\n\nElectron的入门也符合前端知识领域的特点，几乎没有门槛，\n只要你有一点JS和Node的基础就行了，开发目录的文件层次结构也很简单，\n后面会有打包工具帮助我们一键打包生成层次比较复杂的项目文件，\n作为桌面GUI应用，当然也包括.exe的启动文件，\n\n让我们看看如何开发一个桌面应用，或者说一个能和操作本地系统的web页面的基本方法~\n你可以跟着步骤完成一些基本的文件，也可以直接下载[快速开始的demo](https://github.com/shudery/electron/archive/master.zip)\n基本的文件层次很简单，用app存放一个具体的桌面应用，具体结构是这样的\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_1.png)\n\nOutApp用来存放打包输出的exe文件\n至于为什么有两个``package.json``文件，后面打包操作时你就知道了\n\n### 1、首先安装electron\n命令行进入根目录，先用npm安装electron，如果还没有就先[安装node](https://nodejs.org/en/)\n```\nnpm install -g electron-prebuilt\n```\n### 2、生成``package.json``配置文件\n运行``npm init`` 生成一个``package.json``文件来存放应用的相关配置，这个是第一个``package.json``文件，位于外层根目录下的，运行 \n```\nnpm install --save-dev electron-prebuilt  \n```\n会在devDependencies中生成依赖信息，方便后面打包\n```\n{\n  \"name\": \"firstGUI\",\n  \"version\": \"1.0.0\",\n  \"main\": \"app/main.js\",//js入口文件\n  \"scripts\": {\n    \"build\": \"electron-packager ./app firstApp --platform=win32 --arch=x64 --out ./OutApp --version 0.37.3 --overwrite --icon=./app/img/daguo. jpg\",\n    //打包命令，后面打包可以简化代码\n  },\n  \"devDependencies\": {\n    \"electron-prebuilt\": \"^1.2.0\"\n  }\n}\n```\n### 3、新建main.js\n生成一个入口的js文件来作为控制GUI窗口的主进程程序\n```\nconst electron = require('electron');\n// 控制应用生命周期的模块\nconst {app} = electron;\n// 创建本地浏览器窗口的模块\nconst {BrowserWindow} = electron;\n// 指向窗口对象的一个全局引用\nlet win;\n\nfunction createWindow() {\n\n // 创建一个新的浏览器窗口\n  win = new BrowserWindow({ width: 360, height: 572 });\n // 并且装载应用的index.html页面,注意路径\n  win.loadURL('file://'+__dirname+'/html/index.html');\n // 当窗口关闭时调用的方法\n\n  win.on('closed', () => {\n  // 解除窗口对象的引用，通常而言如果应用支持多个窗口的话，你会在一个数组里\n  // 存放窗口对象，在窗口关闭的时候应当删除相应的元素。\n  win = null;\n  });\n}\n\n// 当Electron完成初始化并且已经创建了浏览器窗口，则该方法将会被调用。\n// 有些API只能在该事件发生后才能被使用。\napp.on('ready', createWindow);\n\n// 当所有的窗口被关闭后退出应用\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\napp.on('activate', () => {\n  if (win === null) {\n    createWindow();\n  }\n});\n// 在这个文件后面你可以直接包含你应用特定的由主进程运行的代码。\n// 也可以把这些代码放在另一个文件中然后在这里导入。\n```\n### 4、index.html\nGUI窗口（web页面）渲染的Html文件\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>firstGUI</title>\n  </head>\n  <body>\n    <h1 style=>Hello World!</h1>\n  </body>\n</html>\n```\n\n### 5、运行桌面app\n大公告成，没错就是如此之快，运行``electron .``（跟一个空格和小点），或者``electron app/main``\n打开制作好的GUI界面，so cool~\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_2.png)\n\n### 6、进行打包\n既然是桌面应用，那肯定是要一键运行的，不需要安装什么依赖模块，\n也不需要运行命令行程序的，所以为了提升逼格，让更多的人可以方便实用你的桌面app，\n需要对app文件夹进行打包，安装打包程序 ``electron-packager``\n```\nnpm install --save-dev electron-packager\n```\n打包的基本命令是 \n```\nelectron-packager <location of project> <name of project> <platform> <architecture> <electron version><optional options>\n```\n上面已经在``package.json``的script里配置了简化的命令，可以根据自身情况对名称，操作系统，应用图标进行修改，\n注意啦开始打包前，一定要复制一份``package.json``到app文件，\n前面说了桌面应用不用下载依赖，其实是因为打包的时候就将依赖一同打包到文件包里了，\n所以我们要打包app文件夹下的文件，需要一个``package.json``  来说明依赖项，注意修改里面的路径，要往下一级，然后运行``npm packager``\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_3.png)\n\n完成打包后可以看到OutApp里头已经有了相应的文件，\n运行里面的exe文件会生成和本地测试时一样的GUI窗口~\n\n\n一个简单的基于前端技术栈的桌面app算是完成了，后续的asar文件加密，\n用nsis制作一个安装引导等等~有兴趣的可以继续完善~\n\n一个桌面级app当然不是用来显示``hello world``的，那样和web页面有什么区别，\n这里只是我入门的一个学习记录，一个基于electron的桌面应用\n还有着非常丰富的与系统交互功能可以设计和开发~\n更加详细的用法和配置有兴趣的同学不妨看看官方的[api演示文档](http://electron.atom.io/)，\n它也是一个基于electron做的桌面app\n\n"},{"header":" 最近的npm模块风波","time":" 2016-04-04 17:53:38","tags":" [npm,modules]","description":" npm导致我们不会写代码了？","section":"最近，前端圈子有件事闹得沸沸扬扬，有一个叫做`leftpad`的npm模块被作者撤下，\n导致一系列引用该模板的项目出现问题。\n\n其实本来大家对这件事的重点应该是关于NPM管理者对于模块作者著作权的保护不周上的，\n但是可能由于这个模块的特殊性和他造成的影响之间的对比太强烈，\n让大家都把注意力放到了这个模块本身和引用这个模块的做法上来了。\n<!--more-->\n**这个模块只有短短十一行，仅仅实现一个简单的字符串左侧填充的功能！**\n\n如此简单的模块为什么那么多项目都要引用他呢？\n其实如果不出现作者`unpublish`的问题，大家不会对这样的做法有太多的疑问，\n因为NodeJS的特色就是如此嘛，而且npm的引用和配置下载也非常方便， \n即使是再简单的模块，我若引用也就是`require`一下，然后将依赖写到json里，\n还是比自己写实现函数要方便一些，虽然方便得不多。\n总之就是不出事还好，一出事，那不好意思就得有人负责，\n这件事没有主要负责人，那么就得有问题被抛出。\n\n所以最近这几天抛出的最多的一个问题就是，**对于简单的代码我们仍要引用模块吗？**\n\n\n首先我觉得像这次又模块被作者下架，这毕竟是少数事件，\n我们不应该讨论对于npm的信任问题，这样会使我们在引用模块时畏手畏脚，\n有人说你简单的函数方法自己写嘛，复杂的再引用别人的，\n就是减少引用，就减少了出了事摊上你的概率，\n我只想说在小概率事件中减小该事件的概率--无关痛痒。\n\n\n总之我对npm模块的引用还是持比较乐观的态度，\nnpm的社区非常繁荣，拥有大批的贡献者，我觉得就是即使是再小的一个模块，\n你写出来了就可以`publish`上去，就可以给别人引用，每个人都有发光发热的机会，\n这给作者多大的鼓励和成就感啊，别人用后也会给你反馈，你再去不断改善，\n大家也可以在`review`其他模块代码中得到非常多的编程技术和思想。\n\n\n与对引用小模块的质疑相反，我觉得引用大模块的问题似乎更多，\n一个项目中引用的大模块往往并不需要里面的很多功能，\n所以NodeJS才在新版中将核心模块分割成多份，大家需要用啥再引用那个模块，\n这样就避免了项目庞大引起的各模块之间可能出现的兼容问题，\n也不至于使得代码太臃肿，至于对小模块引用可能导致require和模块依赖过大，\n但是代码依然比较精简，代码的冗余也比较少。\n\n\n最后，关于npm模块的引用，小模块如果有用过或已经知道的精巧模块，\n不仿大胆引用，若是不清楚也不必特意查询，简单的功能自己想方法实现即可，\n大模块如果与项目的配合不好，该分解的最好分解，结合项目和自身的编程习惯，\n高效的完成项目。\n以上仅仅是个人愚昧的一些看法。\n\n"},{"header":" 用hexo搭建一个博客","time":" 2016-05-05 12:00:33","tags":" [hexo,node,git]","description":" 如何用hexo来搭建一个博客","section":"hexo出自一位台湾大学生之手，是如今搭建，管理博客，发布文章的非常好用的工具，\n之前一直想搭建一个不依赖后台，便于管理和发布的博客，在朋友推荐下用了hexo\n确实是简单粗暴好用~\n基于hexo的博客搭建，对于已经配备了Node环境和git的前端开发人士，\n搭建出一个博客那就是分分钟的事情，即使还没有弄好这些也不难搭建，\n下面就从头大致说一说搭建的流程。\n<!--more-->\n### 创建一个github账号和博客\nhexo搭建的博客是一个静态页面，可以直接托放到github上面的服务器上，\n不需要拥有自己的服务器，所以我们要先有一个github账号，\n然后需要生成一个github的博客，之后我们用自己定制的hexo博客来替换它，\n如何搭建github技术博客可以看看这篇:[创建GitHub技术博客全攻略](http://blog.csdn.net/renfufei/article/details/37725057/)\n### 搭建Node环境\n我们还需要一个运行hexo和调试的环境，就是用Nodejs，\n在[官网地址](https://nodejs.org/en/)选一个稳定版或者开发版一键安装好环境。\n### 安装Hexo，生成文章\n准备好nodejs之后打开命令行使用Node的包管理工具npm,直接在命令行运行\n``\nnpm install -g hexo\n``\n\n下载hexo，然后再在相应的目录运行\n``\nhexo init\n``\n\n即可一键生成文件结构，你可以看到在source/_posts里面有一篇默认的helloworld.md文章，\n在themes里面有一个默认的主题landscape，再继续运行\n``\nhexo generate\n``\n\n### 调试，部署到git\n上面过程之后即可生成一个Public文件，里面会有你的文章内容，然后就可以运行\n``\nhexo server\n``\n\n启动localhost:4000，在浏览器输入地址就可以看到你的博客效果了，\n如果你对默认的配置都满意的话下一步就是运行\n``\nhexo deploy\n``\n\n将内容部署到github上面去了，但是我们好像还没有建立hexo和我们账号github仓库的链接，\n所以要在_config.yml最下面进行一些配置\n```\ndeploy:\n  type: git\n  repo: git@github.com:shudery/shudery.github.io.git # 换成你的博客仓库地址\n  branch: master\n```\n然后再hexo deploy即可完成部署，注意用ssh地址可以免去输入密码的繁琐，\n当然前提是要先生成ssh密钥，并且在你的github上面添加这个ssh密钥~\nhexo博客就已经搭建完成，可以在shudery.github.io上面看到博客页面和文章效果\n### 添加文章，更换主题，修改配置\n基本的东西就是这样，接下来我们可以在_posts里面以markdown的写作形式写文章，\n然后通过同样的方式生成，部署，可以直接在_posts里新建md文件，\n也可以用运行\n``\nhexo new [fileStyle] [fileName]\n``\n\n的方式来生成文件，后者会以scaffolds中对应的fileStyle的形式，\n给你生成一个fileName的md文件，里面会包括一些开头的默认字段，\n会方便记录一些文章的信息，我们还可以在[官网主题](https://hexo.io/themes/)里找一个更加符合心意的主题，\n然后直接git clone/ctrl+c 到我们hexo/themes下面，\n然后在hexo/_config.yml中的 theme:landscape 改为你下载好的主题名，\n然后你会发现主题文件夹里还有一个_config.yml 用来修改主题的一些相关配置，\n你可以参考你下载主题的github,或者官网的介绍来设置这些配置~\n### 完善博客\n最后你可以根据自己的喜好和需求为博客添加一些你喜欢的挂件和工具，\n我自己加了多说评论，百度统计，还有就是换了一个逼格高一点的域名，\n通过添加CNAME域名解析，重定向到github.io的博客地址上面。\n\n搭建过程中一些tips~\n\n* hexo clean会清理缓存和Public文件夹一般是在hexo generate之前使用，但是不用没啥问题\n* hexo/_config.yml对于hexo非常重要，但是如果去掉_config.yml你会发现还是依然能运行各种命令\n* 然而一般运行时报错都是config配置有问题，而且很不好定位，\n  所以可以注释掉config.yml里面你觉得应该不会导致报错的配置，然后再运行看结果，\n  重复几次就可以定位到问题了，这对一开始没有什么经验的人来说是一个可行的debug方法。\n* 在做域名重定向的时候，域名解析的CNAME需要指向github.io，\n  此外还要在hexo/source下面也建立一个CNAME文件指向你的设置了重定向的域名地址才行"},{"header":" ES5和ES6中对于继承的实现方法","time":" 2016-07-23 23:32:17","tags":" [javascript]","description":" develop cross-platform GUI app with electron","section":"\n在ES5继承的实现非常有趣的，由于没有传统面向对象类的概念，Javascript利用原型链的特性来实现继承，这其中有很多的属性指向和需要注意的地方。\n原型链的特点和实现已经在之前的一篇整理说过了，就是通过将子类构造函数的原型作为父类构造函数的实例，这样就连通了子类-子类原型-父类，原型链的特点就是逐层查找，从子类开始一直往上直到所有对象的原型Object.prototype，找到属性方法之后就会停止查找，所以下层的属性方法会覆盖上层。\n<!--more-->\n一个基本的基于原型链的继承过程大概是这样的：\n```\n//先来个父类，带些属性\nfunction Super(){\n    this.flag = true;\n}\n//为了提高复用性，方法绑定在父类原型属性上\nSuper.prototype.getFlag = function(){\n    return this.flag;\n}\n//来个子类\nfunction Sub(){\n    this.subFlag = false;\n}\n//实现继承\nSub.prototype = new Super;\n//给子类添加子类特有的方法，注意顺序要在继承之后\nSub.prototype.getSubFlag = function(){\n    return this.subFlag;\n}\n//构造实例\nvar es5 = new Sub;\n```\n原型链实现的继承主要有几个问题：\n1、本来我们为了构造函数属性的封装私有性，方法的复用性，提倡将属性声明在构造函数内，而将方法绑定在原型对象上，但是现在子类的原型是父类的一个实例，自然父类的属性就变成子类原型的属性了；\n这就会带来一个问题，我们知道构造函数的原型属性在所有构造的实例中是共享的，所以原型中属性的改变会反应到所有的实例上，这就违背了我们想要属性私有化的初衷；\n2、创建子类的实例时，不能向父类的构造函数传递参数\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n   this.subFlag = false;\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nobj.flag = flase;  //修改之后，由于是原型上的属性，之后创建的所有实例都会受到影响\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //false；\n```\n为了解决以上两个问题，有一个叫借用构造函数的方法\n只需要在子类构造函数内部使用apply或者call来调用父类的函数即可在实现属性继承的同时，又能传递参数，又能让实例不互相影响\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n    Super.call(this)  //如果父类可以需要接收参数，这里也可以直接传递\n}\nvar obj = new Sub();\nobj.flag = flase;\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //依然是true，不会相互影响\n```\n结合借用构造函数和原型链的方法，可以实现比较完美的继承方法，可以称为组合继承：\n```\nfunction Super(){\n    this.flag = true;\n}\nSuper.prototype.getFlag = function(){\n    return this.flag;     //继承方法\n}\nfunction Sub(){\n    this.subFlag = flase\n    Super.call(this)    //继承属性\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nSuper.prototype.getSubFlag = function(){\n    return this.flag;\n}\n```\n这里还有个小问题，Sub.prototype = new Super;  会导致Sub.prototype的constructor指向Super;\n然而constructor的定义是要指向原型属性对应的构造函数的，Sub.prototype是Sub构造函数的原型，所以应该添加一句纠正：\nSub.prototype.constructor = Sub;\n\n看完ES5的实现，再来看看ES6的继承实现方法，其内部其实也是ES5组合继承的方式，通过call借用构造函数，在A类构造函数中调用相关属性，再用原型链的连接实现方法的继承\n```\nclass B extends A {\n  constructor() {\n    return A.call(this);  //继承属性\n  }\n}\nA.prototype = new B;  //继承方法  \n```\nES6封装了class，extends关键字来实现继承，内部的实现原理其实依然是基于上面所讲的原型链，不过进过一层封装后，Javascript的继承得以更加简洁优雅地实现\n```\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 等同于parent.constructor(x, y)\n    this.color = color;\n  }\n  toString() {\n    return this.color + ' ' + super.toString(); // 等同于parent.toString()\n  }\n}\n```\n通过constructor来定义构造函数，用super调用父类的属性方法\n\nES6中Class充当了ES5中，构造函数在继承实现过程中的作用\n同样有原型属性prototype，以及在ES5中用来指向构造函数原型的`__proto__`属性，这个属性在ES6中的指向有一些主动的修改。\n一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法继承。\n```\nclass A extends B {}\nA.__proto__ === B;  //继承属性\nA.prototype.__proto__ === B.prototype;  //继承方法\n```\nES6的子类的`__proto__`是父类，子类的原型的`__proto__`是父类的原型\n第二条继承链理解起来没有什么问题，对应到ES5中的A.prototype = new B;A.prototype作为B构造的实例，指向构造函数B的原型B.prototype，\n但是在ES5中A.`__proto__`是指向Function.prototype的，因为每一个构造函数其实都是Function这个对象构造的，ES6中子类的`__proto__`指向父类可以实现属性的继承，在ES5中在没有用借用继承的时候由于父类属性被子类原型继承，所有的子类实例实际上都是同一个属性引用。\n在ES6中实现了子类继承父类属性，在构造实例的时候会直接拿到子类的属性，不需要查找到原型属性上面去，ES6新的静态方法和静态属性（只能在构造函数上访问）也是通过这样类的直接继承来实现，至于普通复用方法还是放到原型链上，道理和实现和ES5是一样的。\n此外我认为这里修改A.`__proto__`的指向是有意区分ES6中继承和实例化，同时建立子类和父类直接的关系，ES5的子类的构造函数通过子类的原型与父类的构造函数连接，不存在直接的关系；\n可以这么说，在ES5继承和构造实例，ES6构造实例的时候可以理解`__proto__`原型指针是用来指向构造函数的原型的，但是在ES6继承中，`__proto__`指继承自哪个类或原型，在A继承B之后，构造一个实例 var obj = new A; 会发现它所有的属性指向都是和ES5一致的。\n\n\n有个有趣的地方：ES6继承是在父类创建this对象，在子类constructor中来修饰父类的this，ES5是在子类创建this，将父类的属性方法绑定到子类，由于原生的构造函数（Function，Array等）没有this，子类无法通过call/apply(this)获得其内部属性，所以在ES5无法继承，ES6实现后可以为原生构造函数封装一些有趣的接口，比方说阮一峰老师的这个给Array实例封装一个版本记录和回滚的方法：\n```\nclass VersionedArray extends Array {\n  constructor() {\n    super();\n    this.history = [[]];\n  }\n  commit() {\n    this.history.push(this.slice());\n  }\n  revert() {\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  }\n}\n\nvar x = new VersionedArray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\nx.push(3);\nx // [1, 2, 3]\n\nx.revert();\nx // [1, 2]\n```\n最后做一个ES5和ES6的继承小结：\nES5最经典的继承方法是用组合继承的方式，原型链继承方法，借用函数继承属性，ES6也是基于这样的方式，但是封装了更优雅简洁的api，让Javascript越来越强大，修改了一些属性指向，规范了继承的操作，区分开了继承实现和实例构造，此外ES6继承还能实现更多的继承需求和场景。\n\n\n\n\n\n\n"},{"header":" HTTP缓存及众多的web储存概念之小整理","time":" 2016-08-12 01:46:57","tags":" [javascript,html]","description":" this is a article for my way of studying front-end","section":"\n缓存对于一个网站来说非常重要，可以提高网站性能，减少冗余的数据传输，增加服务器负担，web存储则给浏览器提供了更加强大的保存文件的接口。\n有相当一段时间一直混淆了HTTP缓存相关的属性，HTML5离线存储和本地储存的一些关系，最近好好地整理了一下这些Web存储相关的东西\n\n先列出一些相关属性和概念，看看能否理清它们之间的区别和联系？\n<!--more-->\n\n* manifest\n* cache-control\n* expires\n* 304(no modified)\n* ETag\n* If-None-Match\n* Last-Modified\n* If-Modified-Since\n* http-equiv\n* webstorage\n* cookie/session\n\n是不是感觉有点凌乱，那就跟着我整理的笔记走一遍吧：）\n首先说一说HTTP缓存相关的东西:\n　　\n　　\n`Cache-Control`\n每一个用HTTP请求的资源都可以在响应头用Cache-Control来给浏览器定义缓存策略，通过设置一些属性值它可以控制谁可以，在什么条件下可以缓存响应，还有缓存的有效期，这个属性的一些常用值如下\n\n`no-cache：`表示不使用缓存，先和服务器确认要返回的资源是否有修改\n`no-store：`表示禁止浏览器和所有中继缓存响应的资源\n`max-age=100：`表示缓存的有效期，单位是秒，这一段时间内，除非缓存文件发生一些变动，否则会直接使用之前的缓存，注意这段时间内是不会发Etag等方法去验证的资源有没有修改的。缓存的文件发生变动，主要有这些情况：资源名更改，资源地址更改，缓存被删除，网页强制刷新等；资源名更改，给文件名添加版本hash值，比如给image.png修改为image-hash.png，可以保证每次更新文件时用户可以重新发出请求，获取最新的资源。资源路径更改，修改文件的请求路径，比如给image.png添加查询参数修改为image.png?hash，max-age的时间设置根据每个网站的实际情况不同去设置，一种极端的做法是把这个值设置很大，然后通过修改资源名或者给资源请求地址添加查询参数，来告诉浏览器该更新资源了，一般用在很久才更新网站的情况\n`public：`用max-age即是默认public了，不用设置\n`private：`私人缓存，中继缓存不被允许，但是可以在浏览器缓存\n\n`PS：expires：`表示存在的时间，使客户端在这个设置的时间之前不用去请求资源，类似于max-age，但是expires表示的是一个固定时间，而且可能有服务器和客户端时间不一致的问题，主要用于HTTP1.0版本，在HTTP1.1版本完全可以用功能更强的Cache-Control来替代，和max-age同时存在时expiers会被覆盖掉\n`PS：http-equiv：`缓存有两种控制机制，一种是请求头信息控制，另外一种就是利用meta标签；可以在HTML文档中为meta标签设置http-equiv为相应属性名，content为值来设置缓存，例如\n`<meta http-equiv=\"Expires\" content=\"Mon, 20 Jul 2009 23:00:00 GMT\" />`，不过只对改网页的HTML文件有缓存作用，对该页面的其他资源以及其他页面的HTML文件都没有作用\n　　\n　　\n那么max-age（expires）到期之后，在no-cache下的资源会先和服务器确认返回的资源是否有修改，如何实现这一过程？\n`ETag/If-None-Match，Last-Modified/If-Modified-Since`\nETag (Entity Tag)其实就是一个验证令牌，用来标识一个资源，可能是一个hash值，也可能是一个版本号，每当资源有修改的时候ETag的值就会改变\n浏览器第一次请求之后会保存响应头的ETag值，以便下一次发送请求的时候校验Etag是否有更改。\n　　\n　　\n那么下一次浏览器如何告诉服务器本地已经存有Etag和相应的资源了呢？If-None-Match\n通过在请求头添加If-None-Match(如果存在ETag，浏览器会自动添加)，赋值为上一次请求后在本地存储的Etag值，服务器会和服务端最新资源的Etag比对，如果没有更改会直接返回304 no modified给浏览器，浏览器就直接使用本地缓存的文件\n\n`PS：Last-Modified/If-Modified-Since`的作用等同于`ETag/If-None-Match，`不过前者是通过规定一个时间来比对，最小的单位是秒，后者通过一个唯一标识符，所以可以看出来如果原站在一秒内有多次更新，那么前者就不顶用啦。\nETag的验证要优先于Last-Modified，此外ETag也是有缺点的，在分布式的环境中，Etag在不同服务器上的同步问题可能会给服务器带来一些压力。\n　　\n　　\n`HTTP缓存`是和每一个HTTP请求直接相关的，每一个请求资源的响应都有相应的缓存策略，它们往往是相似的，是否可以通过其他的机制，直接告诉浏览器去缓存哪一些文件呢？\n`HTML5离线存储`闪亮出场\n\nH5离线存储：服务器通过一份.manifest文件给浏览器提供一份完备的缓存名单，名单包括需要缓存的文件，不需要缓存的文件的列表之外，还有一些其他的功能，比如给资源设置备选的请求地址，设置404页面等\n\n实现：利用H5的标签新属性manifest，只需要在HTML文件添加`<html manifest=\"test.manifest\">，`服务器则将manifest文件的mime-type设置为text/cache-manifest类型即可，浏览器每次请求会检查`manifest`是否有更新，服务端通过修改manifest文件，即可在浏览器下一次请求资源的时候通知其更新相应的资源。\n作用：通过本地离线存储可以在没有网络的情况下访问网站事先保存的文件资源，在有网络的情况下直接使用本地资源也可以减少请求连接的压力，提高网页的加载速度，注意这里和HTTP缓存的区别，它是直接使用本地资源，请求返回的是200（from cache）,由于有manifest来统一管理，所以不需要发请求查看是否有更新，也没有过期时间。\n　\n`PS：`这里关于manifest文件自身的更新问题，还是要走HTTP缓存，或者直接不缓存这个文件。\n　　\n　　\n前面提到的概念主要都是缓存请求文件这一块的东西，它们的目的都是为了提高网页的性能，可以说是一种优化型的存储，可以给用户带来更流畅的体验\n但是我们印象中还有一种存储，它可以给我们提供更多的可能和效果的实现，是功能型的存储，如H5本地储存`Webstorage，cookie，session`\n　　\n　　\n`cookie，session`\n众所周知，HTTP是无状态的协议，每一次请求都是独立没有联系的，浏览器和服务器都没有办法维持用户的状态，判断用户是不是依然是之前的那个用户。\n很容易可以想到，在同一个用户的每个请求头添加一个唯一标识符，通过判断这个标识符就可以维持用户的一些信息和状态\n会话信息被用来作为标识符解决这个问题，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案（服务端保持状态也需要客户端保持状态，所以一般session都要基础cookie或者sessionstorage）\n\n总的来说：cookie数据放在客户端，session数据放在服务端，cookie可以设置期限，session则是关闭浏览器时销毁（cookie默认也是），cookie不安全，session可能会影响服务器性能\n\n`Cookie：`通常用Javascript封装一个setCookie的函数来创建，有大小限制，可能会导致请求头过于臃肿，浏览器发送请求时，检查本地cookie，如果该cookie声明的范围大于发送请求的url地址时，就会自动在请求上添加cookie字段\n\n`session：`服务器每次会检查浏览器请求头的session标识，如果有则将这个session id在服务器的数据库（散列表）查找，找到后才进行相应权限的操作\n如果没有这个请求标识，则为客户端新建一个，返回给客户端后，客户端可以通过cookie或者sessionstorage来保存这个session id，通过请求头的cookie字段来给服务器提供sessionId，当cookie被禁止时就需要一些其他方法，通常是采用添加到url路径中，添加表单隐藏域等方法\n\ncookie作为HTTP协议规范的一部分，主要还是用来储存用户信息的，用来和服务端交互，大小也有限制，仅仅只是一种会话级别的存储\n　　\n　　\n`localstorage，sessionstorage`\n`webstorage`为了更大的存储文件设计，与Cookie负责记录用户信息相比，webStorage专注于本地存储，通过封装好的setItem，getItem等方法即可使用\nlocalstorage是一种持久化的存储，除非主动删除，否则永远存在，sessionstorage主要用来存储会话（session），关闭浏览器就会销毁，是一种非持久化的存储\n　　\n　　\n除了上面这些的概念之外，还有诸如像IndexDB，FileSystem等存储方法，关于Web存储的知识真的非常多，看上去坑也是不少，还需要实践慢慢来掌握。\n\n\n\n\n\n\n\n\n\n"},{"header":" JavaScript关键概念理解之闭包","time":" 2016-07-10 21:59:48","tags":" [javascript]","description":" none","section":"\nJavaScript作为一种多范式编程语言，和许多函数式编程语言一样拥有闭包的概念。\n闭包是一个老生常谈的问题，前端面试必问，要理解闭包的原理，必须知道什么是词法作用域，理解词法作用域，又需要对Javascript另外两个关键概念的掌握和理解~\n\n<!--more-->\n\n#### 执行环境和作用域链\n执行环境：红宝书将执行环境称为Javascript这么编程语言最为重要的一个概念，一开始我是不服的，屌屌的闭包和原型链呢？后来一番整理，才发现原来闭包和原型链的实现都是依赖于执行环境。\n执行环境定义了变量或者函数有权访问的数据，决定了它们各自的行为，每个执行环境拥有一个变量对象来保存环境中定义的所有变量和函数。\n每个函数都有自己的执行环境，每次执行语句进入函数后，就会将相应函数的执行函数压入环境栈中，执行完函数之后就会弹出，将控制权交给原来的执行环境。\n\n作用域链：作用域链用来保证执行环境中，对所有环境有权访问的变量或者函数的有序访问。每一个执行环境会为自身的变量对象创建一个作用域链，作用域的前端始终是当前执行环境的变量对象，会一直向外延伸到全局作用环境，执行环境查询变量和函数的顺序遵循从局部到全局，一旦找到就会停止查找。\n\n执行环境和作用域是很多概念和一些实现方法的基础，在Javascript里，执行环境决定了访问的权限，作用域链决定了访问的顺序。\n\n#### 闭包和词法作用域\n闭包：闭包就是一个作用域内定义的一个函数，由于Javascript没有块级作用域，局部作用域的形成依赖于函数来实现，所以也可以说闭包是一个函数里定义的一个函数。由于闭包的一个作用就是用来访问其他函数作用域中的变量，所以它又有一种定义：闭包指有权访问另一个函数作用域中变量的一个函数。\n先看一段代码\n```\nname = 'hi';\nfunction close(){\n    name = 'hello';\n    return function sayName(){\n        console.log(name)\n    }\n}\nvar sayName = close();\nsayName();\n```\n词法作用域：在这段代码中console出来的是hello，也就是说sayName执行过程中的name值取得是close函数内部的Name，而不是外部全局环境的name；根据上面对执行环境的理解，当进入sayName这个函数之后，执行环境就由全局进入局部环境，注意到每次定义函数的同时就会生成该函数的执行环境，所以sayName是在哪里声明的，它的外部执行环境就是谁，在这里就是close这个函数的执行环境，再根据上面对作用域链的理解，sayName对于name变量的查询将到此为止，不会到全局去，所以name的值就是hello，而不是hi，简单的说，sayName这个函数所属的作用域是声明它的时候所在的作用域，而不是运行它的时候，高端地说，这就是Javascript的词法作用域。\n\n依照作用域链的原理，本来全局执行环境是没有办法访问到局部执行环境的，但是由于词法作用域的原因，使得sayName这个闭包（全局环境）拥有了访问close内部name变量（局部环境）的能力。\n\n#### 闭包和this关键字\n闭包经常会和this关键字配合使用，每个函数在被调用的时候都会自动获得两个特殊变量，一个是arguments，另一个就是this，所以在一些多层嵌套return的闭包中，无法同过this来正确获得外层的this，因为作用域链在最里层的函数找到this后就停止了，所以一般都需要用一个中间变量来存储或者用bind方法绑定外层的this指向\n```\nvar name = 'hi';\nvar obj = {\n    name:'hello';\n    getName:function(){\n        //var that = this;\n        return function(){\n            return this.name;\n        }\n    }\n}\n```\n关于this的指向问题，只需要认准this当前所在函数的调用方式即可，当函数作为一个对象的方法调用时，this指向为这个对象，当作为一个函数调用时，this在非严格模式下指向全局，严格模式下返回undefined\n\n闭包的作用：\n特权方法：通过上面的闭包的概念理解，已经可以知道闭包的一个作用就是作为一个公有方法用来访问私有变量的，有权访问私有变量和函数的公有方法也叫做特权方法；Javascript中虽然没有传统面向对象中的类，也没有私有成员的概念，不过对于一个函数而言，其函数参数，内部声明的变量或者函数就是私有的。\n```\nfunction Person(){\n    var name = 'daguo';\n    var getAge  = function(){\n        return console.log('22');\n    }\n    this.publicMethod = function(){\n        console.log(name)\n        return getAge()\n    }\n}\n```\n保留变量：通常函数的作用域和其所有变量会在函数执行结束之后就销毁，但是当这个函数返回一个闭包时，只要闭包还存在，那么声明闭包的这个作用域内的变量就不会被销毁，原因就是闭包依然保有对这些变量的引用，使它们不会被JS垃圾回收标记清除。这是一个可以利用的地方，也可能是一个造成内存泄漏的原因。所以不能过多创建闭包\n\n\n\n\n\n\n\n\n\n"},{"header":" chrome扩展程序入门手记","time":" 2016-06-14 23:08:15","tags":" [javascript,chrome]","description":" share my record after learning how to build a plugin for chrome.","section":"chrome是我非常喜欢的浏览器，它除了速度飞快，对前端代码支持友好的优点外，\n还有非常丰富的扩展程序资源，提供了大量方便强大的web页面应用插件\n这两天由于朋友的业务需求，接触了一些chrome扩展程序(即俗称插件)的有关代码\n基于对谷歌开发者文档的学习，随手记录了写chrome插件的基本方法~\n<!--more-->\n每一个基本的Chrome插件,首先都有一个manifest.json\n的配置文件用来存储插件的基本信息 \n\n``\n\"manifest_version\": 2,\n  \"name\": \"Getting started example\",\n  \"description\": \"This extension shows a Google Image search result for the current page\",\n  \"version\": \"1.0\"\n``\n\n包括manifest的版本，扩展插件的名字，描述，版本\n\n弹窗页面的信息browser_action, 在里面配置一个插件弹窗html页面代码，一般名字是popup.html，\n浏览器界面显示的扩展图标位置，以及鼠标hover的title\n\n``\n\"browser_action\": {\n    \"default_icon\": \"images/icon.png\",\n    \"default_popup\": \"popup.html\",\n    \"default_title\": \"Click here!\"\n  }\n``\n\n可选的页面注入代码，一般名字是contentscript.js，\n可选多个文件，匹配页面的matches，只对匹配到的注入代码\n\n``\n\"content_scripts\": [{\n    \"js\": [\"jquery.min.js\", \"contentscript.js\"],\n    \"matches\": [\"http://*/*\",\"https://*/*\"]\n  }]\n``\n\n还有插件要求的权限和要使用该插件的网页的匹配\n\n``\n\"permissions\": [\n    \"tabs\",\n    \"http://*/\"\n  ]\n``\n\n关于manifest的更多字段配置信息，可以查看360翻译谷歌的[开发者文档](http://open.chrome.360.cn/extension_dev/manifest.html)\n\n从上面的配置可以看到，一个简单插件除了有manifest之外\n还有一个browser_action, 即popup.html来渲染点击插件之后的弹窗页面，\n这个页面可以分离出来popup.js popup.css等文件，\n这些文件可以放在同一个根目录下，文件中的引用跟普通项目一致可以取相对路径\n\n\n如果要实现与浏览器打开页面的交互就必须还有一个注入脚本文件，\n一般取名contentscript.js，弹窗页面popup page通过相应api实现和注入脚本的交互\n再由注入脚本实现对web page的交互\n在popup page（popup.js）中的输入代码\n\n```\nchrome.tabs.query({\n      active: true\n    }, function(tab) {\n       var data = '';\n        //要传递给注入脚本文件的信息\n      chrome.tabs.sendMessage(tab[0].id, 'hello, content script, from background page. there are some data:' + data);\n});\n```\n\n第二个参数为发送的信息，在注入脚本中通过request参数拿到\n在contentscript.js中输入以下代码，开启对popup.js的信息发送监听，拿到信息request\n\n```\nchrome.extension.onMessage.addListener(function(request) {\n  //request是popup page传来的信息\n   console.log('get the message from popup.js'+request)\n   //收到popup page的信息后要做的事情\n});\n```\n\n注入脚本contentscript.js和浏览器打开的网页脚本web page运行在不同的环境之下，\n所以他们的变量名和全局对象不会有冲突，\n但是他们共享一个DOM树，也就是可以通过修改注入脚本的DOM结构来改变页面的DOM，\n这也就是注入脚本同web page交互的方式\n\n最后贴一个我练手写的一个[chrome插件](https://github.com/shudery/daguoNote)，\n实现简单的便签功能，界面用amazeUI做的，\n用React渲染，后台处理用Express搭建，数据结果直接保存一份JSON文件来管理\n"},{"header":" javascript的对象构造和原型链继承","time":" 2016-04-14 17:55:58","tags":" [javascript]","description":" javascript的对象构造和原型链继承","section":"这两天仔细地学习了JS的创建对象以及继承的方法，结合红宝石书整理了下笔记。\n（红宝石这里讲了非常多的模式，看第一遍觉得还蛮乱的）\nJavascript作为一种动态的面向对象语言，本身却没有类的概念和方法，\n在创建对象和继承方面有很多有趣的实现和方法\n<!--more-->\n## 1.原始绑定和字面量表示：\n**优点**：简洁方便\n**问题**：使用对象字面量的方法创建的对象，若重复创建会产生大量的重复代码\n```\nvar o = new Object();\no.name = 'shudery';\no.skill = function(){console.log('sayHello')};\n//这是比较老的方法，一般用下面这种简单粗暴的，直接字面量创建\n\nvar obj = {\n    sex = 'man',\n    skill = function(){console.log('tucao')} \n    ...\n}\n```\n## 2.工厂模式：\n抽象创建具体对象的过程\n**具体**：用函数来封装对象，然后调用特定接口创建对象\n**优点和问题**：解决代码重复性的问题，但是没有解决对象识别问题\n```\nfunction createObj(name){\n    var obj= {\n        name : name ,\n        skill : function(){console.log('tucao')}\n    };\n    return obj;\n}\nvar obj_1 = createObj('shudery');\nvar obj_2 = createObj('Lin'); \n//Object类型的对象\n```\n## 3.构造函数模式：\n使用`new`操作符，没有显式创建对象\n**优点**：解决了代码识别问题，可以将它构造的实例标示为特定类型\n**问题**：多次复用的方法需要在每个实例上重新创建一遍，浪费内存\n```\nfunction Myobj(name){\n        this.name = name,\n        this.skill= function(){console.log('tucao')}   \n}\nvar obj_1 =  new Myobj('shudery');\nvar obj_2 =  new Myobj('Lin');\n//对象类型名称为myObj，解决了识别的问题，用下面方法可以验证\nconsole.log(obj_1.constructor === Myobj && obj_2 instanceof Myobj);//true\n```\n这里如果怕遗漏new关键字，可以在`myObj`函数里头显示地返回一个对象，如下：\n```\nfunction Myobj(name){\n        var obj={};\n        obj.name=name,\n        obj.method= function(){\n        console.log('tucao')\n         }\n    return obj;\n}\nvar obj_1 = Myobj('shudery');\nvar obj_2 = new Myobj('shudery');\n```\n如果这么做`obj_1`的`constructor`指向的是`Object`\n这样就和工程模式一样不能识别对象，\n但是功能上两个对象相同，这也被叫寄生构造函数模式，一般不用它\n此外在构造函数模式下如果没有引用this和new，那就是稳妥构造函数模式，\n一般用在安全的环境\n\n## 4.原型模式：\n在构造函数模式下如果直接提取出方法函数到全局环境下，\n在方法变多时容易污染命名空间，\n此外不利于我们自定义的引用类型的封装。\n我们可以用JS的一大特色原型属性来挂载属性方法。\n**优点**：我们可以将复用的方法绑定到每一个构造函数定义的原型属性prototype上来，这样所有的对象实例都可以共享这个挂在这个原型下的属性和方法。\n**问题**：实例失去本身的特点和封装，公用一套属性和方法\n```\nfunction Myobj(){\n       \n}\nMyobj.prototype.name ='shudery';\nMyobj.prototype.age = '22';\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj();\n```\n也可用对象字面量形式，不过要注意顺序，字面量的形式相当于重写整个对象，\n构造函数原型的`constructor`属性（指向对象类型）会被重写为`Object`,\n而不是`Myobj`了\n```\nfunction Myobj(){\n       \n}\nvar obj =  new Myobj();//先实例化\nMyobj.prototype={\n//重写后这个原型和Myobj这个构造函数就没有关系了\n    name: 'shudery',\n    age:'22',\n    method : function(){\n    console.log('tucao')\n    }\n};\nobj.name;//undefined，联系被切断了\n```\n如果在重写之后实例化一个对象，虽然还存在联系，\n但是`obj`实例就不是`Myobj`类型了\n不在乎对象识别问题的话，也可以直接这样重写，仍能调用obj.name等属性和方法\n\n## 5.终极模式：构造函数+原型模式\n 最为常用的创建对象的方式，结合两种模式的优点，\n 实现对象属性的封装和对象方法的复用，\n平衡了对象的独立性和多态复用节省内存的问题。\n```\nfunction Myobj(name,age){\n    this.name =name;\n    this.age = age\n}\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj('shudery',22);\n```\n如此一来对象就拥有自定义的属性和可共享复用的方法啦\n有句话这样说，当我们把程序中变化的部分封装好之后，剩下的就是稳定可复用的了\n这也是很多种设计模式里推崇的，放到创建对象的方法里也是一样的做法。\n\n说完对象的创建，接下来是继承~\nJS是没有类的关键字和概念的，它的继承是基于原型链的，类似上面的原型模式\n我们先简单了解下原型链：\n\n![](https://raw.githubusercontent.com/shudery/public/master/clipboard.png)\n\n每个构造函数都有一个原型对象，构造的实例有一个指向原型对象的指针，\n如果我们把父类的实例赋值给原型对象，那么子类的原型对象就是父类的实例， \n那么这个实例还是有一个指向父类原型的指针，\n这些指针连起了子类和父类的实例（子类构造函数的原型），就是原型链。\n\n对象的方法和属性会循着原型链进行访问，直到查找到相应的属性和方法名，\n或者到达原型链的终点`Object.prototype`,这也就实现了继承\n\n\n\n\n\n\n\n\n\n\n"},{"header":" 搭建属于自己的vpn服务器","time":" 2016-06-10 21:59:48","tags":" [vpn]","description":" how to build vpn or vps by youself","section":"之前实习的时候想着有需要翻墙的时候用着公司的vpn就足够了\n但是随着马上要去工作，还有对一些国外资源的需求（资源你懂的）\n然后也前后被一些网上的vpn服务商坑过（各种掉线，不稳定）\n决定自己租用一台国外的服务器vps\n<!--more-->\n了解一番后知道了国外[搬瓦工](http://bandwagonhost.com/)和[digital ocean](www.digitalocean.com/?refcode=3491087221da)都有不错的口碑，最终选择DO,\n最便宜的512MB内存，20GB固态硬盘，1TB流量，\n\n这个好像只是防止恶意使用的，实际上流量是用不完的，\n在服务器控制版面也没有流量使用情况提示\n首先注册账号，输入邮箱密码，在邮箱收到确认邮件，\n来到Payment Methods \n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_1.png)\n\n这一项我选择的是方便快捷的PayPal，Credit不好设置\n需要预充5刀PayPal，5刀也是最便宜的服务器的月租价格，\n如果没有PayPal的话就先注册一次，比这个Credit方便多了\n注意一些老旧的银联卡号可能提示设置错误，我换了一张卡就好了\n\n然后开始选择服务器，包括价格，地点，系统，\n我选了最便宜已经够用了的5刀/月，ping后较快的美国西部服务器，\n以及比较容易操作的ubuntu系统，然后添加主机的SSH密钥，以后方便，\n\n不过也可以先跳过以后再说，买后会收到邮件，\n得到一个服务器主机Ip，root账户名，以及一个初始密码。\nvps算是有了，接下来我们在这台服务器上搭建vpn\n\n然后不得吐槽的是网页的console控制台实在有点卡卡，\n所以我用简单的putty来建立与vps的链接，也可以使用xshell等工具，\n下载putty后直接输入ip地址，保留默认端口，点击open就进入控制台了\n\n然后输入你的用户名root，然后出现password输入密码，\n这里注意啦~输入密码的时候，光标是不会动的！\n所以，慢慢输入，不要输错了，登录成功后显示一些信息\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_2.png)\n\n第一次登陆要求重置密码，分别填一次旧密码和两次新密码，注意光标还是不会移动！\n然后开始一列Linux操作，作为小白的我们就只管输入代码即可，\n不过我们也是有(yao)追(zhuan)求(bi)的小白，所以也要大概知道这些代码是个什么作用\n\n### 1、安装vpn服务\n首先我们必须在vps服务器上安装一种vpn服务，这里选择点对点隧道协议pptp,输入\n\n```\napt-get install pptpd\n```\n\n### 2、配置文件修改\n用vi编辑器打开配置文件，输入\n\n```\nvi /etc/pptpd.conf\n```\n\n没用过vi的注意啦，要编辑文件必须先输入i，进入INSERT模式，\n将光标移动到最下面更改\n\n```\nlocalip 10.0.0.1\nremoteip 10.0.0.100-200\n```\n\n有两段，localip更改为你vps服务器的ip地址，remoteip是以后分配给\n其他连到你vpn的服务器的ip，可以照着例子分配，写完后保存，\nvi的文件保存方法是先按Esc然后输入冒号:wq即可，w是写入保存，q是退出vi\n\n### 3、添加vpn账号\n用vi打开密钥文件，输入\n\n``` \nvi /etc/ppp/chap-secrets \n```\n\n依次输入 username pptpd password ### \n将username, password更换为你的vpn账号和密码，中间是服务名，\n最后一个是ip通配符，如果要建立多个vpn账号给妹子基友一起用，\n还一行依次输入即可，输完同样保存\n\n### 4、设置公共DNS服务，输入\n\n```\nvi /etc/ppp/pptpd-options\n```\n\n打开服务选项文件设置找到ms-dns并设置为\n`\nms-dns 8.8.8.8\nms-dns 8.8.4.4\n`\n\n### 5、重启pptp服务，\n重启服务，刷新配置，输入\n\n```\nservice pptpd restart\n```\n\n### 6、ip转发配置\n打开转发配置文件，输入\n\n```\nvi /etc/sysctl.conf\n```\n\n发现整个文件都带有注释符#,去掉`# net.ipv4.ip_forward = 1`\n前面的注释符#保存,为了使配置生效还需运行\n\n```\nsysctl -p\n```\n\n### 7、设置iptables\n设置并保存，运行\n\n```\niptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE && iptables-save\n```\n\n至此搭建好属于你自己的vpn，拿着账号在手机和电脑的vpn设置登录即可\n注意如果出现vpn隧道协议构建失败，检查一下网络适配器里vpn的安全属性\n勾选为以下选项\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_3.jpg)\n\n\n\n\n\n\n\n"},{"header":" Javascript开发跨平台桌面app","time":" 2016-06-23 23:32:17","tags":" [javascript,node]","description":" develop cross-platform GUI app with electron","section":"electron原本是atom shell的项目，由于集成node丰富的本地系统级API，\n提供了与操作系统交互的功能，所以归结起来，现在javascrpit的技术栈之所以如此宽广，\n要得益于NodeJS将其中浏览器的环境中分离出来\n\n不过需要特别说明的是，这里生成的桌面应用，\n实际上是Electron生成的一个由Javascrpit控制管理的迷你浏览器Chromeinum，\n它其实是一个Chrome浏览器的试验版本，当然用的也是V8的内核\n<!--more-->\n不管怎么说，这对于喜欢前端，熟悉javascript的同学来说，\n能够用前端和一点后台的知识去接触，尝试各种不同的领域，实在是不要太爽\n\nElectron的入门也符合前端知识领域的特点，几乎没有门槛，\n只要你有一点JS和Node的基础就行了，开发目录的文件层次结构也很简单，\n后面会有打包工具帮助我们一键打包生成层次比较复杂的项目文件，\n作为桌面GUI应用，当然也包括.exe的启动文件，\n\n让我们看看如何开发一个桌面应用，或者说一个能和操作本地系统的web页面的基本方法~\n你可以跟着步骤完成一些基本的文件，也可以直接下载[快速开始的demo](https://github.com/shudery/electron/archive/master.zip)\n基本的文件层次很简单，用app存放一个具体的桌面应用，具体结构是这样的\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_1.png)\n\nOutApp用来存放打包输出的exe文件\n至于为什么有两个``package.json``文件，后面打包操作时你就知道了\n\n### 1、首先安装electron\n命令行进入根目录，先用npm安装electron，如果还没有就先[安装node](https://nodejs.org/en/)\n```\nnpm install -g electron-prebuilt\n```\n### 2、生成``package.json``配置文件\n运行``npm init`` 生成一个``package.json``文件来存放应用的相关配置，这个是第一个``package.json``文件，位于外层根目录下的，运行 \n```\nnpm install --save-dev electron-prebuilt  \n```\n会在devDependencies中生成依赖信息，方便后面打包\n```\n{\n  \"name\": \"firstGUI\",\n  \"version\": \"1.0.0\",\n  \"main\": \"app/main.js\",//js入口文件\n  \"scripts\": {\n    \"build\": \"electron-packager ./app firstApp --platform=win32 --arch=x64 --out ./OutApp --version 0.37.3 --overwrite --icon=./app/img/daguo. jpg\",\n    //打包命令，后面打包可以简化代码\n  },\n  \"devDependencies\": {\n    \"electron-prebuilt\": \"^1.2.0\"\n  }\n}\n```\n### 3、新建main.js\n生成一个入口的js文件来作为控制GUI窗口的主进程程序\n```\nconst electron = require('electron');\n// 控制应用生命周期的模块\nconst {app} = electron;\n// 创建本地浏览器窗口的模块\nconst {BrowserWindow} = electron;\n// 指向窗口对象的一个全局引用\nlet win;\n\nfunction createWindow() {\n\n // 创建一个新的浏览器窗口\n  win = new BrowserWindow({ width: 360, height: 572 });\n // 并且装载应用的index.html页面,注意路径\n  win.loadURL('file://'+__dirname+'/html/index.html');\n // 当窗口关闭时调用的方法\n\n  win.on('closed', () => {\n  // 解除窗口对象的引用，通常而言如果应用支持多个窗口的话，你会在一个数组里\n  // 存放窗口对象，在窗口关闭的时候应当删除相应的元素。\n  win = null;\n  });\n}\n\n// 当Electron完成初始化并且已经创建了浏览器窗口，则该方法将会被调用。\n// 有些API只能在该事件发生后才能被使用。\napp.on('ready', createWindow);\n\n// 当所有的窗口被关闭后退出应用\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\napp.on('activate', () => {\n  if (win === null) {\n    createWindow();\n  }\n});\n// 在这个文件后面你可以直接包含你应用特定的由主进程运行的代码。\n// 也可以把这些代码放在另一个文件中然后在这里导入。\n```\n### 4、index.html\nGUI窗口（web页面）渲染的Html文件\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>firstGUI</title>\n  </head>\n  <body>\n    <h1 style=>Hello World!</h1>\n  </body>\n</html>\n```\n\n### 5、运行桌面app\n大公告成，没错就是如此之快，运行``electron .``（跟一个空格和小点），或者``electron app/main``\n打开制作好的GUI界面，so cool~\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_2.png)\n\n### 6、进行打包\n既然是桌面应用，那肯定是要一键运行的，不需要安装什么依赖模块，\n也不需要运行命令行程序的，所以为了提升逼格，让更多的人可以方便实用你的桌面app，\n需要对app文件夹进行打包，安装打包程序 ``electron-packager``\n```\nnpm install --save-dev electron-packager\n```\n打包的基本命令是 \n```\nelectron-packager <location of project> <name of project> <platform> <architecture> <electron version><optional options>\n```\n上面已经在``package.json``的script里配置了简化的命令，可以根据自身情况对名称，操作系统，应用图标进行修改，\n注意啦开始打包前，一定要复制一份``package.json``到app文件，\n前面说了桌面应用不用下载依赖，其实是因为打包的时候就将依赖一同打包到文件包里了，\n所以我们要打包app文件夹下的文件，需要一个``package.json``  来说明依赖项，注意修改里面的路径，要往下一级，然后运行``npm packager``\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_3.png)\n\n完成打包后可以看到OutApp里头已经有了相应的文件，\n运行里面的exe文件会生成和本地测试时一样的GUI窗口~\n\n\n一个简单的基于前端技术栈的桌面app算是完成了，后续的asar文件加密，\n用nsis制作一个安装引导等等~有兴趣的可以继续完善~\n\n一个桌面级app当然不是用来显示``hello world``的，那样和web页面有什么区别，\n这里只是我入门的一个学习记录，一个基于electron的桌面应用\n还有着非常丰富的与系统交互功能可以设计和开发~\n更加详细的用法和配置有兴趣的同学不妨看看官方的[api演示文档](http://electron.atom.io/)，\n它也是一个基于electron做的桌面app\n\n"},{"header":" 最近的npm模块风波","time":" 2016-04-04 17:53:38","tags":" [npm,modules]","description":" npm导致我们不会写代码了？","section":"最近，前端圈子有件事闹得沸沸扬扬，有一个叫做`leftpad`的npm模块被作者撤下，\n导致一系列引用该模板的项目出现问题。\n\n其实本来大家对这件事的重点应该是关于NPM管理者对于模块作者著作权的保护不周上的，\n但是可能由于这个模块的特殊性和他造成的影响之间的对比太强烈，\n让大家都把注意力放到了这个模块本身和引用这个模块的做法上来了。\n<!--more-->\n**这个模块只有短短十一行，仅仅实现一个简单的字符串左侧填充的功能！**\n\n如此简单的模块为什么那么多项目都要引用他呢？\n其实如果不出现作者`unpublish`的问题，大家不会对这样的做法有太多的疑问，\n因为NodeJS的特色就是如此嘛，而且npm的引用和配置下载也非常方便， \n即使是再简单的模块，我若引用也就是`require`一下，然后将依赖写到json里，\n还是比自己写实现函数要方便一些，虽然方便得不多。\n总之就是不出事还好，一出事，那不好意思就得有人负责，\n这件事没有主要负责人，那么就得有问题被抛出。\n\n所以最近这几天抛出的最多的一个问题就是，**对于简单的代码我们仍要引用模块吗？**\n\n\n首先我觉得像这次又模块被作者下架，这毕竟是少数事件，\n我们不应该讨论对于npm的信任问题，这样会使我们在引用模块时畏手畏脚，\n有人说你简单的函数方法自己写嘛，复杂的再引用别人的，\n就是减少引用，就减少了出了事摊上你的概率，\n我只想说在小概率事件中减小该事件的概率--无关痛痒。\n\n\n总之我对npm模块的引用还是持比较乐观的态度，\nnpm的社区非常繁荣，拥有大批的贡献者，我觉得就是即使是再小的一个模块，\n你写出来了就可以`publish`上去，就可以给别人引用，每个人都有发光发热的机会，\n这给作者多大的鼓励和成就感啊，别人用后也会给你反馈，你再去不断改善，\n大家也可以在`review`其他模块代码中得到非常多的编程技术和思想。\n\n\n与对引用小模块的质疑相反，我觉得引用大模块的问题似乎更多，\n一个项目中引用的大模块往往并不需要里面的很多功能，\n所以NodeJS才在新版中将核心模块分割成多份，大家需要用啥再引用那个模块，\n这样就避免了项目庞大引起的各模块之间可能出现的兼容问题，\n也不至于使得代码太臃肿，至于对小模块引用可能导致require和模块依赖过大，\n但是代码依然比较精简，代码的冗余也比较少。\n\n\n最后，关于npm模块的引用，小模块如果有用过或已经知道的精巧模块，\n不仿大胆引用，若是不清楚也不必特意查询，简单的功能自己想方法实现即可，\n大模块如果与项目的配合不好，该分解的最好分解，结合项目和自身的编程习惯，\n高效的完成项目。\n以上仅仅是个人愚昧的一些看法。\n\n"},{"header":" 用hexo搭建一个博客","time":" 2016-05-05 12:00:33","tags":" [hexo,node,git]","description":" 如何用hexo来搭建一个博客","section":"hexo出自一位台湾大学生之手，是如今搭建，管理博客，发布文章的非常好用的工具，\n之前一直想搭建一个不依赖后台，便于管理和发布的博客，在朋友推荐下用了hexo\n确实是简单粗暴好用~\n基于hexo的博客搭建，对于已经配备了Node环境和git的前端开发人士，\n搭建出一个博客那就是分分钟的事情，即使还没有弄好这些也不难搭建，\n下面就从头大致说一说搭建的流程。\n<!--more-->\n### 创建一个github账号和博客\nhexo搭建的博客是一个静态页面，可以直接托放到github上面的服务器上，\n不需要拥有自己的服务器，所以我们要先有一个github账号，\n然后需要生成一个github的博客，之后我们用自己定制的hexo博客来替换它，\n如何搭建github技术博客可以看看这篇:[创建GitHub技术博客全攻略](http://blog.csdn.net/renfufei/article/details/37725057/)\n### 搭建Node环境\n我们还需要一个运行hexo和调试的环境，就是用Nodejs，\n在[官网地址](https://nodejs.org/en/)选一个稳定版或者开发版一键安装好环境。\n### 安装Hexo，生成文章\n准备好nodejs之后打开命令行使用Node的包管理工具npm,直接在命令行运行\n``\nnpm install -g hexo\n``\n\n下载hexo，然后再在相应的目录运行\n``\nhexo init\n``\n\n即可一键生成文件结构，你可以看到在source/_posts里面有一篇默认的helloworld.md文章，\n在themes里面有一个默认的主题landscape，再继续运行\n``\nhexo generate\n``\n\n### 调试，部署到git\n上面过程之后即可生成一个Public文件，里面会有你的文章内容，然后就可以运行\n``\nhexo server\n``\n\n启动localhost:4000，在浏览器输入地址就可以看到你的博客效果了，\n如果你对默认的配置都满意的话下一步就是运行\n``\nhexo deploy\n``\n\n将内容部署到github上面去了，但是我们好像还没有建立hexo和我们账号github仓库的链接，\n所以要在_config.yml最下面进行一些配置\n```\ndeploy:\n  type: git\n  repo: git@github.com:shudery/shudery.github.io.git # 换成你的博客仓库地址\n  branch: master\n```\n然后再hexo deploy即可完成部署，注意用ssh地址可以免去输入密码的繁琐，\n当然前提是要先生成ssh密钥，并且在你的github上面添加这个ssh密钥~\nhexo博客就已经搭建完成，可以在shudery.github.io上面看到博客页面和文章效果\n### 添加文章，更换主题，修改配置\n基本的东西就是这样，接下来我们可以在_posts里面以markdown的写作形式写文章，\n然后通过同样的方式生成，部署，可以直接在_posts里新建md文件，\n也可以用运行\n``\nhexo new [fileStyle] [fileName]\n``\n\n的方式来生成文件，后者会以scaffolds中对应的fileStyle的形式，\n给你生成一个fileName的md文件，里面会包括一些开头的默认字段，\n会方便记录一些文章的信息，我们还可以在[官网主题](https://hexo.io/themes/)里找一个更加符合心意的主题，\n然后直接git clone/ctrl+c 到我们hexo/themes下面，\n然后在hexo/_config.yml中的 theme:landscape 改为你下载好的主题名，\n然后你会发现主题文件夹里还有一个_config.yml 用来修改主题的一些相关配置，\n你可以参考你下载主题的github,或者官网的介绍来设置这些配置~\n### 完善博客\n最后你可以根据自己的喜好和需求为博客添加一些你喜欢的挂件和工具，\n我自己加了多说评论，百度统计，还有就是换了一个逼格高一点的域名，\n通过添加CNAME域名解析，重定向到github.io的博客地址上面。\n\n搭建过程中一些tips~\n\n* hexo clean会清理缓存和Public文件夹一般是在hexo generate之前使用，但是不用没啥问题\n* hexo/_config.yml对于hexo非常重要，但是如果去掉_config.yml你会发现还是依然能运行各种命令\n* 然而一般运行时报错都是config配置有问题，而且很不好定位，\n  所以可以注释掉config.yml里面你觉得应该不会导致报错的配置，然后再运行看结果，\n  重复几次就可以定位到问题了，这对一开始没有什么经验的人来说是一个可行的debug方法。\n* 在做域名重定向的时候，域名解析的CNAME需要指向github.io，\n  此外还要在hexo/source下面也建立一个CNAME文件指向你的设置了重定向的域名地址才行"},{"header":" ES5和ES6中对于继承的实现方法","time":" 2016-07-23 23:32:17","tags":" [javascript]","description":" develop cross-platform GUI app with electron","section":"\n在ES5继承的实现非常有趣的，由于没有传统面向对象类的概念，Javascript利用原型链的特性来实现继承，这其中有很多的属性指向和需要注意的地方。\n原型链的特点和实现已经在之前的一篇整理说过了，就是通过将子类构造函数的原型作为父类构造函数的实例，这样就连通了子类-子类原型-父类，原型链的特点就是逐层查找，从子类开始一直往上直到所有对象的原型Object.prototype，找到属性方法之后就会停止查找，所以下层的属性方法会覆盖上层。\n<!--more-->\n一个基本的基于原型链的继承过程大概是这样的：\n```\n//先来个父类，带些属性\nfunction Super(){\n    this.flag = true;\n}\n//为了提高复用性，方法绑定在父类原型属性上\nSuper.prototype.getFlag = function(){\n    return this.flag;\n}\n//来个子类\nfunction Sub(){\n    this.subFlag = false;\n}\n//实现继承\nSub.prototype = new Super;\n//给子类添加子类特有的方法，注意顺序要在继承之后\nSub.prototype.getSubFlag = function(){\n    return this.subFlag;\n}\n//构造实例\nvar es5 = new Sub;\n```\n原型链实现的继承主要有几个问题：\n1、本来我们为了构造函数属性的封装私有性，方法的复用性，提倡将属性声明在构造函数内，而将方法绑定在原型对象上，但是现在子类的原型是父类的一个实例，自然父类的属性就变成子类原型的属性了；\n这就会带来一个问题，我们知道构造函数的原型属性在所有构造的实例中是共享的，所以原型中属性的改变会反应到所有的实例上，这就违背了我们想要属性私有化的初衷；\n2、创建子类的实例时，不能向父类的构造函数传递参数\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n   this.subFlag = false;\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nobj.flag = flase;  //修改之后，由于是原型上的属性，之后创建的所有实例都会受到影响\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //false；\n```\n为了解决以上两个问题，有一个叫借用构造函数的方法\n只需要在子类构造函数内部使用apply或者call来调用父类的函数即可在实现属性继承的同时，又能传递参数，又能让实例不互相影响\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n    Super.call(this)  //如果父类可以需要接收参数，这里也可以直接传递\n}\nvar obj = new Sub();\nobj.flag = flase;\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //依然是true，不会相互影响\n```\n结合借用构造函数和原型链的方法，可以实现比较完美的继承方法，可以称为组合继承：\n```\nfunction Super(){\n    this.flag = true;\n}\nSuper.prototype.getFlag = function(){\n    return this.flag;     //继承方法\n}\nfunction Sub(){\n    this.subFlag = flase\n    Super.call(this)    //继承属性\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nSuper.prototype.getSubFlag = function(){\n    return this.flag;\n}\n```\n这里还有个小问题，Sub.prototype = new Super;  会导致Sub.prototype的constructor指向Super;\n然而constructor的定义是要指向原型属性对应的构造函数的，Sub.prototype是Sub构造函数的原型，所以应该添加一句纠正：\nSub.prototype.constructor = Sub;\n\n看完ES5的实现，再来看看ES6的继承实现方法，其内部其实也是ES5组合继承的方式，通过call借用构造函数，在A类构造函数中调用相关属性，再用原型链的连接实现方法的继承\n```\nclass B extends A {\n  constructor() {\n    return A.call(this);  //继承属性\n  }\n}\nA.prototype = new B;  //继承方法  \n```\nES6封装了class，extends关键字来实现继承，内部的实现原理其实依然是基于上面所讲的原型链，不过进过一层封装后，Javascript的继承得以更加简洁优雅地实现\n```\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 等同于parent.constructor(x, y)\n    this.color = color;\n  }\n  toString() {\n    return this.color + ' ' + super.toString(); // 等同于parent.toString()\n  }\n}\n```\n通过constructor来定义构造函数，用super调用父类的属性方法\n\nES6中Class充当了ES5中，构造函数在继承实现过程中的作用\n同样有原型属性prototype，以及在ES5中用来指向构造函数原型的`__proto__`属性，这个属性在ES6中的指向有一些主动的修改。\n一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法继承。\n```\nclass A extends B {}\nA.__proto__ === B;  //继承属性\nA.prototype.__proto__ === B.prototype;  //继承方法\n```\nES6的子类的`__proto__`是父类，子类的原型的`__proto__`是父类的原型\n第二条继承链理解起来没有什么问题，对应到ES5中的A.prototype = new B;A.prototype作为B构造的实例，指向构造函数B的原型B.prototype，\n但是在ES5中A.`__proto__`是指向Function.prototype的，因为每一个构造函数其实都是Function这个对象构造的，ES6中子类的`__proto__`指向父类可以实现属性的继承，在ES5中在没有用借用继承的时候由于父类属性被子类原型继承，所有的子类实例实际上都是同一个属性引用。\n在ES6中实现了子类继承父类属性，在构造实例的时候会直接拿到子类的属性，不需要查找到原型属性上面去，ES6新的静态方法和静态属性（只能在构造函数上访问）也是通过这样类的直接继承来实现，至于普通复用方法还是放到原型链上，道理和实现和ES5是一样的。\n此外我认为这里修改A.`__proto__`的指向是有意区分ES6中继承和实例化，同时建立子类和父类直接的关系，ES5的子类的构造函数通过子类的原型与父类的构造函数连接，不存在直接的关系；\n可以这么说，在ES5继承和构造实例，ES6构造实例的时候可以理解`__proto__`原型指针是用来指向构造函数的原型的，但是在ES6继承中，`__proto__`指继承自哪个类或原型，在A继承B之后，构造一个实例 var obj = new A; 会发现它所有的属性指向都是和ES5一致的。\n\n\n有个有趣的地方：ES6继承是在父类创建this对象，在子类constructor中来修饰父类的this，ES5是在子类创建this，将父类的属性方法绑定到子类，由于原生的构造函数（Function，Array等）没有this，子类无法通过call/apply(this)获得其内部属性，所以在ES5无法继承，ES6实现后可以为原生构造函数封装一些有趣的接口，比方说阮一峰老师的这个给Array实例封装一个版本记录和回滚的方法：\n```\nclass VersionedArray extends Array {\n  constructor() {\n    super();\n    this.history = [[]];\n  }\n  commit() {\n    this.history.push(this.slice());\n  }\n  revert() {\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  }\n}\n\nvar x = new VersionedArray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\nx.push(3);\nx // [1, 2, 3]\n\nx.revert();\nx // [1, 2]\n```\n最后做一个ES5和ES6的继承小结：\nES5最经典的继承方法是用组合继承的方式，原型链继承方法，借用函数继承属性，ES6也是基于这样的方式，但是封装了更优雅简洁的api，让Javascript越来越强大，修改了一些属性指向，规范了继承的操作，区分开了继承实现和实例构造，此外ES6继承还能实现更多的继承需求和场景。\n\n\n\n\n\n\n"},{"header":" HTTP缓存及众多的web储存概念之小整理","time":" 2016-08-12 01:46:57","tags":" [javascript,html]","description":" this is a article for my way of studying front-end","section":"\n缓存对于一个网站来说非常重要，可以提高网站性能，减少冗余的数据传输，增加服务器负担，web存储则给浏览器提供了更加强大的保存文件的接口。\n有相当一段时间一直混淆了HTTP缓存相关的属性，HTML5离线存储和本地储存的一些关系，最近好好地整理了一下这些Web存储相关的东西\n\n先列出一些相关属性和概念，看看能否理清它们之间的区别和联系？\n<!--more-->\n\n* manifest\n* cache-control\n* expires\n* 304(no modified)\n* ETag\n* If-None-Match\n* Last-Modified\n* If-Modified-Since\n* http-equiv\n* webstorage\n* cookie/session\n\n是不是感觉有点凌乱，那就跟着我整理的笔记走一遍吧：）\n首先说一说HTTP缓存相关的东西:\n　　\n　　\n`Cache-Control`\n每一个用HTTP请求的资源都可以在响应头用Cache-Control来给浏览器定义缓存策略，通过设置一些属性值它可以控制谁可以，在什么条件下可以缓存响应，还有缓存的有效期，这个属性的一些常用值如下\n\n`no-cache：`表示不使用缓存，先和服务器确认要返回的资源是否有修改\n`no-store：`表示禁止浏览器和所有中继缓存响应的资源\n`max-age=100：`表示缓存的有效期，单位是秒，这一段时间内，除非缓存文件发生一些变动，否则会直接使用之前的缓存，注意这段时间内是不会发Etag等方法去验证的资源有没有修改的。缓存的文件发生变动，主要有这些情况：资源名更改，资源地址更改，缓存被删除，网页强制刷新等；资源名更改，给文件名添加版本hash值，比如给image.png修改为image-hash.png，可以保证每次更新文件时用户可以重新发出请求，获取最新的资源。资源路径更改，修改文件的请求路径，比如给image.png添加查询参数修改为image.png?hash，max-age的时间设置根据每个网站的实际情况不同去设置，一种极端的做法是把这个值设置很大，然后通过修改资源名或者给资源请求地址添加查询参数，来告诉浏览器该更新资源了，一般用在很久才更新网站的情况\n`public：`用max-age即是默认public了，不用设置\n`private：`私人缓存，中继缓存不被允许，但是可以在浏览器缓存\n\n`PS：expires：`表示存在的时间，使客户端在这个设置的时间之前不用去请求资源，类似于max-age，但是expires表示的是一个固定时间，而且可能有服务器和客户端时间不一致的问题，主要用于HTTP1.0版本，在HTTP1.1版本完全可以用功能更强的Cache-Control来替代，和max-age同时存在时expiers会被覆盖掉\n`PS：http-equiv：`缓存有两种控制机制，一种是请求头信息控制，另外一种就是利用meta标签；可以在HTML文档中为meta标签设置http-equiv为相应属性名，content为值来设置缓存，例如\n`<meta http-equiv=\"Expires\" content=\"Mon, 20 Jul 2009 23:00:00 GMT\" />`，不过只对改网页的HTML文件有缓存作用，对该页面的其他资源以及其他页面的HTML文件都没有作用\n　　\n　　\n那么max-age（expires）到期之后，在no-cache下的资源会先和服务器确认返回的资源是否有修改，如何实现这一过程？\n`ETag/If-None-Match，Last-Modified/If-Modified-Since`\nETag (Entity Tag)其实就是一个验证令牌，用来标识一个资源，可能是一个hash值，也可能是一个版本号，每当资源有修改的时候ETag的值就会改变\n浏览器第一次请求之后会保存响应头的ETag值，以便下一次发送请求的时候校验Etag是否有更改。\n　　\n　　\n那么下一次浏览器如何告诉服务器本地已经存有Etag和相应的资源了呢？If-None-Match\n通过在请求头添加If-None-Match(如果存在ETag，浏览器会自动添加)，赋值为上一次请求后在本地存储的Etag值，服务器会和服务端最新资源的Etag比对，如果没有更改会直接返回304 no modified给浏览器，浏览器就直接使用本地缓存的文件\n\n`PS：Last-Modified/If-Modified-Since`的作用等同于`ETag/If-None-Match，`不过前者是通过规定一个时间来比对，最小的单位是秒，后者通过一个唯一标识符，所以可以看出来如果原站在一秒内有多次更新，那么前者就不顶用啦。\nETag的验证要优先于Last-Modified，此外ETag也是有缺点的，在分布式的环境中，Etag在不同服务器上的同步问题可能会给服务器带来一些压力。\n　　\n　　\n`HTTP缓存`是和每一个HTTP请求直接相关的，每一个请求资源的响应都有相应的缓存策略，它们往往是相似的，是否可以通过其他的机制，直接告诉浏览器去缓存哪一些文件呢？\n`HTML5离线存储`闪亮出场\n\nH5离线存储：服务器通过一份.manifest文件给浏览器提供一份完备的缓存名单，名单包括需要缓存的文件，不需要缓存的文件的列表之外，还有一些其他的功能，比如给资源设置备选的请求地址，设置404页面等\n\n实现：利用H5的标签新属性manifest，只需要在HTML文件添加`<html manifest=\"test.manifest\">，`服务器则将manifest文件的mime-type设置为text/cache-manifest类型即可，浏览器每次请求会检查`manifest`是否有更新，服务端通过修改manifest文件，即可在浏览器下一次请求资源的时候通知其更新相应的资源。\n作用：通过本地离线存储可以在没有网络的情况下访问网站事先保存的文件资源，在有网络的情况下直接使用本地资源也可以减少请求连接的压力，提高网页的加载速度，注意这里和HTTP缓存的区别，它是直接使用本地资源，请求返回的是200（from cache）,由于有manifest来统一管理，所以不需要发请求查看是否有更新，也没有过期时间。\n　\n`PS：`这里关于manifest文件自身的更新问题，还是要走HTTP缓存，或者直接不缓存这个文件。\n　　\n　　\n前面提到的概念主要都是缓存请求文件这一块的东西，它们的目的都是为了提高网页的性能，可以说是一种优化型的存储，可以给用户带来更流畅的体验\n但是我们印象中还有一种存储，它可以给我们提供更多的可能和效果的实现，是功能型的存储，如H5本地储存`Webstorage，cookie，session`\n　　\n　　\n`cookie，session`\n众所周知，HTTP是无状态的协议，每一次请求都是独立没有联系的，浏览器和服务器都没有办法维持用户的状态，判断用户是不是依然是之前的那个用户。\n很容易可以想到，在同一个用户的每个请求头添加一个唯一标识符，通过判断这个标识符就可以维持用户的一些信息和状态\n会话信息被用来作为标识符解决这个问题，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案（服务端保持状态也需要客户端保持状态，所以一般session都要基础cookie或者sessionstorage）\n\n总的来说：cookie数据放在客户端，session数据放在服务端，cookie可以设置期限，session则是关闭浏览器时销毁（cookie默认也是），cookie不安全，session可能会影响服务器性能\n\n`Cookie：`通常用Javascript封装一个setCookie的函数来创建，有大小限制，可能会导致请求头过于臃肿，浏览器发送请求时，检查本地cookie，如果该cookie声明的范围大于发送请求的url地址时，就会自动在请求上添加cookie字段\n\n`session：`服务器每次会检查浏览器请求头的session标识，如果有则将这个session id在服务器的数据库（散列表）查找，找到后才进行相应权限的操作\n如果没有这个请求标识，则为客户端新建一个，返回给客户端后，客户端可以通过cookie或者sessionstorage来保存这个session id，通过请求头的cookie字段来给服务器提供sessionId，当cookie被禁止时就需要一些其他方法，通常是采用添加到url路径中，添加表单隐藏域等方法\n\ncookie作为HTTP协议规范的一部分，主要还是用来储存用户信息的，用来和服务端交互，大小也有限制，仅仅只是一种会话级别的存储\n　　\n　　\n`localstorage，sessionstorage`\n`webstorage`为了更大的存储文件设计，与Cookie负责记录用户信息相比，webStorage专注于本地存储，通过封装好的setItem，getItem等方法即可使用\nlocalstorage是一种持久化的存储，除非主动删除，否则永远存在，sessionstorage主要用来存储会话（session），关闭浏览器就会销毁，是一种非持久化的存储\n　　\n　　\n除了上面这些的概念之外，还有诸如像IndexDB，FileSystem等存储方法，关于Web存储的知识真的非常多，看上去坑也是不少，还需要实践慢慢来掌握。\n\n\n\n\n\n\n\n\n\n"},{"header":" JavaScript关键概念理解之闭包","time":" 2016-07-10 21:59:48","tags":" [javascript]","description":" none","section":"\nJavaScript作为一种多范式编程语言，和许多函数式编程语言一样拥有闭包的概念。\n闭包是一个老生常谈的问题，前端面试必问，要理解闭包的原理，必须知道什么是词法作用域，理解词法作用域，又需要对Javascript另外两个关键概念的掌握和理解~\n\n<!--more-->\n\n#### 执行环境和作用域链\n执行环境：红宝书将执行环境称为Javascript这么编程语言最为重要的一个概念，一开始我是不服的，屌屌的闭包和原型链呢？后来一番整理，才发现原来闭包和原型链的实现都是依赖于执行环境。\n执行环境定义了变量或者函数有权访问的数据，决定了它们各自的行为，每个执行环境拥有一个变量对象来保存环境中定义的所有变量和函数。\n每个函数都有自己的执行环境，每次执行语句进入函数后，就会将相应函数的执行函数压入环境栈中，执行完函数之后就会弹出，将控制权交给原来的执行环境。\n\n作用域链：作用域链用来保证执行环境中，对所有环境有权访问的变量或者函数的有序访问。每一个执行环境会为自身的变量对象创建一个作用域链，作用域的前端始终是当前执行环境的变量对象，会一直向外延伸到全局作用环境，执行环境查询变量和函数的顺序遵循从局部到全局，一旦找到就会停止查找。\n\n执行环境和作用域是很多概念和一些实现方法的基础，在Javascript里，执行环境决定了访问的权限，作用域链决定了访问的顺序。\n\n#### 闭包和词法作用域\n闭包：闭包就是一个作用域内定义的一个函数，由于Javascript没有块级作用域，局部作用域的形成依赖于函数来实现，所以也可以说闭包是一个函数里定义的一个函数。由于闭包的一个作用就是用来访问其他函数作用域中的变量，所以它又有一种定义：闭包指有权访问另一个函数作用域中变量的一个函数。\n先看一段代码\n```\nname = 'hi';\nfunction close(){\n    name = 'hello';\n    return function sayName(){\n        console.log(name)\n    }\n}\nvar sayName = close();\nsayName();\n```\n词法作用域：在这段代码中console出来的是hello，也就是说sayName执行过程中的name值取得是close函数内部的Name，而不是外部全局环境的name；根据上面对执行环境的理解，当进入sayName这个函数之后，执行环境就由全局进入局部环境，注意到每次定义函数的同时就会生成该函数的执行环境，所以sayName是在哪里声明的，它的外部执行环境就是谁，在这里就是close这个函数的执行环境，再根据上面对作用域链的理解，sayName对于name变量的查询将到此为止，不会到全局去，所以name的值就是hello，而不是hi，简单的说，sayName这个函数所属的作用域是声明它的时候所在的作用域，而不是运行它的时候，高端地说，这就是Javascript的词法作用域。\n\n依照作用域链的原理，本来全局执行环境是没有办法访问到局部执行环境的，但是由于词法作用域的原因，使得sayName这个闭包（全局环境）拥有了访问close内部name变量（局部环境）的能力。\n\n#### 闭包和this关键字\n闭包经常会和this关键字配合使用，每个函数在被调用的时候都会自动获得两个特殊变量，一个是arguments，另一个就是this，所以在一些多层嵌套return的闭包中，无法同过this来正确获得外层的this，因为作用域链在最里层的函数找到this后就停止了，所以一般都需要用一个中间变量来存储或者用bind方法绑定外层的this指向\n```\nvar name = 'hi';\nvar obj = {\n    name:'hello';\n    getName:function(){\n        //var that = this;\n        return function(){\n            return this.name;\n        }\n    }\n}\n```\n关于this的指向问题，只需要认准this当前所在函数的调用方式即可，当函数作为一个对象的方法调用时，this指向为这个对象，当作为一个函数调用时，this在非严格模式下指向全局，严格模式下返回undefined\n\n闭包的作用：\n特权方法：通过上面的闭包的概念理解，已经可以知道闭包的一个作用就是作为一个公有方法用来访问私有变量的，有权访问私有变量和函数的公有方法也叫做特权方法；Javascript中虽然没有传统面向对象中的类，也没有私有成员的概念，不过对于一个函数而言，其函数参数，内部声明的变量或者函数就是私有的。\n```\nfunction Person(){\n    var name = 'daguo';\n    var getAge  = function(){\n        return console.log('22');\n    }\n    this.publicMethod = function(){\n        console.log(name)\n        return getAge()\n    }\n}\n```\n保留变量：通常函数的作用域和其所有变量会在函数执行结束之后就销毁，但是当这个函数返回一个闭包时，只要闭包还存在，那么声明闭包的这个作用域内的变量就不会被销毁，原因就是闭包依然保有对这些变量的引用，使它们不会被JS垃圾回收标记清除。这是一个可以利用的地方，也可能是一个造成内存泄漏的原因。所以不能过多创建闭包\n\n\n\n\n\n\n\n\n\n"},{"header":" chrome扩展程序入门手记","time":" 2016-06-14 23:08:15","tags":" [javascript,chrome]","description":" share my record after learning how to build a plugin for chrome.","section":"chrome是我非常喜欢的浏览器，它除了速度飞快，对前端代码支持友好的优点外，\n还有非常丰富的扩展程序资源，提供了大量方便强大的web页面应用插件\n这两天由于朋友的业务需求，接触了一些chrome扩展程序(即俗称插件)的有关代码\n基于对谷歌开发者文档的学习，随手记录了写chrome插件的基本方法~\n<!--more-->\n每一个基本的Chrome插件,首先都有一个manifest.json\n的配置文件用来存储插件的基本信息 \n\n``\n\"manifest_version\": 2,\n  \"name\": \"Getting started example\",\n  \"description\": \"This extension shows a Google Image search result for the current page\",\n  \"version\": \"1.0\"\n``\n\n包括manifest的版本，扩展插件的名字，描述，版本\n\n弹窗页面的信息browser_action, 在里面配置一个插件弹窗html页面代码，一般名字是popup.html，\n浏览器界面显示的扩展图标位置，以及鼠标hover的title\n\n``\n\"browser_action\": {\n    \"default_icon\": \"images/icon.png\",\n    \"default_popup\": \"popup.html\",\n    \"default_title\": \"Click here!\"\n  }\n``\n\n可选的页面注入代码，一般名字是contentscript.js，\n可选多个文件，匹配页面的matches，只对匹配到的注入代码\n\n``\n\"content_scripts\": [{\n    \"js\": [\"jquery.min.js\", \"contentscript.js\"],\n    \"matches\": [\"http://*/*\",\"https://*/*\"]\n  }]\n``\n\n还有插件要求的权限和要使用该插件的网页的匹配\n\n``\n\"permissions\": [\n    \"tabs\",\n    \"http://*/\"\n  ]\n``\n\n关于manifest的更多字段配置信息，可以查看360翻译谷歌的[开发者文档](http://open.chrome.360.cn/extension_dev/manifest.html)\n\n从上面的配置可以看到，一个简单插件除了有manifest之外\n还有一个browser_action, 即popup.html来渲染点击插件之后的弹窗页面，\n这个页面可以分离出来popup.js popup.css等文件，\n这些文件可以放在同一个根目录下，文件中的引用跟普通项目一致可以取相对路径\n\n\n如果要实现与浏览器打开页面的交互就必须还有一个注入脚本文件，\n一般取名contentscript.js，弹窗页面popup page通过相应api实现和注入脚本的交互\n再由注入脚本实现对web page的交互\n在popup page（popup.js）中的输入代码\n\n```\nchrome.tabs.query({\n      active: true\n    }, function(tab) {\n       var data = '';\n        //要传递给注入脚本文件的信息\n      chrome.tabs.sendMessage(tab[0].id, 'hello, content script, from background page. there are some data:' + data);\n});\n```\n\n第二个参数为发送的信息，在注入脚本中通过request参数拿到\n在contentscript.js中输入以下代码，开启对popup.js的信息发送监听，拿到信息request\n\n```\nchrome.extension.onMessage.addListener(function(request) {\n  //request是popup page传来的信息\n   console.log('get the message from popup.js'+request)\n   //收到popup page的信息后要做的事情\n});\n```\n\n注入脚本contentscript.js和浏览器打开的网页脚本web page运行在不同的环境之下，\n所以他们的变量名和全局对象不会有冲突，\n但是他们共享一个DOM树，也就是可以通过修改注入脚本的DOM结构来改变页面的DOM，\n这也就是注入脚本同web page交互的方式\n\n最后贴一个我练手写的一个[chrome插件](https://github.com/shudery/daguoNote)，\n实现简单的便签功能，界面用amazeUI做的，\n用React渲染，后台处理用Express搭建，数据结果直接保存一份JSON文件来管理\n"},{"header":" javascript的对象构造和原型链继承","time":" 2016-04-14 17:55:58","tags":" [javascript]","description":" javascript的对象构造和原型链继承","section":"这两天仔细地学习了JS的创建对象以及继承的方法，结合红宝石书整理了下笔记。\n（红宝石这里讲了非常多的模式，看第一遍觉得还蛮乱的）\nJavascript作为一种动态的面向对象语言，本身却没有类的概念和方法，\n在创建对象和继承方面有很多有趣的实现和方法\n<!--more-->\n## 1.原始绑定和字面量表示：\n**优点**：简洁方便\n**问题**：使用对象字面量的方法创建的对象，若重复创建会产生大量的重复代码\n```\nvar o = new Object();\no.name = 'shudery';\no.skill = function(){console.log('sayHello')};\n//这是比较老的方法，一般用下面这种简单粗暴的，直接字面量创建\n\nvar obj = {\n    sex = 'man',\n    skill = function(){console.log('tucao')} \n    ...\n}\n```\n## 2.工厂模式：\n抽象创建具体对象的过程\n**具体**：用函数来封装对象，然后调用特定接口创建对象\n**优点和问题**：解决代码重复性的问题，但是没有解决对象识别问题\n```\nfunction createObj(name){\n    var obj= {\n        name : name ,\n        skill : function(){console.log('tucao')}\n    };\n    return obj;\n}\nvar obj_1 = createObj('shudery');\nvar obj_2 = createObj('Lin'); \n//Object类型的对象\n```\n## 3.构造函数模式：\n使用`new`操作符，没有显式创建对象\n**优点**：解决了代码识别问题，可以将它构造的实例标示为特定类型\n**问题**：多次复用的方法需要在每个实例上重新创建一遍，浪费内存\n```\nfunction Myobj(name){\n        this.name = name,\n        this.skill= function(){console.log('tucao')}   \n}\nvar obj_1 =  new Myobj('shudery');\nvar obj_2 =  new Myobj('Lin');\n//对象类型名称为myObj，解决了识别的问题，用下面方法可以验证\nconsole.log(obj_1.constructor === Myobj && obj_2 instanceof Myobj);//true\n```\n这里如果怕遗漏new关键字，可以在`myObj`函数里头显示地返回一个对象，如下：\n```\nfunction Myobj(name){\n        var obj={};\n        obj.name=name,\n        obj.method= function(){\n        console.log('tucao')\n         }\n    return obj;\n}\nvar obj_1 = Myobj('shudery');\nvar obj_2 = new Myobj('shudery');\n```\n如果这么做`obj_1`的`constructor`指向的是`Object`\n这样就和工程模式一样不能识别对象，\n但是功能上两个对象相同，这也被叫寄生构造函数模式，一般不用它\n此外在构造函数模式下如果没有引用this和new，那就是稳妥构造函数模式，\n一般用在安全的环境\n\n## 4.原型模式：\n在构造函数模式下如果直接提取出方法函数到全局环境下，\n在方法变多时容易污染命名空间，\n此外不利于我们自定义的引用类型的封装。\n我们可以用JS的一大特色原型属性来挂载属性方法。\n**优点**：我们可以将复用的方法绑定到每一个构造函数定义的原型属性prototype上来，这样所有的对象实例都可以共享这个挂在这个原型下的属性和方法。\n**问题**：实例失去本身的特点和封装，公用一套属性和方法\n```\nfunction Myobj(){\n       \n}\nMyobj.prototype.name ='shudery';\nMyobj.prototype.age = '22';\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj();\n```\n也可用对象字面量形式，不过要注意顺序，字面量的形式相当于重写整个对象，\n构造函数原型的`constructor`属性（指向对象类型）会被重写为`Object`,\n而不是`Myobj`了\n```\nfunction Myobj(){\n       \n}\nvar obj =  new Myobj();//先实例化\nMyobj.prototype={\n//重写后这个原型和Myobj这个构造函数就没有关系了\n    name: 'shudery',\n    age:'22',\n    method : function(){\n    console.log('tucao')\n    }\n};\nobj.name;//undefined，联系被切断了\n```\n如果在重写之后实例化一个对象，虽然还存在联系，\n但是`obj`实例就不是`Myobj`类型了\n不在乎对象识别问题的话，也可以直接这样重写，仍能调用obj.name等属性和方法\n\n## 5.终极模式：构造函数+原型模式\n 最为常用的创建对象的方式，结合两种模式的优点，\n 实现对象属性的封装和对象方法的复用，\n平衡了对象的独立性和多态复用节省内存的问题。\n```\nfunction Myobj(name,age){\n    this.name =name;\n    this.age = age\n}\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj('shudery',22);\n```\n如此一来对象就拥有自定义的属性和可共享复用的方法啦\n有句话这样说，当我们把程序中变化的部分封装好之后，剩下的就是稳定可复用的了\n这也是很多种设计模式里推崇的，放到创建对象的方法里也是一样的做法。\n\n说完对象的创建，接下来是继承~\nJS是没有类的关键字和概念的，它的继承是基于原型链的，类似上面的原型模式\n我们先简单了解下原型链：\n\n![](https://raw.githubusercontent.com/shudery/public/master/clipboard.png)\n\n每个构造函数都有一个原型对象，构造的实例有一个指向原型对象的指针，\n如果我们把父类的实例赋值给原型对象，那么子类的原型对象就是父类的实例， \n那么这个实例还是有一个指向父类原型的指针，\n这些指针连起了子类和父类的实例（子类构造函数的原型），就是原型链。\n\n对象的方法和属性会循着原型链进行访问，直到查找到相应的属性和方法名，\n或者到达原型链的终点`Object.prototype`,这也就实现了继承\n\n\n\n\n\n\n\n\n\n\n"},{"header":" 搭建属于自己的vpn服务器","time":" 2016-06-10 21:59:48","tags":" [vpn]","description":" how to build vpn or vps by youself","section":"之前实习的时候想着有需要翻墙的时候用着公司的vpn就足够了\n但是随着马上要去工作，还有对一些国外资源的需求（资源你懂的）\n然后也前后被一些网上的vpn服务商坑过（各种掉线，不稳定）\n决定自己租用一台国外的服务器vps\n<!--more-->\n了解一番后知道了国外[搬瓦工](http://bandwagonhost.com/)和[digital ocean](www.digitalocean.com/?refcode=3491087221da)都有不错的口碑，最终选择DO,\n最便宜的512MB内存，20GB固态硬盘，1TB流量，\n\n这个好像只是防止恶意使用的，实际上流量是用不完的，\n在服务器控制版面也没有流量使用情况提示\n首先注册账号，输入邮箱密码，在邮箱收到确认邮件，\n来到Payment Methods \n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_1.png)\n\n这一项我选择的是方便快捷的PayPal，Credit不好设置\n需要预充5刀PayPal，5刀也是最便宜的服务器的月租价格，\n如果没有PayPal的话就先注册一次，比这个Credit方便多了\n注意一些老旧的银联卡号可能提示设置错误，我换了一张卡就好了\n\n然后开始选择服务器，包括价格，地点，系统，\n我选了最便宜已经够用了的5刀/月，ping后较快的美国西部服务器，\n以及比较容易操作的ubuntu系统，然后添加主机的SSH密钥，以后方便，\n\n不过也可以先跳过以后再说，买后会收到邮件，\n得到一个服务器主机Ip，root账户名，以及一个初始密码。\nvps算是有了，接下来我们在这台服务器上搭建vpn\n\n然后不得吐槽的是网页的console控制台实在有点卡卡，\n所以我用简单的putty来建立与vps的链接，也可以使用xshell等工具，\n下载putty后直接输入ip地址，保留默认端口，点击open就进入控制台了\n\n然后输入你的用户名root，然后出现password输入密码，\n这里注意啦~输入密码的时候，光标是不会动的！\n所以，慢慢输入，不要输错了，登录成功后显示一些信息\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_2.png)\n\n第一次登陆要求重置密码，分别填一次旧密码和两次新密码，注意光标还是不会移动！\n然后开始一列Linux操作，作为小白的我们就只管输入代码即可，\n不过我们也是有(yao)追(zhuan)求(bi)的小白，所以也要大概知道这些代码是个什么作用\n\n### 1、安装vpn服务\n首先我们必须在vps服务器上安装一种vpn服务，这里选择点对点隧道协议pptp,输入\n\n```\napt-get install pptpd\n```\n\n### 2、配置文件修改\n用vi编辑器打开配置文件，输入\n\n```\nvi /etc/pptpd.conf\n```\n\n没用过vi的注意啦，要编辑文件必须先输入i，进入INSERT模式，\n将光标移动到最下面更改\n\n```\nlocalip 10.0.0.1\nremoteip 10.0.0.100-200\n```\n\n有两段，localip更改为你vps服务器的ip地址，remoteip是以后分配给\n其他连到你vpn的服务器的ip，可以照着例子分配，写完后保存，\nvi的文件保存方法是先按Esc然后输入冒号:wq即可，w是写入保存，q是退出vi\n\n### 3、添加vpn账号\n用vi打开密钥文件，输入\n\n``` \nvi /etc/ppp/chap-secrets \n```\n\n依次输入 username pptpd password ### \n将username, password更换为你的vpn账号和密码，中间是服务名，\n最后一个是ip通配符，如果要建立多个vpn账号给妹子基友一起用，\n还一行依次输入即可，输完同样保存\n\n### 4、设置公共DNS服务，输入\n\n```\nvi /etc/ppp/pptpd-options\n```\n\n打开服务选项文件设置找到ms-dns并设置为\n`\nms-dns 8.8.8.8\nms-dns 8.8.4.4\n`\n\n### 5、重启pptp服务，\n重启服务，刷新配置，输入\n\n```\nservice pptpd restart\n```\n\n### 6、ip转发配置\n打开转发配置文件，输入\n\n```\nvi /etc/sysctl.conf\n```\n\n发现整个文件都带有注释符#,去掉`# net.ipv4.ip_forward = 1`\n前面的注释符#保存,为了使配置生效还需运行\n\n```\nsysctl -p\n```\n\n### 7、设置iptables\n设置并保存，运行\n\n```\niptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE && iptables-save\n```\n\n至此搭建好属于你自己的vpn，拿着账号在手机和电脑的vpn设置登录即可\n注意如果出现vpn隧道协议构建失败，检查一下网络适配器里vpn的安全属性\n勾选为以下选项\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_3.jpg)\n\n\n\n\n\n\n\n"},{"header":" Javascript开发跨平台桌面app","time":" 2016-06-23 23:32:17","tags":" [javascript,node]","description":" develop cross-platform GUI app with electron","section":"electron原本是atom shell的项目，由于集成node丰富的本地系统级API，\n提供了与操作系统交互的功能，所以归结起来，现在javascrpit的技术栈之所以如此宽广，\n要得益于NodeJS将其中浏览器的环境中分离出来\n\n不过需要特别说明的是，这里生成的桌面应用，\n实际上是Electron生成的一个由Javascrpit控制管理的迷你浏览器Chromeinum，\n它其实是一个Chrome浏览器的试验版本，当然用的也是V8的内核\n<!--more-->\n不管怎么说，这对于喜欢前端，熟悉javascript的同学来说，\n能够用前端和一点后台的知识去接触，尝试各种不同的领域，实在是不要太爽\n\nElectron的入门也符合前端知识领域的特点，几乎没有门槛，\n只要你有一点JS和Node的基础就行了，开发目录的文件层次结构也很简单，\n后面会有打包工具帮助我们一键打包生成层次比较复杂的项目文件，\n作为桌面GUI应用，当然也包括.exe的启动文件，\n\n让我们看看如何开发一个桌面应用，或者说一个能和操作本地系统的web页面的基本方法~\n你可以跟着步骤完成一些基本的文件，也可以直接下载[快速开始的demo](https://github.com/shudery/electron/archive/master.zip)\n基本的文件层次很简单，用app存放一个具体的桌面应用，具体结构是这样的\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_1.png)\n\nOutApp用来存放打包输出的exe文件\n至于为什么有两个``package.json``文件，后面打包操作时你就知道了\n\n### 1、首先安装electron\n命令行进入根目录，先用npm安装electron，如果还没有就先[安装node](https://nodejs.org/en/)\n```\nnpm install -g electron-prebuilt\n```\n### 2、生成``package.json``配置文件\n运行``npm init`` 生成一个``package.json``文件来存放应用的相关配置，这个是第一个``package.json``文件，位于外层根目录下的，运行 \n```\nnpm install --save-dev electron-prebuilt  \n```\n会在devDependencies中生成依赖信息，方便后面打包\n```\n{\n  \"name\": \"firstGUI\",\n  \"version\": \"1.0.0\",\n  \"main\": \"app/main.js\",//js入口文件\n  \"scripts\": {\n    \"build\": \"electron-packager ./app firstApp --platform=win32 --arch=x64 --out ./OutApp --version 0.37.3 --overwrite --icon=./app/img/daguo. jpg\",\n    //打包命令，后面打包可以简化代码\n  },\n  \"devDependencies\": {\n    \"electron-prebuilt\": \"^1.2.0\"\n  }\n}\n```\n### 3、新建main.js\n生成一个入口的js文件来作为控制GUI窗口的主进程程序\n```\nconst electron = require('electron');\n// 控制应用生命周期的模块\nconst {app} = electron;\n// 创建本地浏览器窗口的模块\nconst {BrowserWindow} = electron;\n// 指向窗口对象的一个全局引用\nlet win;\n\nfunction createWindow() {\n\n // 创建一个新的浏览器窗口\n  win = new BrowserWindow({ width: 360, height: 572 });\n // 并且装载应用的index.html页面,注意路径\n  win.loadURL('file://'+__dirname+'/html/index.html');\n // 当窗口关闭时调用的方法\n\n  win.on('closed', () => {\n  // 解除窗口对象的引用，通常而言如果应用支持多个窗口的话，你会在一个数组里\n  // 存放窗口对象，在窗口关闭的时候应当删除相应的元素。\n  win = null;\n  });\n}\n\n// 当Electron完成初始化并且已经创建了浏览器窗口，则该方法将会被调用。\n// 有些API只能在该事件发生后才能被使用。\napp.on('ready', createWindow);\n\n// 当所有的窗口被关闭后退出应用\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\napp.on('activate', () => {\n  if (win === null) {\n    createWindow();\n  }\n});\n// 在这个文件后面你可以直接包含你应用特定的由主进程运行的代码。\n// 也可以把这些代码放在另一个文件中然后在这里导入。\n```\n### 4、index.html\nGUI窗口（web页面）渲染的Html文件\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>firstGUI</title>\n  </head>\n  <body>\n    <h1 style=>Hello World!</h1>\n  </body>\n</html>\n```\n\n### 5、运行桌面app\n大公告成，没错就是如此之快，运行``electron .``（跟一个空格和小点），或者``electron app/main``\n打开制作好的GUI界面，so cool~\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_2.png)\n\n### 6、进行打包\n既然是桌面应用，那肯定是要一键运行的，不需要安装什么依赖模块，\n也不需要运行命令行程序的，所以为了提升逼格，让更多的人可以方便实用你的桌面app，\n需要对app文件夹进行打包，安装打包程序 ``electron-packager``\n```\nnpm install --save-dev electron-packager\n```\n打包的基本命令是 \n```\nelectron-packager <location of project> <name of project> <platform> <architecture> <electron version><optional options>\n```\n上面已经在``package.json``的script里配置了简化的命令，可以根据自身情况对名称，操作系统，应用图标进行修改，\n注意啦开始打包前，一定要复制一份``package.json``到app文件，\n前面说了桌面应用不用下载依赖，其实是因为打包的时候就将依赖一同打包到文件包里了，\n所以我们要打包app文件夹下的文件，需要一个``package.json``  来说明依赖项，注意修改里面的路径，要往下一级，然后运行``npm packager``\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_3.png)\n\n完成打包后可以看到OutApp里头已经有了相应的文件，\n运行里面的exe文件会生成和本地测试时一样的GUI窗口~\n\n\n一个简单的基于前端技术栈的桌面app算是完成了，后续的asar文件加密，\n用nsis制作一个安装引导等等~有兴趣的可以继续完善~\n\n一个桌面级app当然不是用来显示``hello world``的，那样和web页面有什么区别，\n这里只是我入门的一个学习记录，一个基于electron的桌面应用\n还有着非常丰富的与系统交互功能可以设计和开发~\n更加详细的用法和配置有兴趣的同学不妨看看官方的[api演示文档](http://electron.atom.io/)，\n它也是一个基于electron做的桌面app\n\n"},{"header":" 最近的npm模块风波","time":" 2016-04-04 17:53:38","tags":" [npm,modules]","description":" npm导致我们不会写代码了？","section":"最近，前端圈子有件事闹得沸沸扬扬，有一个叫做`leftpad`的npm模块被作者撤下，\n导致一系列引用该模板的项目出现问题。\n\n其实本来大家对这件事的重点应该是关于NPM管理者对于模块作者著作权的保护不周上的，\n但是可能由于这个模块的特殊性和他造成的影响之间的对比太强烈，\n让大家都把注意力放到了这个模块本身和引用这个模块的做法上来了。\n<!--more-->\n**这个模块只有短短十一行，仅仅实现一个简单的字符串左侧填充的功能！**\n\n如此简单的模块为什么那么多项目都要引用他呢？\n其实如果不出现作者`unpublish`的问题，大家不会对这样的做法有太多的疑问，\n因为NodeJS的特色就是如此嘛，而且npm的引用和配置下载也非常方便， \n即使是再简单的模块，我若引用也就是`require`一下，然后将依赖写到json里，\n还是比自己写实现函数要方便一些，虽然方便得不多。\n总之就是不出事还好，一出事，那不好意思就得有人负责，\n这件事没有主要负责人，那么就得有问题被抛出。\n\n所以最近这几天抛出的最多的一个问题就是，**对于简单的代码我们仍要引用模块吗？**\n\n\n首先我觉得像这次又模块被作者下架，这毕竟是少数事件，\n我们不应该讨论对于npm的信任问题，这样会使我们在引用模块时畏手畏脚，\n有人说你简单的函数方法自己写嘛，复杂的再引用别人的，\n就是减少引用，就减少了出了事摊上你的概率，\n我只想说在小概率事件中减小该事件的概率--无关痛痒。\n\n\n总之我对npm模块的引用还是持比较乐观的态度，\nnpm的社区非常繁荣，拥有大批的贡献者，我觉得就是即使是再小的一个模块，\n你写出来了就可以`publish`上去，就可以给别人引用，每个人都有发光发热的机会，\n这给作者多大的鼓励和成就感啊，别人用后也会给你反馈，你再去不断改善，\n大家也可以在`review`其他模块代码中得到非常多的编程技术和思想。\n\n\n与对引用小模块的质疑相反，我觉得引用大模块的问题似乎更多，\n一个项目中引用的大模块往往并不需要里面的很多功能，\n所以NodeJS才在新版中将核心模块分割成多份，大家需要用啥再引用那个模块，\n这样就避免了项目庞大引起的各模块之间可能出现的兼容问题，\n也不至于使得代码太臃肿，至于对小模块引用可能导致require和模块依赖过大，\n但是代码依然比较精简，代码的冗余也比较少。\n\n\n最后，关于npm模块的引用，小模块如果有用过或已经知道的精巧模块，\n不仿大胆引用，若是不清楚也不必特意查询，简单的功能自己想方法实现即可，\n大模块如果与项目的配合不好，该分解的最好分解，结合项目和自身的编程习惯，\n高效的完成项目。\n以上仅仅是个人愚昧的一些看法。\n\n"},{"header":" 用hexo搭建一个博客","time":" 2016-05-05 12:00:33","tags":" [hexo,node,git]","description":" 如何用hexo来搭建一个博客","section":"hexo出自一位台湾大学生之手，是如今搭建，管理博客，发布文章的非常好用的工具，\n之前一直想搭建一个不依赖后台，便于管理和发布的博客，在朋友推荐下用了hexo\n确实是简单粗暴好用~\n基于hexo的博客搭建，对于已经配备了Node环境和git的前端开发人士，\n搭建出一个博客那就是分分钟的事情，即使还没有弄好这些也不难搭建，\n下面就从头大致说一说搭建的流程。\n<!--more-->\n### 创建一个github账号和博客\nhexo搭建的博客是一个静态页面，可以直接托放到github上面的服务器上，\n不需要拥有自己的服务器，所以我们要先有一个github账号，\n然后需要生成一个github的博客，之后我们用自己定制的hexo博客来替换它，\n如何搭建github技术博客可以看看这篇:[创建GitHub技术博客全攻略](http://blog.csdn.net/renfufei/article/details/37725057/)\n### 搭建Node环境\n我们还需要一个运行hexo和调试的环境，就是用Nodejs，\n在[官网地址](https://nodejs.org/en/)选一个稳定版或者开发版一键安装好环境。\n### 安装Hexo，生成文章\n准备好nodejs之后打开命令行使用Node的包管理工具npm,直接在命令行运行\n``\nnpm install -g hexo\n``\n\n下载hexo，然后再在相应的目录运行\n``\nhexo init\n``\n\n即可一键生成文件结构，你可以看到在source/_posts里面有一篇默认的helloworld.md文章，\n在themes里面有一个默认的主题landscape，再继续运行\n``\nhexo generate\n``\n\n### 调试，部署到git\n上面过程之后即可生成一个Public文件，里面会有你的文章内容，然后就可以运行\n``\nhexo server\n``\n\n启动localhost:4000，在浏览器输入地址就可以看到你的博客效果了，\n如果你对默认的配置都满意的话下一步就是运行\n``\nhexo deploy\n``\n\n将内容部署到github上面去了，但是我们好像还没有建立hexo和我们账号github仓库的链接，\n所以要在_config.yml最下面进行一些配置\n```\ndeploy:\n  type: git\n  repo: git@github.com:shudery/shudery.github.io.git # 换成你的博客仓库地址\n  branch: master\n```\n然后再hexo deploy即可完成部署，注意用ssh地址可以免去输入密码的繁琐，\n当然前提是要先生成ssh密钥，并且在你的github上面添加这个ssh密钥~\nhexo博客就已经搭建完成，可以在shudery.github.io上面看到博客页面和文章效果\n### 添加文章，更换主题，修改配置\n基本的东西就是这样，接下来我们可以在_posts里面以markdown的写作形式写文章，\n然后通过同样的方式生成，部署，可以直接在_posts里新建md文件，\n也可以用运行\n``\nhexo new [fileStyle] [fileName]\n``\n\n的方式来生成文件，后者会以scaffolds中对应的fileStyle的形式，\n给你生成一个fileName的md文件，里面会包括一些开头的默认字段，\n会方便记录一些文章的信息，我们还可以在[官网主题](https://hexo.io/themes/)里找一个更加符合心意的主题，\n然后直接git clone/ctrl+c 到我们hexo/themes下面，\n然后在hexo/_config.yml中的 theme:landscape 改为你下载好的主题名，\n然后你会发现主题文件夹里还有一个_config.yml 用来修改主题的一些相关配置，\n你可以参考你下载主题的github,或者官网的介绍来设置这些配置~\n### 完善博客\n最后你可以根据自己的喜好和需求为博客添加一些你喜欢的挂件和工具，\n我自己加了多说评论，百度统计，还有就是换了一个逼格高一点的域名，\n通过添加CNAME域名解析，重定向到github.io的博客地址上面。\n\n搭建过程中一些tips~\n\n* hexo clean会清理缓存和Public文件夹一般是在hexo generate之前使用，但是不用没啥问题\n* hexo/_config.yml对于hexo非常重要，但是如果去掉_config.yml你会发现还是依然能运行各种命令\n* 然而一般运行时报错都是config配置有问题，而且很不好定位，\n  所以可以注释掉config.yml里面你觉得应该不会导致报错的配置，然后再运行看结果，\n  重复几次就可以定位到问题了，这对一开始没有什么经验的人来说是一个可行的debug方法。\n* 在做域名重定向的时候，域名解析的CNAME需要指向github.io，\n  此外还要在hexo/source下面也建立一个CNAME文件指向你的设置了重定向的域名地址才行"},{"header":" ES5和ES6中对于继承的实现方法","time":" 2016-07-23 23:32:17","tags":" [javascript]","description":" develop cross-platform GUI app with electron","section":"\n在ES5继承的实现非常有趣的，由于没有传统面向对象类的概念，Javascript利用原型链的特性来实现继承，这其中有很多的属性指向和需要注意的地方。\n原型链的特点和实现已经在之前的一篇整理说过了，就是通过将子类构造函数的原型作为父类构造函数的实例，这样就连通了子类-子类原型-父类，原型链的特点就是逐层查找，从子类开始一直往上直到所有对象的原型Object.prototype，找到属性方法之后就会停止查找，所以下层的属性方法会覆盖上层。\n<!--more-->\n一个基本的基于原型链的继承过程大概是这样的：\n```\n//先来个父类，带些属性\nfunction Super(){\n    this.flag = true;\n}\n//为了提高复用性，方法绑定在父类原型属性上\nSuper.prototype.getFlag = function(){\n    return this.flag;\n}\n//来个子类\nfunction Sub(){\n    this.subFlag = false;\n}\n//实现继承\nSub.prototype = new Super;\n//给子类添加子类特有的方法，注意顺序要在继承之后\nSub.prototype.getSubFlag = function(){\n    return this.subFlag;\n}\n//构造实例\nvar es5 = new Sub;\n```\n原型链实现的继承主要有几个问题：\n1、本来我们为了构造函数属性的封装私有性，方法的复用性，提倡将属性声明在构造函数内，而将方法绑定在原型对象上，但是现在子类的原型是父类的一个实例，自然父类的属性就变成子类原型的属性了；\n这就会带来一个问题，我们知道构造函数的原型属性在所有构造的实例中是共享的，所以原型中属性的改变会反应到所有的实例上，这就违背了我们想要属性私有化的初衷；\n2、创建子类的实例时，不能向父类的构造函数传递参数\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n   this.subFlag = false;\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nobj.flag = flase;  //修改之后，由于是原型上的属性，之后创建的所有实例都会受到影响\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //false；\n```\n为了解决以上两个问题，有一个叫借用构造函数的方法\n只需要在子类构造函数内部使用apply或者call来调用父类的函数即可在实现属性继承的同时，又能传递参数，又能让实例不互相影响\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n    Super.call(this)  //如果父类可以需要接收参数，这里也可以直接传递\n}\nvar obj = new Sub();\nobj.flag = flase;\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //依然是true，不会相互影响\n```\n结合借用构造函数和原型链的方法，可以实现比较完美的继承方法，可以称为组合继承：\n```\nfunction Super(){\n    this.flag = true;\n}\nSuper.prototype.getFlag = function(){\n    return this.flag;     //继承方法\n}\nfunction Sub(){\n    this.subFlag = flase\n    Super.call(this)    //继承属性\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nSuper.prototype.getSubFlag = function(){\n    return this.flag;\n}\n```\n这里还有个小问题，Sub.prototype = new Super;  会导致Sub.prototype的constructor指向Super;\n然而constructor的定义是要指向原型属性对应的构造函数的，Sub.prototype是Sub构造函数的原型，所以应该添加一句纠正：\nSub.prototype.constructor = Sub;\n\n看完ES5的实现，再来看看ES6的继承实现方法，其内部其实也是ES5组合继承的方式，通过call借用构造函数，在A类构造函数中调用相关属性，再用原型链的连接实现方法的继承\n```\nclass B extends A {\n  constructor() {\n    return A.call(this);  //继承属性\n  }\n}\nA.prototype = new B;  //继承方法  \n```\nES6封装了class，extends关键字来实现继承，内部的实现原理其实依然是基于上面所讲的原型链，不过进过一层封装后，Javascript的继承得以更加简洁优雅地实现\n```\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 等同于parent.constructor(x, y)\n    this.color = color;\n  }\n  toString() {\n    return this.color + ' ' + super.toString(); // 等同于parent.toString()\n  }\n}\n```\n通过constructor来定义构造函数，用super调用父类的属性方法\n\nES6中Class充当了ES5中，构造函数在继承实现过程中的作用\n同样有原型属性prototype，以及在ES5中用来指向构造函数原型的`__proto__`属性，这个属性在ES6中的指向有一些主动的修改。\n一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法继承。\n```\nclass A extends B {}\nA.__proto__ === B;  //继承属性\nA.prototype.__proto__ === B.prototype;  //继承方法\n```\nES6的子类的`__proto__`是父类，子类的原型的`__proto__`是父类的原型\n第二条继承链理解起来没有什么问题，对应到ES5中的A.prototype = new B;A.prototype作为B构造的实例，指向构造函数B的原型B.prototype，\n但是在ES5中A.`__proto__`是指向Function.prototype的，因为每一个构造函数其实都是Function这个对象构造的，ES6中子类的`__proto__`指向父类可以实现属性的继承，在ES5中在没有用借用继承的时候由于父类属性被子类原型继承，所有的子类实例实际上都是同一个属性引用。\n在ES6中实现了子类继承父类属性，在构造实例的时候会直接拿到子类的属性，不需要查找到原型属性上面去，ES6新的静态方法和静态属性（只能在构造函数上访问）也是通过这样类的直接继承来实现，至于普通复用方法还是放到原型链上，道理和实现和ES5是一样的。\n此外我认为这里修改A.`__proto__`的指向是有意区分ES6中继承和实例化，同时建立子类和父类直接的关系，ES5的子类的构造函数通过子类的原型与父类的构造函数连接，不存在直接的关系；\n可以这么说，在ES5继承和构造实例，ES6构造实例的时候可以理解`__proto__`原型指针是用来指向构造函数的原型的，但是在ES6继承中，`__proto__`指继承自哪个类或原型，在A继承B之后，构造一个实例 var obj = new A; 会发现它所有的属性指向都是和ES5一致的。\n\n\n有个有趣的地方：ES6继承是在父类创建this对象，在子类constructor中来修饰父类的this，ES5是在子类创建this，将父类的属性方法绑定到子类，由于原生的构造函数（Function，Array等）没有this，子类无法通过call/apply(this)获得其内部属性，所以在ES5无法继承，ES6实现后可以为原生构造函数封装一些有趣的接口，比方说阮一峰老师的这个给Array实例封装一个版本记录和回滚的方法：\n```\nclass VersionedArray extends Array {\n  constructor() {\n    super();\n    this.history = [[]];\n  }\n  commit() {\n    this.history.push(this.slice());\n  }\n  revert() {\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  }\n}\n\nvar x = new VersionedArray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\nx.push(3);\nx // [1, 2, 3]\n\nx.revert();\nx // [1, 2]\n```\n最后做一个ES5和ES6的继承小结：\nES5最经典的继承方法是用组合继承的方式，原型链继承方法，借用函数继承属性，ES6也是基于这样的方式，但是封装了更优雅简洁的api，让Javascript越来越强大，修改了一些属性指向，规范了继承的操作，区分开了继承实现和实例构造，此外ES6继承还能实现更多的继承需求和场景。\n\n\n\n\n\n\n"},{"header":" HTTP缓存及众多的web储存概念之小整理","time":" 2016-08-12 01:46:57","tags":" [javascript,html]","description":" this is a article for my way of studying front-end","section":"\n缓存对于一个网站来说非常重要，可以提高网站性能，减少冗余的数据传输，增加服务器负担，web存储则给浏览器提供了更加强大的保存文件的接口。\n有相当一段时间一直混淆了HTTP缓存相关的属性，HTML5离线存储和本地储存的一些关系，最近好好地整理了一下这些Web存储相关的东西\n\n先列出一些相关属性和概念，看看能否理清它们之间的区别和联系？\n<!--more-->\n\n* manifest\n* cache-control\n* expires\n* 304(no modified)\n* ETag\n* If-None-Match\n* Last-Modified\n* If-Modified-Since\n* http-equiv\n* webstorage\n* cookie/session\n\n是不是感觉有点凌乱，那就跟着我整理的笔记走一遍吧：）\n首先说一说HTTP缓存相关的东西:\n　　\n　　\n`Cache-Control`\n每一个用HTTP请求的资源都可以在响应头用Cache-Control来给浏览器定义缓存策略，通过设置一些属性值它可以控制谁可以，在什么条件下可以缓存响应，还有缓存的有效期，这个属性的一些常用值如下\n\n`no-cache：`表示不使用缓存，先和服务器确认要返回的资源是否有修改\n`no-store：`表示禁止浏览器和所有中继缓存响应的资源\n`max-age=100：`表示缓存的有效期，单位是秒，这一段时间内，除非缓存文件发生一些变动，否则会直接使用之前的缓存，注意这段时间内是不会发Etag等方法去验证的资源有没有修改的。缓存的文件发生变动，主要有这些情况：资源名更改，资源地址更改，缓存被删除，网页强制刷新等；资源名更改，给文件名添加版本hash值，比如给image.png修改为image-hash.png，可以保证每次更新文件时用户可以重新发出请求，获取最新的资源。资源路径更改，修改文件的请求路径，比如给image.png添加查询参数修改为image.png?hash，max-age的时间设置根据每个网站的实际情况不同去设置，一种极端的做法是把这个值设置很大，然后通过修改资源名或者给资源请求地址添加查询参数，来告诉浏览器该更新资源了，一般用在很久才更新网站的情况\n`public：`用max-age即是默认public了，不用设置\n`private：`私人缓存，中继缓存不被允许，但是可以在浏览器缓存\n\n`PS：expires：`表示存在的时间，使客户端在这个设置的时间之前不用去请求资源，类似于max-age，但是expires表示的是一个固定时间，而且可能有服务器和客户端时间不一致的问题，主要用于HTTP1.0版本，在HTTP1.1版本完全可以用功能更强的Cache-Control来替代，和max-age同时存在时expiers会被覆盖掉\n`PS：http-equiv：`缓存有两种控制机制，一种是请求头信息控制，另外一种就是利用meta标签；可以在HTML文档中为meta标签设置http-equiv为相应属性名，content为值来设置缓存，例如\n`<meta http-equiv=\"Expires\" content=\"Mon, 20 Jul 2009 23:00:00 GMT\" />`，不过只对改网页的HTML文件有缓存作用，对该页面的其他资源以及其他页面的HTML文件都没有作用\n　　\n　　\n那么max-age（expires）到期之后，在no-cache下的资源会先和服务器确认返回的资源是否有修改，如何实现这一过程？\n`ETag/If-None-Match，Last-Modified/If-Modified-Since`\nETag (Entity Tag)其实就是一个验证令牌，用来标识一个资源，可能是一个hash值，也可能是一个版本号，每当资源有修改的时候ETag的值就会改变\n浏览器第一次请求之后会保存响应头的ETag值，以便下一次发送请求的时候校验Etag是否有更改。\n　　\n　　\n那么下一次浏览器如何告诉服务器本地已经存有Etag和相应的资源了呢？If-None-Match\n通过在请求头添加If-None-Match(如果存在ETag，浏览器会自动添加)，赋值为上一次请求后在本地存储的Etag值，服务器会和服务端最新资源的Etag比对，如果没有更改会直接返回304 no modified给浏览器，浏览器就直接使用本地缓存的文件\n\n`PS：Last-Modified/If-Modified-Since`的作用等同于`ETag/If-None-Match，`不过前者是通过规定一个时间来比对，最小的单位是秒，后者通过一个唯一标识符，所以可以看出来如果原站在一秒内有多次更新，那么前者就不顶用啦。\nETag的验证要优先于Last-Modified，此外ETag也是有缺点的，在分布式的环境中，Etag在不同服务器上的同步问题可能会给服务器带来一些压力。\n　　\n　　\n`HTTP缓存`是和每一个HTTP请求直接相关的，每一个请求资源的响应都有相应的缓存策略，它们往往是相似的，是否可以通过其他的机制，直接告诉浏览器去缓存哪一些文件呢？\n`HTML5离线存储`闪亮出场\n\nH5离线存储：服务器通过一份.manifest文件给浏览器提供一份完备的缓存名单，名单包括需要缓存的文件，不需要缓存的文件的列表之外，还有一些其他的功能，比如给资源设置备选的请求地址，设置404页面等\n\n实现：利用H5的标签新属性manifest，只需要在HTML文件添加`<html manifest=\"test.manifest\">，`服务器则将manifest文件的mime-type设置为text/cache-manifest类型即可，浏览器每次请求会检查`manifest`是否有更新，服务端通过修改manifest文件，即可在浏览器下一次请求资源的时候通知其更新相应的资源。\n作用：通过本地离线存储可以在没有网络的情况下访问网站事先保存的文件资源，在有网络的情况下直接使用本地资源也可以减少请求连接的压力，提高网页的加载速度，注意这里和HTTP缓存的区别，它是直接使用本地资源，请求返回的是200（from cache）,由于有manifest来统一管理，所以不需要发请求查看是否有更新，也没有过期时间。\n　\n`PS：`这里关于manifest文件自身的更新问题，还是要走HTTP缓存，或者直接不缓存这个文件。\n　　\n　　\n前面提到的概念主要都是缓存请求文件这一块的东西，它们的目的都是为了提高网页的性能，可以说是一种优化型的存储，可以给用户带来更流畅的体验\n但是我们印象中还有一种存储，它可以给我们提供更多的可能和效果的实现，是功能型的存储，如H5本地储存`Webstorage，cookie，session`\n　　\n　　\n`cookie，session`\n众所周知，HTTP是无状态的协议，每一次请求都是独立没有联系的，浏览器和服务器都没有办法维持用户的状态，判断用户是不是依然是之前的那个用户。\n很容易可以想到，在同一个用户的每个请求头添加一个唯一标识符，通过判断这个标识符就可以维持用户的一些信息和状态\n会话信息被用来作为标识符解决这个问题，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案（服务端保持状态也需要客户端保持状态，所以一般session都要基础cookie或者sessionstorage）\n\n总的来说：cookie数据放在客户端，session数据放在服务端，cookie可以设置期限，session则是关闭浏览器时销毁（cookie默认也是），cookie不安全，session可能会影响服务器性能\n\n`Cookie：`通常用Javascript封装一个setCookie的函数来创建，有大小限制，可能会导致请求头过于臃肿，浏览器发送请求时，检查本地cookie，如果该cookie声明的范围大于发送请求的url地址时，就会自动在请求上添加cookie字段\n\n`session：`服务器每次会检查浏览器请求头的session标识，如果有则将这个session id在服务器的数据库（散列表）查找，找到后才进行相应权限的操作\n如果没有这个请求标识，则为客户端新建一个，返回给客户端后，客户端可以通过cookie或者sessionstorage来保存这个session id，通过请求头的cookie字段来给服务器提供sessionId，当cookie被禁止时就需要一些其他方法，通常是采用添加到url路径中，添加表单隐藏域等方法\n\ncookie作为HTTP协议规范的一部分，主要还是用来储存用户信息的，用来和服务端交互，大小也有限制，仅仅只是一种会话级别的存储\n　　\n　　\n`localstorage，sessionstorage`\n`webstorage`为了更大的存储文件设计，与Cookie负责记录用户信息相比，webStorage专注于本地存储，通过封装好的setItem，getItem等方法即可使用\nlocalstorage是一种持久化的存储，除非主动删除，否则永远存在，sessionstorage主要用来存储会话（session），关闭浏览器就会销毁，是一种非持久化的存储\n　　\n　　\n除了上面这些的概念之外，还有诸如像IndexDB，FileSystem等存储方法，关于Web存储的知识真的非常多，看上去坑也是不少，还需要实践慢慢来掌握。\n\n\n\n\n\n\n\n\n\n"},{"header":" JavaScript关键概念理解之闭包","time":" 2016-07-10 21:59:48","tags":" [javascript]","description":" none","section":"\nJavaScript作为一种多范式编程语言，和许多函数式编程语言一样拥有闭包的概念。\n闭包是一个老生常谈的问题，前端面试必问，要理解闭包的原理，必须知道什么是词法作用域，理解词法作用域，又需要对Javascript另外两个关键概念的掌握和理解~\n\n<!--more-->\n\n#### 执行环境和作用域链\n执行环境：红宝书将执行环境称为Javascript这么编程语言最为重要的一个概念，一开始我是不服的，屌屌的闭包和原型链呢？后来一番整理，才发现原来闭包和原型链的实现都是依赖于执行环境。\n执行环境定义了变量或者函数有权访问的数据，决定了它们各自的行为，每个执行环境拥有一个变量对象来保存环境中定义的所有变量和函数。\n每个函数都有自己的执行环境，每次执行语句进入函数后，就会将相应函数的执行函数压入环境栈中，执行完函数之后就会弹出，将控制权交给原来的执行环境。\n\n作用域链：作用域链用来保证执行环境中，对所有环境有权访问的变量或者函数的有序访问。每一个执行环境会为自身的变量对象创建一个作用域链，作用域的前端始终是当前执行环境的变量对象，会一直向外延伸到全局作用环境，执行环境查询变量和函数的顺序遵循从局部到全局，一旦找到就会停止查找。\n\n执行环境和作用域是很多概念和一些实现方法的基础，在Javascript里，执行环境决定了访问的权限，作用域链决定了访问的顺序。\n\n#### 闭包和词法作用域\n闭包：闭包就是一个作用域内定义的一个函数，由于Javascript没有块级作用域，局部作用域的形成依赖于函数来实现，所以也可以说闭包是一个函数里定义的一个函数。由于闭包的一个作用就是用来访问其他函数作用域中的变量，所以它又有一种定义：闭包指有权访问另一个函数作用域中变量的一个函数。\n先看一段代码\n```\nname = 'hi';\nfunction close(){\n    name = 'hello';\n    return function sayName(){\n        console.log(name)\n    }\n}\nvar sayName = close();\nsayName();\n```\n词法作用域：在这段代码中console出来的是hello，也就是说sayName执行过程中的name值取得是close函数内部的Name，而不是外部全局环境的name；根据上面对执行环境的理解，当进入sayName这个函数之后，执行环境就由全局进入局部环境，注意到每次定义函数的同时就会生成该函数的执行环境，所以sayName是在哪里声明的，它的外部执行环境就是谁，在这里就是close这个函数的执行环境，再根据上面对作用域链的理解，sayName对于name变量的查询将到此为止，不会到全局去，所以name的值就是hello，而不是hi，简单的说，sayName这个函数所属的作用域是声明它的时候所在的作用域，而不是运行它的时候，高端地说，这就是Javascript的词法作用域。\n\n依照作用域链的原理，本来全局执行环境是没有办法访问到局部执行环境的，但是由于词法作用域的原因，使得sayName这个闭包（全局环境）拥有了访问close内部name变量（局部环境）的能力。\n\n#### 闭包和this关键字\n闭包经常会和this关键字配合使用，每个函数在被调用的时候都会自动获得两个特殊变量，一个是arguments，另一个就是this，所以在一些多层嵌套return的闭包中，无法同过this来正确获得外层的this，因为作用域链在最里层的函数找到this后就停止了，所以一般都需要用一个中间变量来存储或者用bind方法绑定外层的this指向\n```\nvar name = 'hi';\nvar obj = {\n    name:'hello';\n    getName:function(){\n        //var that = this;\n        return function(){\n            return this.name;\n        }\n    }\n}\n```\n关于this的指向问题，只需要认准this当前所在函数的调用方式即可，当函数作为一个对象的方法调用时，this指向为这个对象，当作为一个函数调用时，this在非严格模式下指向全局，严格模式下返回undefined\n\n闭包的作用：\n特权方法：通过上面的闭包的概念理解，已经可以知道闭包的一个作用就是作为一个公有方法用来访问私有变量的，有权访问私有变量和函数的公有方法也叫做特权方法；Javascript中虽然没有传统面向对象中的类，也没有私有成员的概念，不过对于一个函数而言，其函数参数，内部声明的变量或者函数就是私有的。\n```\nfunction Person(){\n    var name = 'daguo';\n    var getAge  = function(){\n        return console.log('22');\n    }\n    this.publicMethod = function(){\n        console.log(name)\n        return getAge()\n    }\n}\n```\n保留变量：通常函数的作用域和其所有变量会在函数执行结束之后就销毁，但是当这个函数返回一个闭包时，只要闭包还存在，那么声明闭包的这个作用域内的变量就不会被销毁，原因就是闭包依然保有对这些变量的引用，使它们不会被JS垃圾回收标记清除。这是一个可以利用的地方，也可能是一个造成内存泄漏的原因。所以不能过多创建闭包\n\n\n\n\n\n\n\n\n\n"},{"header":" chrome扩展程序入门手记","time":" 2016-06-14 23:08:15","tags":" [javascript,chrome]","description":" share my record after learning how to build a plugin for chrome.","section":"chrome是我非常喜欢的浏览器，它除了速度飞快，对前端代码支持友好的优点外，\n还有非常丰富的扩展程序资源，提供了大量方便强大的web页面应用插件\n这两天由于朋友的业务需求，接触了一些chrome扩展程序(即俗称插件)的有关代码\n基于对谷歌开发者文档的学习，随手记录了写chrome插件的基本方法~\n<!--more-->\n每一个基本的Chrome插件,首先都有一个manifest.json\n的配置文件用来存储插件的基本信息 \n\n``\n\"manifest_version\": 2,\n  \"name\": \"Getting started example\",\n  \"description\": \"This extension shows a Google Image search result for the current page\",\n  \"version\": \"1.0\"\n``\n\n包括manifest的版本，扩展插件的名字，描述，版本\n\n弹窗页面的信息browser_action, 在里面配置一个插件弹窗html页面代码，一般名字是popup.html，\n浏览器界面显示的扩展图标位置，以及鼠标hover的title\n\n``\n\"browser_action\": {\n    \"default_icon\": \"images/icon.png\",\n    \"default_popup\": \"popup.html\",\n    \"default_title\": \"Click here!\"\n  }\n``\n\n可选的页面注入代码，一般名字是contentscript.js，\n可选多个文件，匹配页面的matches，只对匹配到的注入代码\n\n``\n\"content_scripts\": [{\n    \"js\": [\"jquery.min.js\", \"contentscript.js\"],\n    \"matches\": [\"http://*/*\",\"https://*/*\"]\n  }]\n``\n\n还有插件要求的权限和要使用该插件的网页的匹配\n\n``\n\"permissions\": [\n    \"tabs\",\n    \"http://*/\"\n  ]\n``\n\n关于manifest的更多字段配置信息，可以查看360翻译谷歌的[开发者文档](http://open.chrome.360.cn/extension_dev/manifest.html)\n\n从上面的配置可以看到，一个简单插件除了有manifest之外\n还有一个browser_action, 即popup.html来渲染点击插件之后的弹窗页面，\n这个页面可以分离出来popup.js popup.css等文件，\n这些文件可以放在同一个根目录下，文件中的引用跟普通项目一致可以取相对路径\n\n\n如果要实现与浏览器打开页面的交互就必须还有一个注入脚本文件，\n一般取名contentscript.js，弹窗页面popup page通过相应api实现和注入脚本的交互\n再由注入脚本实现对web page的交互\n在popup page（popup.js）中的输入代码\n\n```\nchrome.tabs.query({\n      active: true\n    }, function(tab) {\n       var data = '';\n        //要传递给注入脚本文件的信息\n      chrome.tabs.sendMessage(tab[0].id, 'hello, content script, from background page. there are some data:' + data);\n});\n```\n\n第二个参数为发送的信息，在注入脚本中通过request参数拿到\n在contentscript.js中输入以下代码，开启对popup.js的信息发送监听，拿到信息request\n\n```\nchrome.extension.onMessage.addListener(function(request) {\n  //request是popup page传来的信息\n   console.log('get the message from popup.js'+request)\n   //收到popup page的信息后要做的事情\n});\n```\n\n注入脚本contentscript.js和浏览器打开的网页脚本web page运行在不同的环境之下，\n所以他们的变量名和全局对象不会有冲突，\n但是他们共享一个DOM树，也就是可以通过修改注入脚本的DOM结构来改变页面的DOM，\n这也就是注入脚本同web page交互的方式\n\n最后贴一个我练手写的一个[chrome插件](https://github.com/shudery/daguoNote)，\n实现简单的便签功能，界面用amazeUI做的，\n用React渲染，后台处理用Express搭建，数据结果直接保存一份JSON文件来管理\n"},{"header":" javascript的对象构造和原型链继承","time":" 2016-04-14 17:55:58","tags":" [javascript]","description":" javascript的对象构造和原型链继承","section":"这两天仔细地学习了JS的创建对象以及继承的方法，结合红宝石书整理了下笔记。\n（红宝石这里讲了非常多的模式，看第一遍觉得还蛮乱的）\nJavascript作为一种动态的面向对象语言，本身却没有类的概念和方法，\n在创建对象和继承方面有很多有趣的实现和方法\n<!--more-->\n## 1.原始绑定和字面量表示：\n**优点**：简洁方便\n**问题**：使用对象字面量的方法创建的对象，若重复创建会产生大量的重复代码\n```\nvar o = new Object();\no.name = 'shudery';\no.skill = function(){console.log('sayHello')};\n//这是比较老的方法，一般用下面这种简单粗暴的，直接字面量创建\n\nvar obj = {\n    sex = 'man',\n    skill = function(){console.log('tucao')} \n    ...\n}\n```\n## 2.工厂模式：\n抽象创建具体对象的过程\n**具体**：用函数来封装对象，然后调用特定接口创建对象\n**优点和问题**：解决代码重复性的问题，但是没有解决对象识别问题\n```\nfunction createObj(name){\n    var obj= {\n        name : name ,\n        skill : function(){console.log('tucao')}\n    };\n    return obj;\n}\nvar obj_1 = createObj('shudery');\nvar obj_2 = createObj('Lin'); \n//Object类型的对象\n```\n## 3.构造函数模式：\n使用`new`操作符，没有显式创建对象\n**优点**：解决了代码识别问题，可以将它构造的实例标示为特定类型\n**问题**：多次复用的方法需要在每个实例上重新创建一遍，浪费内存\n```\nfunction Myobj(name){\n        this.name = name,\n        this.skill= function(){console.log('tucao')}   \n}\nvar obj_1 =  new Myobj('shudery');\nvar obj_2 =  new Myobj('Lin');\n//对象类型名称为myObj，解决了识别的问题，用下面方法可以验证\nconsole.log(obj_1.constructor === Myobj && obj_2 instanceof Myobj);//true\n```\n这里如果怕遗漏new关键字，可以在`myObj`函数里头显示地返回一个对象，如下：\n```\nfunction Myobj(name){\n        var obj={};\n        obj.name=name,\n        obj.method= function(){\n        console.log('tucao')\n         }\n    return obj;\n}\nvar obj_1 = Myobj('shudery');\nvar obj_2 = new Myobj('shudery');\n```\n如果这么做`obj_1`的`constructor`指向的是`Object`\n这样就和工程模式一样不能识别对象，\n但是功能上两个对象相同，这也被叫寄生构造函数模式，一般不用它\n此外在构造函数模式下如果没有引用this和new，那就是稳妥构造函数模式，\n一般用在安全的环境\n\n## 4.原型模式：\n在构造函数模式下如果直接提取出方法函数到全局环境下，\n在方法变多时容易污染命名空间，\n此外不利于我们自定义的引用类型的封装。\n我们可以用JS的一大特色原型属性来挂载属性方法。\n**优点**：我们可以将复用的方法绑定到每一个构造函数定义的原型属性prototype上来，这样所有的对象实例都可以共享这个挂在这个原型下的属性和方法。\n**问题**：实例失去本身的特点和封装，公用一套属性和方法\n```\nfunction Myobj(){\n       \n}\nMyobj.prototype.name ='shudery';\nMyobj.prototype.age = '22';\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj();\n```\n也可用对象字面量形式，不过要注意顺序，字面量的形式相当于重写整个对象，\n构造函数原型的`constructor`属性（指向对象类型）会被重写为`Object`,\n而不是`Myobj`了\n```\nfunction Myobj(){\n       \n}\nvar obj =  new Myobj();//先实例化\nMyobj.prototype={\n//重写后这个原型和Myobj这个构造函数就没有关系了\n    name: 'shudery',\n    age:'22',\n    method : function(){\n    console.log('tucao')\n    }\n};\nobj.name;//undefined，联系被切断了\n```\n如果在重写之后实例化一个对象，虽然还存在联系，\n但是`obj`实例就不是`Myobj`类型了\n不在乎对象识别问题的话，也可以直接这样重写，仍能调用obj.name等属性和方法\n\n## 5.终极模式：构造函数+原型模式\n 最为常用的创建对象的方式，结合两种模式的优点，\n 实现对象属性的封装和对象方法的复用，\n平衡了对象的独立性和多态复用节省内存的问题。\n```\nfunction Myobj(name,age){\n    this.name =name;\n    this.age = age\n}\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj('shudery',22);\n```\n如此一来对象就拥有自定义的属性和可共享复用的方法啦\n有句话这样说，当我们把程序中变化的部分封装好之后，剩下的就是稳定可复用的了\n这也是很多种设计模式里推崇的，放到创建对象的方法里也是一样的做法。\n\n说完对象的创建，接下来是继承~\nJS是没有类的关键字和概念的，它的继承是基于原型链的，类似上面的原型模式\n我们先简单了解下原型链：\n\n![](https://raw.githubusercontent.com/shudery/public/master/clipboard.png)\n\n每个构造函数都有一个原型对象，构造的实例有一个指向原型对象的指针，\n如果我们把父类的实例赋值给原型对象，那么子类的原型对象就是父类的实例， \n那么这个实例还是有一个指向父类原型的指针，\n这些指针连起了子类和父类的实例（子类构造函数的原型），就是原型链。\n\n对象的方法和属性会循着原型链进行访问，直到查找到相应的属性和方法名，\n或者到达原型链的终点`Object.prototype`,这也就实现了继承\n\n\n\n\n\n\n\n\n\n\n"},{"header":" 搭建属于自己的vpn服务器","time":" 2016-06-10 21:59:48","tags":" [vpn]","description":" how to build vpn or vps by youself","section":"之前实习的时候想着有需要翻墙的时候用着公司的vpn就足够了\n但是随着马上要去工作，还有对一些国外资源的需求（资源你懂的）\n然后也前后被一些网上的vpn服务商坑过（各种掉线，不稳定）\n决定自己租用一台国外的服务器vps\n<!--more-->\n了解一番后知道了国外[搬瓦工](http://bandwagonhost.com/)和[digital ocean](www.digitalocean.com/?refcode=3491087221da)都有不错的口碑，最终选择DO,\n最便宜的512MB内存，20GB固态硬盘，1TB流量，\n\n这个好像只是防止恶意使用的，实际上流量是用不完的，\n在服务器控制版面也没有流量使用情况提示\n首先注册账号，输入邮箱密码，在邮箱收到确认邮件，\n来到Payment Methods \n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_1.png)\n\n这一项我选择的是方便快捷的PayPal，Credit不好设置\n需要预充5刀PayPal，5刀也是最便宜的服务器的月租价格，\n如果没有PayPal的话就先注册一次，比这个Credit方便多了\n注意一些老旧的银联卡号可能提示设置错误，我换了一张卡就好了\n\n然后开始选择服务器，包括价格，地点，系统，\n我选了最便宜已经够用了的5刀/月，ping后较快的美国西部服务器，\n以及比较容易操作的ubuntu系统，然后添加主机的SSH密钥，以后方便，\n\n不过也可以先跳过以后再说，买后会收到邮件，\n得到一个服务器主机Ip，root账户名，以及一个初始密码。\nvps算是有了，接下来我们在这台服务器上搭建vpn\n\n然后不得吐槽的是网页的console控制台实在有点卡卡，\n所以我用简单的putty来建立与vps的链接，也可以使用xshell等工具，\n下载putty后直接输入ip地址，保留默认端口，点击open就进入控制台了\n\n然后输入你的用户名root，然后出现password输入密码，\n这里注意啦~输入密码的时候，光标是不会动的！\n所以，慢慢输入，不要输错了，登录成功后显示一些信息\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_2.png)\n\n第一次登陆要求重置密码，分别填一次旧密码和两次新密码，注意光标还是不会移动！\n然后开始一列Linux操作，作为小白的我们就只管输入代码即可，\n不过我们也是有(yao)追(zhuan)求(bi)的小白，所以也要大概知道这些代码是个什么作用\n\n### 1、安装vpn服务\n首先我们必须在vps服务器上安装一种vpn服务，这里选择点对点隧道协议pptp,输入\n\n```\napt-get install pptpd\n```\n\n### 2、配置文件修改\n用vi编辑器打开配置文件，输入\n\n```\nvi /etc/pptpd.conf\n```\n\n没用过vi的注意啦，要编辑文件必须先输入i，进入INSERT模式，\n将光标移动到最下面更改\n\n```\nlocalip 10.0.0.1\nremoteip 10.0.0.100-200\n```\n\n有两段，localip更改为你vps服务器的ip地址，remoteip是以后分配给\n其他连到你vpn的服务器的ip，可以照着例子分配，写完后保存，\nvi的文件保存方法是先按Esc然后输入冒号:wq即可，w是写入保存，q是退出vi\n\n### 3、添加vpn账号\n用vi打开密钥文件，输入\n\n``` \nvi /etc/ppp/chap-secrets \n```\n\n依次输入 username pptpd password ### \n将username, password更换为你的vpn账号和密码，中间是服务名，\n最后一个是ip通配符，如果要建立多个vpn账号给妹子基友一起用，\n还一行依次输入即可，输完同样保存\n\n### 4、设置公共DNS服务，输入\n\n```\nvi /etc/ppp/pptpd-options\n```\n\n打开服务选项文件设置找到ms-dns并设置为\n`\nms-dns 8.8.8.8\nms-dns 8.8.4.4\n`\n\n### 5、重启pptp服务，\n重启服务，刷新配置，输入\n\n```\nservice pptpd restart\n```\n\n### 6、ip转发配置\n打开转发配置文件，输入\n\n```\nvi /etc/sysctl.conf\n```\n\n发现整个文件都带有注释符#,去掉`# net.ipv4.ip_forward = 1`\n前面的注释符#保存,为了使配置生效还需运行\n\n```\nsysctl -p\n```\n\n### 7、设置iptables\n设置并保存，运行\n\n```\niptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE && iptables-save\n```\n\n至此搭建好属于你自己的vpn，拿着账号在手机和电脑的vpn设置登录即可\n注意如果出现vpn隧道协议构建失败，检查一下网络适配器里vpn的安全属性\n勾选为以下选项\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_3.jpg)\n\n\n\n\n\n\n\n"},{"header":" Javascript开发跨平台桌面app","time":" 2016-06-23 23:32:17","tags":" [javascript,node]","description":" develop cross-platform GUI app with electron","section":"electron原本是atom shell的项目，由于集成node丰富的本地系统级API，\n提供了与操作系统交互的功能，所以归结起来，现在javascrpit的技术栈之所以如此宽广，\n要得益于NodeJS将其中浏览器的环境中分离出来\n\n不过需要特别说明的是，这里生成的桌面应用，\n实际上是Electron生成的一个由Javascrpit控制管理的迷你浏览器Chromeinum，\n它其实是一个Chrome浏览器的试验版本，当然用的也是V8的内核\n<!--more-->\n不管怎么说，这对于喜欢前端，熟悉javascript的同学来说，\n能够用前端和一点后台的知识去接触，尝试各种不同的领域，实在是不要太爽\n\nElectron的入门也符合前端知识领域的特点，几乎没有门槛，\n只要你有一点JS和Node的基础就行了，开发目录的文件层次结构也很简单，\n后面会有打包工具帮助我们一键打包生成层次比较复杂的项目文件，\n作为桌面GUI应用，当然也包括.exe的启动文件，\n\n让我们看看如何开发一个桌面应用，或者说一个能和操作本地系统的web页面的基本方法~\n你可以跟着步骤完成一些基本的文件，也可以直接下载[快速开始的demo](https://github.com/shudery/electron/archive/master.zip)\n基本的文件层次很简单，用app存放一个具体的桌面应用，具体结构是这样的\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_1.png)\n\nOutApp用来存放打包输出的exe文件\n至于为什么有两个``package.json``文件，后面打包操作时你就知道了\n\n### 1、首先安装electron\n命令行进入根目录，先用npm安装electron，如果还没有就先[安装node](https://nodejs.org/en/)\n```\nnpm install -g electron-prebuilt\n```\n### 2、生成``package.json``配置文件\n运行``npm init`` 生成一个``package.json``文件来存放应用的相关配置，这个是第一个``package.json``文件，位于外层根目录下的，运行 \n```\nnpm install --save-dev electron-prebuilt  \n```\n会在devDependencies中生成依赖信息，方便后面打包\n```\n{\n  \"name\": \"firstGUI\",\n  \"version\": \"1.0.0\",\n  \"main\": \"app/main.js\",//js入口文件\n  \"scripts\": {\n    \"build\": \"electron-packager ./app firstApp --platform=win32 --arch=x64 --out ./OutApp --version 0.37.3 --overwrite --icon=./app/img/daguo. jpg\",\n    //打包命令，后面打包可以简化代码\n  },\n  \"devDependencies\": {\n    \"electron-prebuilt\": \"^1.2.0\"\n  }\n}\n```\n### 3、新建main.js\n生成一个入口的js文件来作为控制GUI窗口的主进程程序\n```\nconst electron = require('electron');\n// 控制应用生命周期的模块\nconst {app} = electron;\n// 创建本地浏览器窗口的模块\nconst {BrowserWindow} = electron;\n// 指向窗口对象的一个全局引用\nlet win;\n\nfunction createWindow() {\n\n // 创建一个新的浏览器窗口\n  win = new BrowserWindow({ width: 360, height: 572 });\n // 并且装载应用的index.html页面,注意路径\n  win.loadURL('file://'+__dirname+'/html/index.html');\n // 当窗口关闭时调用的方法\n\n  win.on('closed', () => {\n  // 解除窗口对象的引用，通常而言如果应用支持多个窗口的话，你会在一个数组里\n  // 存放窗口对象，在窗口关闭的时候应当删除相应的元素。\n  win = null;\n  });\n}\n\n// 当Electron完成初始化并且已经创建了浏览器窗口，则该方法将会被调用。\n// 有些API只能在该事件发生后才能被使用。\napp.on('ready', createWindow);\n\n// 当所有的窗口被关闭后退出应用\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\napp.on('activate', () => {\n  if (win === null) {\n    createWindow();\n  }\n});\n// 在这个文件后面你可以直接包含你应用特定的由主进程运行的代码。\n// 也可以把这些代码放在另一个文件中然后在这里导入。\n```\n### 4、index.html\nGUI窗口（web页面）渲染的Html文件\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>firstGUI</title>\n  </head>\n  <body>\n    <h1 style=>Hello World!</h1>\n  </body>\n</html>\n```\n\n### 5、运行桌面app\n大公告成，没错就是如此之快，运行``electron .``（跟一个空格和小点），或者``electron app/main``\n打开制作好的GUI界面，so cool~\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_2.png)\n\n### 6、进行打包\n既然是桌面应用，那肯定是要一键运行的，不需要安装什么依赖模块，\n也不需要运行命令行程序的，所以为了提升逼格，让更多的人可以方便实用你的桌面app，\n需要对app文件夹进行打包，安装打包程序 ``electron-packager``\n```\nnpm install --save-dev electron-packager\n```\n打包的基本命令是 \n```\nelectron-packager <location of project> <name of project> <platform> <architecture> <electron version><optional options>\n```\n上面已经在``package.json``的script里配置了简化的命令，可以根据自身情况对名称，操作系统，应用图标进行修改，\n注意啦开始打包前，一定要复制一份``package.json``到app文件，\n前面说了桌面应用不用下载依赖，其实是因为打包的时候就将依赖一同打包到文件包里了，\n所以我们要打包app文件夹下的文件，需要一个``package.json``  来说明依赖项，注意修改里面的路径，要往下一级，然后运行``npm packager``\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_3.png)\n\n完成打包后可以看到OutApp里头已经有了相应的文件，\n运行里面的exe文件会生成和本地测试时一样的GUI窗口~\n\n\n一个简单的基于前端技术栈的桌面app算是完成了，后续的asar文件加密，\n用nsis制作一个安装引导等等~有兴趣的可以继续完善~\n\n一个桌面级app当然不是用来显示``hello world``的，那样和web页面有什么区别，\n这里只是我入门的一个学习记录，一个基于electron的桌面应用\n还有着非常丰富的与系统交互功能可以设计和开发~\n更加详细的用法和配置有兴趣的同学不妨看看官方的[api演示文档](http://electron.atom.io/)，\n它也是一个基于electron做的桌面app\n\n"},{"header":" 最近的npm模块风波","time":" 2016-04-04 17:53:38","tags":" [npm,modules]","description":" npm导致我们不会写代码了？","section":"最近，前端圈子有件事闹得沸沸扬扬，有一个叫做`leftpad`的npm模块被作者撤下，\n导致一系列引用该模板的项目出现问题。\n\n其实本来大家对这件事的重点应该是关于NPM管理者对于模块作者著作权的保护不周上的，\n但是可能由于这个模块的特殊性和他造成的影响之间的对比太强烈，\n让大家都把注意力放到了这个模块本身和引用这个模块的做法上来了。\n<!--more-->\n**这个模块只有短短十一行，仅仅实现一个简单的字符串左侧填充的功能！**\n\n如此简单的模块为什么那么多项目都要引用他呢？\n其实如果不出现作者`unpublish`的问题，大家不会对这样的做法有太多的疑问，\n因为NodeJS的特色就是如此嘛，而且npm的引用和配置下载也非常方便， \n即使是再简单的模块，我若引用也就是`require`一下，然后将依赖写到json里，\n还是比自己写实现函数要方便一些，虽然方便得不多。\n总之就是不出事还好，一出事，那不好意思就得有人负责，\n这件事没有主要负责人，那么就得有问题被抛出。\n\n所以最近这几天抛出的最多的一个问题就是，**对于简单的代码我们仍要引用模块吗？**\n\n\n首先我觉得像这次又模块被作者下架，这毕竟是少数事件，\n我们不应该讨论对于npm的信任问题，这样会使我们在引用模块时畏手畏脚，\n有人说你简单的函数方法自己写嘛，复杂的再引用别人的，\n就是减少引用，就减少了出了事摊上你的概率，\n我只想说在小概率事件中减小该事件的概率--无关痛痒。\n\n\n总之我对npm模块的引用还是持比较乐观的态度，\nnpm的社区非常繁荣，拥有大批的贡献者，我觉得就是即使是再小的一个模块，\n你写出来了就可以`publish`上去，就可以给别人引用，每个人都有发光发热的机会，\n这给作者多大的鼓励和成就感啊，别人用后也会给你反馈，你再去不断改善，\n大家也可以在`review`其他模块代码中得到非常多的编程技术和思想。\n\n\n与对引用小模块的质疑相反，我觉得引用大模块的问题似乎更多，\n一个项目中引用的大模块往往并不需要里面的很多功能，\n所以NodeJS才在新版中将核心模块分割成多份，大家需要用啥再引用那个模块，\n这样就避免了项目庞大引起的各模块之间可能出现的兼容问题，\n也不至于使得代码太臃肿，至于对小模块引用可能导致require和模块依赖过大，\n但是代码依然比较精简，代码的冗余也比较少。\n\n\n最后，关于npm模块的引用，小模块如果有用过或已经知道的精巧模块，\n不仿大胆引用，若是不清楚也不必特意查询，简单的功能自己想方法实现即可，\n大模块如果与项目的配合不好，该分解的最好分解，结合项目和自身的编程习惯，\n高效的完成项目。\n以上仅仅是个人愚昧的一些看法。\n\n"},{"header":" 用hexo搭建一个博客","time":" 2016-05-05 12:00:33","tags":" [hexo,node,git]","description":" 如何用hexo来搭建一个博客","section":"hexo出自一位台湾大学生之手，是如今搭建，管理博客，发布文章的非常好用的工具，\n之前一直想搭建一个不依赖后台，便于管理和发布的博客，在朋友推荐下用了hexo\n确实是简单粗暴好用~\n基于hexo的博客搭建，对于已经配备了Node环境和git的前端开发人士，\n搭建出一个博客那就是分分钟的事情，即使还没有弄好这些也不难搭建，\n下面就从头大致说一说搭建的流程。\n<!--more-->\n### 创建一个github账号和博客\nhexo搭建的博客是一个静态页面，可以直接托放到github上面的服务器上，\n不需要拥有自己的服务器，所以我们要先有一个github账号，\n然后需要生成一个github的博客，之后我们用自己定制的hexo博客来替换它，\n如何搭建github技术博客可以看看这篇:[创建GitHub技术博客全攻略](http://blog.csdn.net/renfufei/article/details/37725057/)\n### 搭建Node环境\n我们还需要一个运行hexo和调试的环境，就是用Nodejs，\n在[官网地址](https://nodejs.org/en/)选一个稳定版或者开发版一键安装好环境。\n### 安装Hexo，生成文章\n准备好nodejs之后打开命令行使用Node的包管理工具npm,直接在命令行运行\n``\nnpm install -g hexo\n``\n\n下载hexo，然后再在相应的目录运行\n``\nhexo init\n``\n\n即可一键生成文件结构，你可以看到在source/_posts里面有一篇默认的helloworld.md文章，\n在themes里面有一个默认的主题landscape，再继续运行\n``\nhexo generate\n``\n\n### 调试，部署到git\n上面过程之后即可生成一个Public文件，里面会有你的文章内容，然后就可以运行\n``\nhexo server\n``\n\n启动localhost:4000，在浏览器输入地址就可以看到你的博客效果了，\n如果你对默认的配置都满意的话下一步就是运行\n``\nhexo deploy\n``\n\n将内容部署到github上面去了，但是我们好像还没有建立hexo和我们账号github仓库的链接，\n所以要在_config.yml最下面进行一些配置\n```\ndeploy:\n  type: git\n  repo: git@github.com:shudery/shudery.github.io.git # 换成你的博客仓库地址\n  branch: master\n```\n然后再hexo deploy即可完成部署，注意用ssh地址可以免去输入密码的繁琐，\n当然前提是要先生成ssh密钥，并且在你的github上面添加这个ssh密钥~\nhexo博客就已经搭建完成，可以在shudery.github.io上面看到博客页面和文章效果\n### 添加文章，更换主题，修改配置\n基本的东西就是这样，接下来我们可以在_posts里面以markdown的写作形式写文章，\n然后通过同样的方式生成，部署，可以直接在_posts里新建md文件，\n也可以用运行\n``\nhexo new [fileStyle] [fileName]\n``\n\n的方式来生成文件，后者会以scaffolds中对应的fileStyle的形式，\n给你生成一个fileName的md文件，里面会包括一些开头的默认字段，\n会方便记录一些文章的信息，我们还可以在[官网主题](https://hexo.io/themes/)里找一个更加符合心意的主题，\n然后直接git clone/ctrl+c 到我们hexo/themes下面，\n然后在hexo/_config.yml中的 theme:landscape 改为你下载好的主题名，\n然后你会发现主题文件夹里还有一个_config.yml 用来修改主题的一些相关配置，\n你可以参考你下载主题的github,或者官网的介绍来设置这些配置~\n### 完善博客\n最后你可以根据自己的喜好和需求为博客添加一些你喜欢的挂件和工具，\n我自己加了多说评论，百度统计，还有就是换了一个逼格高一点的域名，\n通过添加CNAME域名解析，重定向到github.io的博客地址上面。\n\n搭建过程中一些tips~\n\n* hexo clean会清理缓存和Public文件夹一般是在hexo generate之前使用，但是不用没啥问题\n* hexo/_config.yml对于hexo非常重要，但是如果去掉_config.yml你会发现还是依然能运行各种命令\n* 然而一般运行时报错都是config配置有问题，而且很不好定位，\n  所以可以注释掉config.yml里面你觉得应该不会导致报错的配置，然后再运行看结果，\n  重复几次就可以定位到问题了，这对一开始没有什么经验的人来说是一个可行的debug方法。\n* 在做域名重定向的时候，域名解析的CNAME需要指向github.io，\n  此外还要在hexo/source下面也建立一个CNAME文件指向你的设置了重定向的域名地址才行"},{"header":" ES5和ES6中对于继承的实现方法","time":" 2016-07-23 23:32:17","tags":" [javascript]","description":" develop cross-platform GUI app with electron","section":"\n在ES5继承的实现非常有趣的，由于没有传统面向对象类的概念，Javascript利用原型链的特性来实现继承，这其中有很多的属性指向和需要注意的地方。\n原型链的特点和实现已经在之前的一篇整理说过了，就是通过将子类构造函数的原型作为父类构造函数的实例，这样就连通了子类-子类原型-父类，原型链的特点就是逐层查找，从子类开始一直往上直到所有对象的原型Object.prototype，找到属性方法之后就会停止查找，所以下层的属性方法会覆盖上层。\n<!--more-->\n一个基本的基于原型链的继承过程大概是这样的：\n```\n//先来个父类，带些属性\nfunction Super(){\n    this.flag = true;\n}\n//为了提高复用性，方法绑定在父类原型属性上\nSuper.prototype.getFlag = function(){\n    return this.flag;\n}\n//来个子类\nfunction Sub(){\n    this.subFlag = false;\n}\n//实现继承\nSub.prototype = new Super;\n//给子类添加子类特有的方法，注意顺序要在继承之后\nSub.prototype.getSubFlag = function(){\n    return this.subFlag;\n}\n//构造实例\nvar es5 = new Sub;\n```\n原型链实现的继承主要有几个问题：\n1、本来我们为了构造函数属性的封装私有性，方法的复用性，提倡将属性声明在构造函数内，而将方法绑定在原型对象上，但是现在子类的原型是父类的一个实例，自然父类的属性就变成子类原型的属性了；\n这就会带来一个问题，我们知道构造函数的原型属性在所有构造的实例中是共享的，所以原型中属性的改变会反应到所有的实例上，这就违背了我们想要属性私有化的初衷；\n2、创建子类的实例时，不能向父类的构造函数传递参数\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n   this.subFlag = false;\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nobj.flag = flase;  //修改之后，由于是原型上的属性，之后创建的所有实例都会受到影响\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //false；\n```\n为了解决以上两个问题，有一个叫借用构造函数的方法\n只需要在子类构造函数内部使用apply或者call来调用父类的函数即可在实现属性继承的同时，又能传递参数，又能让实例不互相影响\n```\nfunction Super(){\n    this.flag = true;\n}\nfunction Sub(){\n    Super.call(this)  //如果父类可以需要接收参数，这里也可以直接传递\n}\nvar obj = new Sub();\nobj.flag = flase;\nvar obj_2 = new Sub();\nconsole.log(obj.flag)  //依然是true，不会相互影响\n```\n结合借用构造函数和原型链的方法，可以实现比较完美的继承方法，可以称为组合继承：\n```\nfunction Super(){\n    this.flag = true;\n}\nSuper.prototype.getFlag = function(){\n    return this.flag;     //继承方法\n}\nfunction Sub(){\n    this.subFlag = flase\n    Super.call(this)    //继承属性\n}\nSub.prototype = new Super;\nvar obj = new Sub();\nSuper.prototype.getSubFlag = function(){\n    return this.flag;\n}\n```\n这里还有个小问题，Sub.prototype = new Super;  会导致Sub.prototype的constructor指向Super;\n然而constructor的定义是要指向原型属性对应的构造函数的，Sub.prototype是Sub构造函数的原型，所以应该添加一句纠正：\nSub.prototype.constructor = Sub;\n\n看完ES5的实现，再来看看ES6的继承实现方法，其内部其实也是ES5组合继承的方式，通过call借用构造函数，在A类构造函数中调用相关属性，再用原型链的连接实现方法的继承\n```\nclass B extends A {\n  constructor() {\n    return A.call(this);  //继承属性\n  }\n}\nA.prototype = new B;  //继承方法  \n```\nES6封装了class，extends关键字来实现继承，内部的实现原理其实依然是基于上面所讲的原型链，不过进过一层封装后，Javascript的继承得以更加简洁优雅地实现\n```\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 等同于parent.constructor(x, y)\n    this.color = color;\n  }\n  toString() {\n    return this.color + ' ' + super.toString(); // 等同于parent.toString()\n  }\n}\n```\n通过constructor来定义构造函数，用super调用父类的属性方法\n\nES6中Class充当了ES5中，构造函数在继承实现过程中的作用\n同样有原型属性prototype，以及在ES5中用来指向构造函数原型的`__proto__`属性，这个属性在ES6中的指向有一些主动的修改。\n一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法继承。\n```\nclass A extends B {}\nA.__proto__ === B;  //继承属性\nA.prototype.__proto__ === B.prototype;  //继承方法\n```\nES6的子类的`__proto__`是父类，子类的原型的`__proto__`是父类的原型\n第二条继承链理解起来没有什么问题，对应到ES5中的A.prototype = new B;A.prototype作为B构造的实例，指向构造函数B的原型B.prototype，\n但是在ES5中A.`__proto__`是指向Function.prototype的，因为每一个构造函数其实都是Function这个对象构造的，ES6中子类的`__proto__`指向父类可以实现属性的继承，在ES5中在没有用借用继承的时候由于父类属性被子类原型继承，所有的子类实例实际上都是同一个属性引用。\n在ES6中实现了子类继承父类属性，在构造实例的时候会直接拿到子类的属性，不需要查找到原型属性上面去，ES6新的静态方法和静态属性（只能在构造函数上访问）也是通过这样类的直接继承来实现，至于普通复用方法还是放到原型链上，道理和实现和ES5是一样的。\n此外我认为这里修改A.`__proto__`的指向是有意区分ES6中继承和实例化，同时建立子类和父类直接的关系，ES5的子类的构造函数通过子类的原型与父类的构造函数连接，不存在直接的关系；\n可以这么说，在ES5继承和构造实例，ES6构造实例的时候可以理解`__proto__`原型指针是用来指向构造函数的原型的，但是在ES6继承中，`__proto__`指继承自哪个类或原型，在A继承B之后，构造一个实例 var obj = new A; 会发现它所有的属性指向都是和ES5一致的。\n\n\n有个有趣的地方：ES6继承是在父类创建this对象，在子类constructor中来修饰父类的this，ES5是在子类创建this，将父类的属性方法绑定到子类，由于原生的构造函数（Function，Array等）没有this，子类无法通过call/apply(this)获得其内部属性，所以在ES5无法继承，ES6实现后可以为原生构造函数封装一些有趣的接口，比方说阮一峰老师的这个给Array实例封装一个版本记录和回滚的方法：\n```\nclass VersionedArray extends Array {\n  constructor() {\n    super();\n    this.history = [[]];\n  }\n  commit() {\n    this.history.push(this.slice());\n  }\n  revert() {\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  }\n}\n\nvar x = new VersionedArray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\nx.push(3);\nx // [1, 2, 3]\n\nx.revert();\nx // [1, 2]\n```\n最后做一个ES5和ES6的继承小结：\nES5最经典的继承方法是用组合继承的方式，原型链继承方法，借用函数继承属性，ES6也是基于这样的方式，但是封装了更优雅简洁的api，让Javascript越来越强大，修改了一些属性指向，规范了继承的操作，区分开了继承实现和实例构造，此外ES6继承还能实现更多的继承需求和场景。\n\n\n\n\n\n\n"},{"header":" HTTP缓存及众多的web储存概念之小整理","time":" 2016-08-12 01:46:57","tags":" [javascript,html]","description":" this is a article for my way of studying front-end","section":"\n缓存对于一个网站来说非常重要，可以提高网站性能，减少冗余的数据传输，增加服务器负担，web存储则给浏览器提供了更加强大的保存文件的接口。\n有相当一段时间一直混淆了HTTP缓存相关的属性，HTML5离线存储和本地储存的一些关系，最近好好地整理了一下这些Web存储相关的东西\n\n先列出一些相关属性和概念，看看能否理清它们之间的区别和联系？\n<!--more-->\n\n* manifest\n* cache-control\n* expires\n* 304(no modified)\n* ETag\n* If-None-Match\n* Last-Modified\n* If-Modified-Since\n* http-equiv\n* webstorage\n* cookie/session\n\n是不是感觉有点凌乱，那就跟着我整理的笔记走一遍吧：）\n首先说一说HTTP缓存相关的东西:\n　　\n　　\n`Cache-Control`\n每一个用HTTP请求的资源都可以在响应头用Cache-Control来给浏览器定义缓存策略，通过设置一些属性值它可以控制谁可以，在什么条件下可以缓存响应，还有缓存的有效期，这个属性的一些常用值如下\n\n`no-cache：`表示不使用缓存，先和服务器确认要返回的资源是否有修改\n`no-store：`表示禁止浏览器和所有中继缓存响应的资源\n`max-age=100：`表示缓存的有效期，单位是秒，这一段时间内，除非缓存文件发生一些变动，否则会直接使用之前的缓存，注意这段时间内是不会发Etag等方法去验证的资源有没有修改的。缓存的文件发生变动，主要有这些情况：资源名更改，资源地址更改，缓存被删除，网页强制刷新等；资源名更改，给文件名添加版本hash值，比如给image.png修改为image-hash.png，可以保证每次更新文件时用户可以重新发出请求，获取最新的资源。资源路径更改，修改文件的请求路径，比如给image.png添加查询参数修改为image.png?hash，max-age的时间设置根据每个网站的实际情况不同去设置，一种极端的做法是把这个值设置很大，然后通过修改资源名或者给资源请求地址添加查询参数，来告诉浏览器该更新资源了，一般用在很久才更新网站的情况\n`public：`用max-age即是默认public了，不用设置\n`private：`私人缓存，中继缓存不被允许，但是可以在浏览器缓存\n\n`PS：expires：`表示存在的时间，使客户端在这个设置的时间之前不用去请求资源，类似于max-age，但是expires表示的是一个固定时间，而且可能有服务器和客户端时间不一致的问题，主要用于HTTP1.0版本，在HTTP1.1版本完全可以用功能更强的Cache-Control来替代，和max-age同时存在时expiers会被覆盖掉\n`PS：http-equiv：`缓存有两种控制机制，一种是请求头信息控制，另外一种就是利用meta标签；可以在HTML文档中为meta标签设置http-equiv为相应属性名，content为值来设置缓存，例如\n`<meta http-equiv=\"Expires\" content=\"Mon, 20 Jul 2009 23:00:00 GMT\" />`，不过只对改网页的HTML文件有缓存作用，对该页面的其他资源以及其他页面的HTML文件都没有作用\n　　\n　　\n那么max-age（expires）到期之后，在no-cache下的资源会先和服务器确认返回的资源是否有修改，如何实现这一过程？\n`ETag/If-None-Match，Last-Modified/If-Modified-Since`\nETag (Entity Tag)其实就是一个验证令牌，用来标识一个资源，可能是一个hash值，也可能是一个版本号，每当资源有修改的时候ETag的值就会改变\n浏览器第一次请求之后会保存响应头的ETag值，以便下一次发送请求的时候校验Etag是否有更改。\n　　\n　　\n那么下一次浏览器如何告诉服务器本地已经存有Etag和相应的资源了呢？If-None-Match\n通过在请求头添加If-None-Match(如果存在ETag，浏览器会自动添加)，赋值为上一次请求后在本地存储的Etag值，服务器会和服务端最新资源的Etag比对，如果没有更改会直接返回304 no modified给浏览器，浏览器就直接使用本地缓存的文件\n\n`PS：Last-Modified/If-Modified-Since`的作用等同于`ETag/If-None-Match，`不过前者是通过规定一个时间来比对，最小的单位是秒，后者通过一个唯一标识符，所以可以看出来如果原站在一秒内有多次更新，那么前者就不顶用啦。\nETag的验证要优先于Last-Modified，此外ETag也是有缺点的，在分布式的环境中，Etag在不同服务器上的同步问题可能会给服务器带来一些压力。\n　　\n　　\n`HTTP缓存`是和每一个HTTP请求直接相关的，每一个请求资源的响应都有相应的缓存策略，它们往往是相似的，是否可以通过其他的机制，直接告诉浏览器去缓存哪一些文件呢？\n`HTML5离线存储`闪亮出场\n\nH5离线存储：服务器通过一份.manifest文件给浏览器提供一份完备的缓存名单，名单包括需要缓存的文件，不需要缓存的文件的列表之外，还有一些其他的功能，比如给资源设置备选的请求地址，设置404页面等\n\n实现：利用H5的标签新属性manifest，只需要在HTML文件添加`<html manifest=\"test.manifest\">，`服务器则将manifest文件的mime-type设置为text/cache-manifest类型即可，浏览器每次请求会检查`manifest`是否有更新，服务端通过修改manifest文件，即可在浏览器下一次请求资源的时候通知其更新相应的资源。\n作用：通过本地离线存储可以在没有网络的情况下访问网站事先保存的文件资源，在有网络的情况下直接使用本地资源也可以减少请求连接的压力，提高网页的加载速度，注意这里和HTTP缓存的区别，它是直接使用本地资源，请求返回的是200（from cache）,由于有manifest来统一管理，所以不需要发请求查看是否有更新，也没有过期时间。\n　\n`PS：`这里关于manifest文件自身的更新问题，还是要走HTTP缓存，或者直接不缓存这个文件。\n　　\n　　\n前面提到的概念主要都是缓存请求文件这一块的东西，它们的目的都是为了提高网页的性能，可以说是一种优化型的存储，可以给用户带来更流畅的体验\n但是我们印象中还有一种存储，它可以给我们提供更多的可能和效果的实现，是功能型的存储，如H5本地储存`Webstorage，cookie，session`\n　　\n　　\n`cookie，session`\n众所周知，HTTP是无状态的协议，每一次请求都是独立没有联系的，浏览器和服务器都没有办法维持用户的状态，判断用户是不是依然是之前的那个用户。\n很容易可以想到，在同一个用户的每个请求头添加一个唯一标识符，通过判断这个标识符就可以维持用户的一些信息和状态\n会话信息被用来作为标识符解决这个问题，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案（服务端保持状态也需要客户端保持状态，所以一般session都要基础cookie或者sessionstorage）\n\n总的来说：cookie数据放在客户端，session数据放在服务端，cookie可以设置期限，session则是关闭浏览器时销毁（cookie默认也是），cookie不安全，session可能会影响服务器性能\n\n`Cookie：`通常用Javascript封装一个setCookie的函数来创建，有大小限制，可能会导致请求头过于臃肿，浏览器发送请求时，检查本地cookie，如果该cookie声明的范围大于发送请求的url地址时，就会自动在请求上添加cookie字段\n\n`session：`服务器每次会检查浏览器请求头的session标识，如果有则将这个session id在服务器的数据库（散列表）查找，找到后才进行相应权限的操作\n如果没有这个请求标识，则为客户端新建一个，返回给客户端后，客户端可以通过cookie或者sessionstorage来保存这个session id，通过请求头的cookie字段来给服务器提供sessionId，当cookie被禁止时就需要一些其他方法，通常是采用添加到url路径中，添加表单隐藏域等方法\n\ncookie作为HTTP协议规范的一部分，主要还是用来储存用户信息的，用来和服务端交互，大小也有限制，仅仅只是一种会话级别的存储\n　　\n　　\n`localstorage，sessionstorage`\n`webstorage`为了更大的存储文件设计，与Cookie负责记录用户信息相比，webStorage专注于本地存储，通过封装好的setItem，getItem等方法即可使用\nlocalstorage是一种持久化的存储，除非主动删除，否则永远存在，sessionstorage主要用来存储会话（session），关闭浏览器就会销毁，是一种非持久化的存储\n　　\n　　\n除了上面这些的概念之外，还有诸如像IndexDB，FileSystem等存储方法，关于Web存储的知识真的非常多，看上去坑也是不少，还需要实践慢慢来掌握。\n\n\n\n\n\n\n\n\n\n"},{"header":" JavaScript关键概念理解之闭包","time":" 2016-07-10 21:59:48","tags":" [javascript]","description":" none","section":"\nJavaScript作为一种多范式编程语言，和许多函数式编程语言一样拥有闭包的概念。\n闭包是一个老生常谈的问题，前端面试必问，要理解闭包的原理，必须知道什么是词法作用域，理解词法作用域，又需要对Javascript另外两个关键概念的掌握和理解~\n\n<!--more-->\n\n#### 执行环境和作用域链\n执行环境：红宝书将执行环境称为Javascript这么编程语言最为重要的一个概念，一开始我是不服的，屌屌的闭包和原型链呢？后来一番整理，才发现原来闭包和原型链的实现都是依赖于执行环境。\n执行环境定义了变量或者函数有权访问的数据，决定了它们各自的行为，每个执行环境拥有一个变量对象来保存环境中定义的所有变量和函数。\n每个函数都有自己的执行环境，每次执行语句进入函数后，就会将相应函数的执行函数压入环境栈中，执行完函数之后就会弹出，将控制权交给原来的执行环境。\n\n作用域链：作用域链用来保证执行环境中，对所有环境有权访问的变量或者函数的有序访问。每一个执行环境会为自身的变量对象创建一个作用域链，作用域的前端始终是当前执行环境的变量对象，会一直向外延伸到全局作用环境，执行环境查询变量和函数的顺序遵循从局部到全局，一旦找到就会停止查找。\n\n执行环境和作用域是很多概念和一些实现方法的基础，在Javascript里，执行环境决定了访问的权限，作用域链决定了访问的顺序。\n\n#### 闭包和词法作用域\n闭包：闭包就是一个作用域内定义的一个函数，由于Javascript没有块级作用域，局部作用域的形成依赖于函数来实现，所以也可以说闭包是一个函数里定义的一个函数。由于闭包的一个作用就是用来访问其他函数作用域中的变量，所以它又有一种定义：闭包指有权访问另一个函数作用域中变量的一个函数。\n先看一段代码\n```\nname = 'hi';\nfunction close(){\n    name = 'hello';\n    return function sayName(){\n        console.log(name)\n    }\n}\nvar sayName = close();\nsayName();\n```\n词法作用域：在这段代码中console出来的是hello，也就是说sayName执行过程中的name值取得是close函数内部的Name，而不是外部全局环境的name；根据上面对执行环境的理解，当进入sayName这个函数之后，执行环境就由全局进入局部环境，注意到每次定义函数的同时就会生成该函数的执行环境，所以sayName是在哪里声明的，它的外部执行环境就是谁，在这里就是close这个函数的执行环境，再根据上面对作用域链的理解，sayName对于name变量的查询将到此为止，不会到全局去，所以name的值就是hello，而不是hi，简单的说，sayName这个函数所属的作用域是声明它的时候所在的作用域，而不是运行它的时候，高端地说，这就是Javascript的词法作用域。\n\n依照作用域链的原理，本来全局执行环境是没有办法访问到局部执行环境的，但是由于词法作用域的原因，使得sayName这个闭包（全局环境）拥有了访问close内部name变量（局部环境）的能力。\n\n#### 闭包和this关键字\n闭包经常会和this关键字配合使用，每个函数在被调用的时候都会自动获得两个特殊变量，一个是arguments，另一个就是this，所以在一些多层嵌套return的闭包中，无法同过this来正确获得外层的this，因为作用域链在最里层的函数找到this后就停止了，所以一般都需要用一个中间变量来存储或者用bind方法绑定外层的this指向\n```\nvar name = 'hi';\nvar obj = {\n    name:'hello';\n    getName:function(){\n        //var that = this;\n        return function(){\n            return this.name;\n        }\n    }\n}\n```\n关于this的指向问题，只需要认准this当前所在函数的调用方式即可，当函数作为一个对象的方法调用时，this指向为这个对象，当作为一个函数调用时，this在非严格模式下指向全局，严格模式下返回undefined\n\n闭包的作用：\n特权方法：通过上面的闭包的概念理解，已经可以知道闭包的一个作用就是作为一个公有方法用来访问私有变量的，有权访问私有变量和函数的公有方法也叫做特权方法；Javascript中虽然没有传统面向对象中的类，也没有私有成员的概念，不过对于一个函数而言，其函数参数，内部声明的变量或者函数就是私有的。\n```\nfunction Person(){\n    var name = 'daguo';\n    var getAge  = function(){\n        return console.log('22');\n    }\n    this.publicMethod = function(){\n        console.log(name)\n        return getAge()\n    }\n}\n```\n保留变量：通常函数的作用域和其所有变量会在函数执行结束之后就销毁，但是当这个函数返回一个闭包时，只要闭包还存在，那么声明闭包的这个作用域内的变量就不会被销毁，原因就是闭包依然保有对这些变量的引用，使它们不会被JS垃圾回收标记清除。这是一个可以利用的地方，也可能是一个造成内存泄漏的原因。所以不能过多创建闭包\n\n\n\n\n\n\n\n\n\n"},{"header":" chrome扩展程序入门手记","time":" 2016-06-14 23:08:15","tags":" [javascript,chrome]","description":" share my record after learning how to build a plugin for chrome.","section":"chrome是我非常喜欢的浏览器，它除了速度飞快，对前端代码支持友好的优点外，\n还有非常丰富的扩展程序资源，提供了大量方便强大的web页面应用插件\n这两天由于朋友的业务需求，接触了一些chrome扩展程序(即俗称插件)的有关代码\n基于对谷歌开发者文档的学习，随手记录了写chrome插件的基本方法~\n<!--more-->\n每一个基本的Chrome插件,首先都有一个manifest.json\n的配置文件用来存储插件的基本信息 \n\n``\n\"manifest_version\": 2,\n  \"name\": \"Getting started example\",\n  \"description\": \"This extension shows a Google Image search result for the current page\",\n  \"version\": \"1.0\"\n``\n\n包括manifest的版本，扩展插件的名字，描述，版本\n\n弹窗页面的信息browser_action, 在里面配置一个插件弹窗html页面代码，一般名字是popup.html，\n浏览器界面显示的扩展图标位置，以及鼠标hover的title\n\n``\n\"browser_action\": {\n    \"default_icon\": \"images/icon.png\",\n    \"default_popup\": \"popup.html\",\n    \"default_title\": \"Click here!\"\n  }\n``\n\n可选的页面注入代码，一般名字是contentscript.js，\n可选多个文件，匹配页面的matches，只对匹配到的注入代码\n\n``\n\"content_scripts\": [{\n    \"js\": [\"jquery.min.js\", \"contentscript.js\"],\n    \"matches\": [\"http://*/*\",\"https://*/*\"]\n  }]\n``\n\n还有插件要求的权限和要使用该插件的网页的匹配\n\n``\n\"permissions\": [\n    \"tabs\",\n    \"http://*/\"\n  ]\n``\n\n关于manifest的更多字段配置信息，可以查看360翻译谷歌的[开发者文档](http://open.chrome.360.cn/extension_dev/manifest.html)\n\n从上面的配置可以看到，一个简单插件除了有manifest之外\n还有一个browser_action, 即popup.html来渲染点击插件之后的弹窗页面，\n这个页面可以分离出来popup.js popup.css等文件，\n这些文件可以放在同一个根目录下，文件中的引用跟普通项目一致可以取相对路径\n\n\n如果要实现与浏览器打开页面的交互就必须还有一个注入脚本文件，\n一般取名contentscript.js，弹窗页面popup page通过相应api实现和注入脚本的交互\n再由注入脚本实现对web page的交互\n在popup page（popup.js）中的输入代码\n\n```\nchrome.tabs.query({\n      active: true\n    }, function(tab) {\n       var data = '';\n        //要传递给注入脚本文件的信息\n      chrome.tabs.sendMessage(tab[0].id, 'hello, content script, from background page. there are some data:' + data);\n});\n```\n\n第二个参数为发送的信息，在注入脚本中通过request参数拿到\n在contentscript.js中输入以下代码，开启对popup.js的信息发送监听，拿到信息request\n\n```\nchrome.extension.onMessage.addListener(function(request) {\n  //request是popup page传来的信息\n   console.log('get the message from popup.js'+request)\n   //收到popup page的信息后要做的事情\n});\n```\n\n注入脚本contentscript.js和浏览器打开的网页脚本web page运行在不同的环境之下，\n所以他们的变量名和全局对象不会有冲突，\n但是他们共享一个DOM树，也就是可以通过修改注入脚本的DOM结构来改变页面的DOM，\n这也就是注入脚本同web page交互的方式\n\n最后贴一个我练手写的一个[chrome插件](https://github.com/shudery/daguoNote)，\n实现简单的便签功能，界面用amazeUI做的，\n用React渲染，后台处理用Express搭建，数据结果直接保存一份JSON文件来管理\n"},{"header":" javascript的对象构造和原型链继承","time":" 2016-04-14 17:55:58","tags":" [javascript]","description":" javascript的对象构造和原型链继承","section":"这两天仔细地学习了JS的创建对象以及继承的方法，结合红宝石书整理了下笔记。\n（红宝石这里讲了非常多的模式，看第一遍觉得还蛮乱的）\nJavascript作为一种动态的面向对象语言，本身却没有类的概念和方法，\n在创建对象和继承方面有很多有趣的实现和方法\n<!--more-->\n## 1.原始绑定和字面量表示：\n**优点**：简洁方便\n**问题**：使用对象字面量的方法创建的对象，若重复创建会产生大量的重复代码\n```\nvar o = new Object();\no.name = 'shudery';\no.skill = function(){console.log('sayHello')};\n//这是比较老的方法，一般用下面这种简单粗暴的，直接字面量创建\n\nvar obj = {\n    sex = 'man',\n    skill = function(){console.log('tucao')} \n    ...\n}\n```\n## 2.工厂模式：\n抽象创建具体对象的过程\n**具体**：用函数来封装对象，然后调用特定接口创建对象\n**优点和问题**：解决代码重复性的问题，但是没有解决对象识别问题\n```\nfunction createObj(name){\n    var obj= {\n        name : name ,\n        skill : function(){console.log('tucao')}\n    };\n    return obj;\n}\nvar obj_1 = createObj('shudery');\nvar obj_2 = createObj('Lin'); \n//Object类型的对象\n```\n## 3.构造函数模式：\n使用`new`操作符，没有显式创建对象\n**优点**：解决了代码识别问题，可以将它构造的实例标示为特定类型\n**问题**：多次复用的方法需要在每个实例上重新创建一遍，浪费内存\n```\nfunction Myobj(name){\n        this.name = name,\n        this.skill= function(){console.log('tucao')}   \n}\nvar obj_1 =  new Myobj('shudery');\nvar obj_2 =  new Myobj('Lin');\n//对象类型名称为myObj，解决了识别的问题，用下面方法可以验证\nconsole.log(obj_1.constructor === Myobj && obj_2 instanceof Myobj);//true\n```\n这里如果怕遗漏new关键字，可以在`myObj`函数里头显示地返回一个对象，如下：\n```\nfunction Myobj(name){\n        var obj={};\n        obj.name=name,\n        obj.method= function(){\n        console.log('tucao')\n         }\n    return obj;\n}\nvar obj_1 = Myobj('shudery');\nvar obj_2 = new Myobj('shudery');\n```\n如果这么做`obj_1`的`constructor`指向的是`Object`\n这样就和工程模式一样不能识别对象，\n但是功能上两个对象相同，这也被叫寄生构造函数模式，一般不用它\n此外在构造函数模式下如果没有引用this和new，那就是稳妥构造函数模式，\n一般用在安全的环境\n\n## 4.原型模式：\n在构造函数模式下如果直接提取出方法函数到全局环境下，\n在方法变多时容易污染命名空间，\n此外不利于我们自定义的引用类型的封装。\n我们可以用JS的一大特色原型属性来挂载属性方法。\n**优点**：我们可以将复用的方法绑定到每一个构造函数定义的原型属性prototype上来，这样所有的对象实例都可以共享这个挂在这个原型下的属性和方法。\n**问题**：实例失去本身的特点和封装，公用一套属性和方法\n```\nfunction Myobj(){\n       \n}\nMyobj.prototype.name ='shudery';\nMyobj.prototype.age = '22';\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj();\n```\n也可用对象字面量形式，不过要注意顺序，字面量的形式相当于重写整个对象，\n构造函数原型的`constructor`属性（指向对象类型）会被重写为`Object`,\n而不是`Myobj`了\n```\nfunction Myobj(){\n       \n}\nvar obj =  new Myobj();//先实例化\nMyobj.prototype={\n//重写后这个原型和Myobj这个构造函数就没有关系了\n    name: 'shudery',\n    age:'22',\n    method : function(){\n    console.log('tucao')\n    }\n};\nobj.name;//undefined，联系被切断了\n```\n如果在重写之后实例化一个对象，虽然还存在联系，\n但是`obj`实例就不是`Myobj`类型了\n不在乎对象识别问题的话，也可以直接这样重写，仍能调用obj.name等属性和方法\n\n## 5.终极模式：构造函数+原型模式\n 最为常用的创建对象的方式，结合两种模式的优点，\n 实现对象属性的封装和对象方法的复用，\n平衡了对象的独立性和多态复用节省内存的问题。\n```\nfunction Myobj(name,age){\n    this.name =name;\n    this.age = age\n}\nMyobj.prototype.method = function(){\n    console.log('tucao')\n}\nvar obj =  new Myobj('shudery',22);\n```\n如此一来对象就拥有自定义的属性和可共享复用的方法啦\n有句话这样说，当我们把程序中变化的部分封装好之后，剩下的就是稳定可复用的了\n这也是很多种设计模式里推崇的，放到创建对象的方法里也是一样的做法。\n\n说完对象的创建，接下来是继承~\nJS是没有类的关键字和概念的，它的继承是基于原型链的，类似上面的原型模式\n我们先简单了解下原型链：\n\n![](https://raw.githubusercontent.com/shudery/public/master/clipboard.png)\n\n每个构造函数都有一个原型对象，构造的实例有一个指向原型对象的指针，\n如果我们把父类的实例赋值给原型对象，那么子类的原型对象就是父类的实例， \n那么这个实例还是有一个指向父类原型的指针，\n这些指针连起了子类和父类的实例（子类构造函数的原型），就是原型链。\n\n对象的方法和属性会循着原型链进行访问，直到查找到相应的属性和方法名，\n或者到达原型链的终点`Object.prototype`,这也就实现了继承\n\n\n\n\n\n\n\n\n\n\n"},{"header":" 搭建属于自己的vpn服务器","time":" 2016-06-10 21:59:48","tags":" [vpn]","description":" how to build vpn or vps by youself","section":"之前实习的时候想着有需要翻墙的时候用着公司的vpn就足够了\n但是随着马上要去工作，还有对一些国外资源的需求（资源你懂的）\n然后也前后被一些网上的vpn服务商坑过（各种掉线，不稳定）\n决定自己租用一台国外的服务器vps\n<!--more-->\n了解一番后知道了国外[搬瓦工](http://bandwagonhost.com/)和[digital ocean](www.digitalocean.com/?refcode=3491087221da)都有不错的口碑，最终选择DO,\n最便宜的512MB内存，20GB固态硬盘，1TB流量，\n\n这个好像只是防止恶意使用的，实际上流量是用不完的，\n在服务器控制版面也没有流量使用情况提示\n首先注册账号，输入邮箱密码，在邮箱收到确认邮件，\n来到Payment Methods \n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_1.png)\n\n这一项我选择的是方便快捷的PayPal，Credit不好设置\n需要预充5刀PayPal，5刀也是最便宜的服务器的月租价格，\n如果没有PayPal的话就先注册一次，比这个Credit方便多了\n注意一些老旧的银联卡号可能提示设置错误，我换了一张卡就好了\n\n然后开始选择服务器，包括价格，地点，系统，\n我选了最便宜已经够用了的5刀/月，ping后较快的美国西部服务器，\n以及比较容易操作的ubuntu系统，然后添加主机的SSH密钥，以后方便，\n\n不过也可以先跳过以后再说，买后会收到邮件，\n得到一个服务器主机Ip，root账户名，以及一个初始密码。\nvps算是有了，接下来我们在这台服务器上搭建vpn\n\n然后不得吐槽的是网页的console控制台实在有点卡卡，\n所以我用简单的putty来建立与vps的链接，也可以使用xshell等工具，\n下载putty后直接输入ip地址，保留默认端口，点击open就进入控制台了\n\n然后输入你的用户名root，然后出现password输入密码，\n这里注意啦~输入密码的时候，光标是不会动的！\n所以，慢慢输入，不要输错了，登录成功后显示一些信息\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_2.png)\n\n第一次登陆要求重置密码，分别填一次旧密码和两次新密码，注意光标还是不会移动！\n然后开始一列Linux操作，作为小白的我们就只管输入代码即可，\n不过我们也是有(yao)追(zhuan)求(bi)的小白，所以也要大概知道这些代码是个什么作用\n\n### 1、安装vpn服务\n首先我们必须在vps服务器上安装一种vpn服务，这里选择点对点隧道协议pptp,输入\n\n```\napt-get install pptpd\n```\n\n### 2、配置文件修改\n用vi编辑器打开配置文件，输入\n\n```\nvi /etc/pptpd.conf\n```\n\n没用过vi的注意啦，要编辑文件必须先输入i，进入INSERT模式，\n将光标移动到最下面更改\n\n```\nlocalip 10.0.0.1\nremoteip 10.0.0.100-200\n```\n\n有两段，localip更改为你vps服务器的ip地址，remoteip是以后分配给\n其他连到你vpn的服务器的ip，可以照着例子分配，写完后保存，\nvi的文件保存方法是先按Esc然后输入冒号:wq即可，w是写入保存，q是退出vi\n\n### 3、添加vpn账号\n用vi打开密钥文件，输入\n\n``` \nvi /etc/ppp/chap-secrets \n```\n\n依次输入 username pptpd password ### \n将username, password更换为你的vpn账号和密码，中间是服务名，\n最后一个是ip通配符，如果要建立多个vpn账号给妹子基友一起用，\n还一行依次输入即可，输完同样保存\n\n### 4、设置公共DNS服务，输入\n\n```\nvi /etc/ppp/pptpd-options\n```\n\n打开服务选项文件设置找到ms-dns并设置为\n`\nms-dns 8.8.8.8\nms-dns 8.8.4.4\n`\n\n### 5、重启pptp服务，\n重启服务，刷新配置，输入\n\n```\nservice pptpd restart\n```\n\n### 6、ip转发配置\n打开转发配置文件，输入\n\n```\nvi /etc/sysctl.conf\n```\n\n发现整个文件都带有注释符#,去掉`# net.ipv4.ip_forward = 1`\n前面的注释符#保存,为了使配置生效还需运行\n\n```\nsysctl -p\n```\n\n### 7、设置iptables\n设置并保存，运行\n\n```\niptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE && iptables-save\n```\n\n至此搭建好属于你自己的vpn，拿着账号在手机和电脑的vpn设置登录即可\n注意如果出现vpn隧道协议构建失败，检查一下网络适配器里vpn的安全属性\n勾选为以下选项\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_3.jpg)\n\n\n\n\n\n\n\n"},{"header":" Javascript开发跨平台桌面app","time":" 2016-06-23 23:32:17","tags":" [javascript,node]","description":" develop cross-platform GUI app with electron","section":"electron原本是atom shell的项目，由于集成node丰富的本地系统级API，\n提供了与操作系统交互的功能，所以归结起来，现在javascrpit的技术栈之所以如此宽广，\n要得益于NodeJS将其中浏览器的环境中分离出来\n\n不过需要特别说明的是，这里生成的桌面应用，\n实际上是Electron生成的一个由Javascrpit控制管理的迷你浏览器Chromeinum，\n它其实是一个Chrome浏览器的试验版本，当然用的也是V8的内核\n<!--more-->\n不管怎么说，这对于喜欢前端，熟悉javascript的同学来说，\n能够用前端和一点后台的知识去接触，尝试各种不同的领域，实在是不要太爽\n\nElectron的入门也符合前端知识领域的特点，几乎没有门槛，\n只要你有一点JS和Node的基础就行了，开发目录的文件层次结构也很简单，\n后面会有打包工具帮助我们一键打包生成层次比较复杂的项目文件，\n作为桌面GUI应用，当然也包括.exe的启动文件，\n\n让我们看看如何开发一个桌面应用，或者说一个能和操作本地系统的web页面的基本方法~\n你可以跟着步骤完成一些基本的文件，也可以直接下载[快速开始的demo](https://github.com/shudery/electron/archive/master.zip)\n基本的文件层次很简单，用app存放一个具体的桌面应用，具体结构是这样的\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_1.png)\n\nOutApp用来存放打包输出的exe文件\n至于为什么有两个``package.json``文件，后面打包操作时你就知道了\n\n### 1、首先安装electron\n命令行进入根目录，先用npm安装electron，如果还没有就先[安装node](https://nodejs.org/en/)\n```\nnpm install -g electron-prebuilt\n```\n### 2、生成``package.json``配置文件\n运行``npm init`` 生成一个``package.json``文件来存放应用的相关配置，这个是第一个``package.json``文件，位于外层根目录下的，运行 \n```\nnpm install --save-dev electron-prebuilt  \n```\n会在devDependencies中生成依赖信息，方便后面打包\n```\n{\n  \"name\": \"firstGUI\",\n  \"version\": \"1.0.0\",\n  \"main\": \"app/main.js\",//js入口文件\n  \"scripts\": {\n    \"build\": \"electron-packager ./app firstApp --platform=win32 --arch=x64 --out ./OutApp --version 0.37.3 --overwrite --icon=./app/img/daguo. jpg\",\n    //打包命令，后面打包可以简化代码\n  },\n  \"devDependencies\": {\n    \"electron-prebuilt\": \"^1.2.0\"\n  }\n}\n```\n### 3、新建main.js\n生成一个入口的js文件来作为控制GUI窗口的主进程程序\n```\nconst electron = require('electron');\n// 控制应用生命周期的模块\nconst {app} = electron;\n// 创建本地浏览器窗口的模块\nconst {BrowserWindow} = electron;\n// 指向窗口对象的一个全局引用\nlet win;\n\nfunction createWindow() {\n\n // 创建一个新的浏览器窗口\n  win = new BrowserWindow({ width: 360, height: 572 });\n // 并且装载应用的index.html页面,注意路径\n  win.loadURL('file://'+__dirname+'/html/index.html');\n // 当窗口关闭时调用的方法\n\n  win.on('closed', () => {\n  // 解除窗口对象的引用，通常而言如果应用支持多个窗口的话，你会在一个数组里\n  // 存放窗口对象，在窗口关闭的时候应当删除相应的元素。\n  win = null;\n  });\n}\n\n// 当Electron完成初始化并且已经创建了浏览器窗口，则该方法将会被调用。\n// 有些API只能在该事件发生后才能被使用。\napp.on('ready', createWindow);\n\n// 当所有的窗口被关闭后退出应用\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\napp.on('activate', () => {\n  if (win === null) {\n    createWindow();\n  }\n});\n// 在这个文件后面你可以直接包含你应用特定的由主进程运行的代码。\n// 也可以把这些代码放在另一个文件中然后在这里导入。\n```\n### 4、index.html\nGUI窗口（web页面）渲染的Html文件\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>firstGUI</title>\n  </head>\n  <body>\n    <h1 style=>Hello World!</h1>\n  </body>\n</html>\n```\n\n### 5、运行桌面app\n大公告成，没错就是如此之快，运行``electron .``（跟一个空格和小点），或者``electron app/main``\n打开制作好的GUI界面，so cool~\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_2.png)\n\n### 6、进行打包\n既然是桌面应用，那肯定是要一键运行的，不需要安装什么依赖模块，\n也不需要运行命令行程序的，所以为了提升逼格，让更多的人可以方便实用你的桌面app，\n需要对app文件夹进行打包，安装打包程序 ``electron-packager``\n```\nnpm install --save-dev electron-packager\n```\n打包的基本命令是 \n```\nelectron-packager <location of project> <name of project> <platform> <architecture> <electron version><optional options>\n```\n上面已经在``package.json``的script里配置了简化的命令，可以根据自身情况对名称，操作系统，应用图标进行修改，\n注意啦开始打包前，一定要复制一份``package.json``到app文件，\n前面说了桌面应用不用下载依赖，其实是因为打包的时候就将依赖一同打包到文件包里了，\n所以我们要打包app文件夹下的文件，需要一个``package.json``  来说明依赖项，注意修改里面的路径，要往下一级，然后运行``npm packager``\n\n![](https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_3.png)\n\n完成打包后可以看到OutApp里头已经有了相应的文件，\n运行里面的exe文件会生成和本地测试时一样的GUI窗口~\n\n\n一个简单的基于前端技术栈的桌面app算是完成了，后续的asar文件加密，\n用nsis制作一个安装引导等等~有兴趣的可以继续完善~\n\n一个桌面级app当然不是用来显示``hello world``的，那样和web页面有什么区别，\n这里只是我入门的一个学习记录，一个基于electron的桌面应用\n还有着非常丰富的与系统交互功能可以设计和开发~\n更加详细的用法和配置有兴趣的同学不妨看看官方的[api演示文档](http://electron.atom.io/)，\n它也是一个基于electron做的桌面app\n\n"},{"header":" 最近的npm模块风波","time":" 2016-04-04 17:53:38","tags":" [npm,modules]","description":" npm导致我们不会写代码了？","section":"最近，前端圈子有件事闹得沸沸扬扬，有一个叫做`leftpad`的npm模块被作者撤下，\n导致一系列引用该模板的项目出现问题。\n\n其实本来大家对这件事的重点应该是关于NPM管理者对于模块作者著作权的保护不周上的，\n但是可能由于这个模块的特殊性和他造成的影响之间的对比太强烈，\n让大家都把注意力放到了这个模块本身和引用这个模块的做法上来了。\n<!--more-->\n**这个模块只有短短十一行，仅仅实现一个简单的字符串左侧填充的功能！**\n\n如此简单的模块为什么那么多项目都要引用他呢？\n其实如果不出现作者`unpublish`的问题，大家不会对这样的做法有太多的疑问，\n因为NodeJS的特色就是如此嘛，而且npm的引用和配置下载也非常方便， \n即使是再简单的模块，我若引用也就是`require`一下，然后将依赖写到json里，\n还是比自己写实现函数要方便一些，虽然方便得不多。\n总之就是不出事还好，一出事，那不好意思就得有人负责，\n这件事没有主要负责人，那么就得有问题被抛出。\n\n所以最近这几天抛出的最多的一个问题就是，**对于简单的代码我们仍要引用模块吗？**\n\n\n首先我觉得像这次又模块被作者下架，这毕竟是少数事件，\n我们不应该讨论对于npm的信任问题，这样会使我们在引用模块时畏手畏脚，\n有人说你简单的函数方法自己写嘛，复杂的再引用别人的，\n就是减少引用，就减少了出了事摊上你的概率，\n我只想说在小概率事件中减小该事件的概率--无关痛痒。\n\n\n总之我对npm模块的引用还是持比较乐观的态度，\nnpm的社区非常繁荣，拥有大批的贡献者，我觉得就是即使是再小的一个模块，\n你写出来了就可以`publish`上去，就可以给别人引用，每个人都有发光发热的机会，\n这给作者多大的鼓励和成就感啊，别人用后也会给你反馈，你再去不断改善，\n大家也可以在`review`其他模块代码中得到非常多的编程技术和思想。\n\n\n与对引用小模块的质疑相反，我觉得引用大模块的问题似乎更多，\n一个项目中引用的大模块往往并不需要里面的很多功能，\n所以NodeJS才在新版中将核心模块分割成多份，大家需要用啥再引用那个模块，\n这样就避免了项目庞大引起的各模块之间可能出现的兼容问题，\n也不至于使得代码太臃肿，至于对小模块引用可能导致require和模块依赖过大，\n但是代码依然比较精简，代码的冗余也比较少。\n\n\n最后，关于npm模块的引用，小模块如果有用过或已经知道的精巧模块，\n不仿大胆引用，若是不清楚也不必特意查询，简单的功能自己想方法实现即可，\n大模块如果与项目的配合不好，该分解的最好分解，结合项目和自身的编程习惯，\n高效的完成项目。\n以上仅仅是个人愚昧的一些看法。\n\n"},{"header":" 用hexo搭建一个博客","time":" 2016-05-05 12:00:33","tags":" [hexo,node,git]","description":" 如何用hexo来搭建一个博客","section":"hexo出自一位台湾大学生之手，是如今搭建，管理博客，发布文章的非常好用的工具，\n之前一直想搭建一个不依赖后台，便于管理和发布的博客，在朋友推荐下用了hexo\n确实是简单粗暴好用~\n基于hexo的博客搭建，对于已经配备了Node环境和git的前端开发人士，\n搭建出一个博客那就是分分钟的事情，即使还没有弄好这些也不难搭建，\n下面就从头大致说一说搭建的流程。\n<!--more-->\n### 创建一个github账号和博客\nhexo搭建的博客是一个静态页面，可以直接托放到github上面的服务器上，\n不需要拥有自己的服务器，所以我们要先有一个github账号，\n然后需要生成一个github的博客，之后我们用自己定制的hexo博客来替换它，\n如何搭建github技术博客可以看看这篇:[创建GitHub技术博客全攻略](http://blog.csdn.net/renfufei/article/details/37725057/)\n### 搭建Node环境\n我们还需要一个运行hexo和调试的环境，就是用Nodejs，\n在[官网地址](https://nodejs.org/en/)选一个稳定版或者开发版一键安装好环境。\n### 安装Hexo，生成文章\n准备好nodejs之后打开命令行使用Node的包管理工具npm,直接在命令行运行\n``\nnpm install -g hexo\n``\n\n下载hexo，然后再在相应的目录运行\n``\nhexo init\n``\n\n即可一键生成文件结构，你可以看到在source/_posts里面有一篇默认的helloworld.md文章，\n在themes里面有一个默认的主题landscape，再继续运行\n``\nhexo generate\n``\n\n### 调试，部署到git\n上面过程之后即可生成一个Public文件，里面会有你的文章内容，然后就可以运行\n``\nhexo server\n``\n\n启动localhost:4000，在浏览器输入地址就可以看到你的博客效果了，\n如果你对默认的配置都满意的话下一步就是运行\n``\nhexo deploy\n``\n\n将内容部署到github上面去了，但是我们好像还没有建立hexo和我们账号github仓库的链接，\n所以要在_config.yml最下面进行一些配置\n```\ndeploy:\n  type: git\n  repo: git@github.com:shudery/shudery.github.io.git # 换成你的博客仓库地址\n  branch: master\n```\n然后再hexo deploy即可完成部署，注意用ssh地址可以免去输入密码的繁琐，\n当然前提是要先生成ssh密钥，并且在你的github上面添加这个ssh密钥~\nhexo博客就已经搭建完成，可以在shudery.github.io上面看到博客页面和文章效果\n### 添加文章，更换主题，修改配置\n基本的东西就是这样，接下来我们可以在_posts里面以markdown的写作形式写文章，\n然后通过同样的方式生成，部署，可以直接在_posts里新建md文件，\n也可以用运行\n``\nhexo new [fileStyle] [fileName]\n``\n\n的方式来生成文件，后者会以scaffolds中对应的fileStyle的形式，\n给你生成一个fileName的md文件，里面会包括一些开头的默认字段，\n会方便记录一些文章的信息，我们还可以在[官网主题](https://hexo.io/themes/)里找一个更加符合心意的主题，\n然后直接git clone/ctrl+c 到我们hexo/themes下面，\n然后在hexo/_config.yml中的 theme:landscape 改为你下载好的主题名，\n然后你会发现主题文件夹里还有一个_config.yml 用来修改主题的一些相关配置，\n你可以参考你下载主题的github,或者官网的介绍来设置这些配置~\n### 完善博客\n最后你可以根据自己的喜好和需求为博客添加一些你喜欢的挂件和工具，\n我自己加了多说评论，百度统计，还有就是换了一个逼格高一点的域名，\n通过添加CNAME域名解析，重定向到github.io的博客地址上面。\n\n搭建过程中一些tips~\n\n* hexo clean会清理缓存和Public文件夹一般是在hexo generate之前使用，但是不用没啥问题\n* hexo/_config.yml对于hexo非常重要，但是如果去掉_config.yml你会发现还是依然能运行各种命令\n* 然而一般运行时报错都是config配置有问题，而且很不好定位，\n  所以可以注释掉config.yml里面你觉得应该不会导致报错的配置，然后再运行看结果，\n  重复几次就可以定位到问题了，这对一开始没有什么经验的人来说是一个可行的debug方法。\n* 在做域名重定向的时候，域名解析的CNAME需要指向github.io，\n  此外还要在hexo/source下面也建立一个CNAME文件指向你的设置了重定向的域名地址才行"}]